- en: 【双语字幕+资料下载】Python 3全系列基础教程，全程代码演示&讲解！10小时视频42节，保证你能掌握Python！快来一起跟着视频敲代码~＜快速入门系列＞
    - P20：20）全局关键字 - ShowMeAI - BV1yg411c7Nw
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 【双语字幕+资料下载】Python 3全系列基础教程，全程代码演示&讲解！10小时视频42节，保证你能掌握Python！快来一起跟着视频敲代码~＜快速入门系列＞
    - P20：20）全局关键字 - ShowMeAI - BV1yg411c7Nw
- en: '![](img/d5b9b4b1de0f36c8a154c3be6260d944_0.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5b9b4b1de0f36c8a154c3be6260d944_0.png)'
- en: Welcome back everyone， my name is Brian， we're going to continue our journey
    to Python 3 with the global keyword。 This is extremely cool， it's extremely easy
    and it solves a complex problem。😊，For example。 we've seen this code before。 X
    is1。 We have a function x is 6。 If we run this。 what's going to happen。Let's find
    out。 So we have6 and one。 Basically， X is two different variables。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎回来，大家好，我是Brian，我们将继续探索Python 3与全局关键字。这非常酷，非常简单，并解决了一个复杂的问题。😊例如，我们之前见过这段代码。X是1。我们有一个函数x是6。如果我们运行这个，结果会怎样？让我们找出答案。所以我们有6和1。基本上，X是两个不同的变量。
- en: and they're being treated different because it's two different scopes。 Remember。
    whenever you're defining a function， you're actually defining a scope。 So what
    the global keyword allows us to do is actually modify variables at。 Well， you
    guessed it。 the global scope。 Let's dive in and take a look。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的处理方式不同，因为这是两个不同的作用域。记住，每当你定义一个函数时，你实际上是在定义一个作用域。所以，全局关键字允许我们修改变量。没错，就是全局作用域。让我们深入看看。
- en: '![](img/d5b9b4b1de0f36c8a154c3be6260d944_2.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5b9b4b1de0f36c8a154c3be6260d944_2.png)'
- en: '![](img/d5b9b4b1de0f36c8a154c3be6260d944_3.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5b9b4b1de0f36c8a154c3be6260d944_3.png)'
- en: Okay， in case you skipped that video on scope， what we're really diving into
    here is。Well。 blocks of code。 we're defining a function， which has its own scope。
    The problem is Python is lexically or statically scoped， which means if we run
    this。 we have two different variables。 However， this is frustrating。 If you comment
    at this out。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果你跳过了关于作用域的视频，我们真正要深入探讨的是代码块。我们正在定义一个有自己作用域的函数。问题是Python是词法或静态作用域，这意味着如果我们运行这个，我们有两个不同的变量。然而，这很令人沮丧。如果你注释掉这个。
- en: It's going to access the global scope。 So what we want to do is to be able to
    access and modify。 and that's what the global keyword does。 So first things first。
    now that we understand that basic premise， let's go ahead and test this code。
    Sure enough，1，1。 we can access at a higher scope。 Let's figure out how to modify。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 它将访问全局作用域。因此，我们想要能够访问和修改，这正是全局关键字的作用。所以，首先，现在我们理解了这个基本前提，先来测试一下这段代码。果然，1，1。我们可以在更高的作用域中访问。让我们看看如何修改。
- en: let's go ahead and make a global variable。Good that's it。 It's really that easy
    Just because we put it on this very first line。 There's no padding。 This is just
    right at the edge of the file here。 That is now considered in the global scope。Let's
    take a look at the scope issues in depth here，Let's say scope issues。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来定义一个全局变量。好，这就行了。其实真的是这么简单。仅仅因为我们把它放在这一行。没有多余的填充。这就是在文件的边缘。这现在被视为全局作用域。让我们深入看看作用域问题，假设作用域问题。
- en: And let's make a function called count。Which is going to have some type of maximum
    number that we're going to count to。Now， without the global keyword， Python is
    going to get very， very confused very， very fast。let's go and demonstrate that。
    So I'm going to say。Counter。Equals， actually。 little'll do plus equals。 We're
    just going to increment this right off the bat here。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来定义一个名为count的函数，它将有一个最大计数的数字。现在，如果没有全局关键字，Python会非常非常快地变得混乱。我们来演示一下。因此，我会说，Counter。等于，实际上，little'll做加等于。我们将立即增加这个值。
- en: And sometimes Python will' let you do it。 Sometimes it's not。 Other times it's
    going to just completely freak out and not have a clue what you're doing。 But
    before we even run this， you can see right now， it's saying。Undefined variable
    counter。 And this is perplexing because it's literally right here。So remember
    our conversation。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有时Python会让你这样做，有时不会。其他时候它会完全崩溃，搞不清楚你在做什么。但在我们运行之前，你现在可以看到，它说，未定义变量counter。这令人困惑，因为它就在这里。所以记住我们的对话。
- en: we're accessing it。 But now it's suddenly saying， well， who， it's not defined。That
    is frustrating。 Let's go ahead and try and run that， let'd say。Out。And let's just
    try to count one just to see what happens here。O oh， unbound local variable。 local
    error。 sorry， Local variable counter reference before assignment。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在访问它。但现在它突然说，哦，它没有定义。这令人沮丧。让我们试着运行它，假设我们说，输出。我们只是尝试计数一次看看会发生什么。哦，未绑定的局部变量，局部错误。抱歉，局部变量counter在赋值前被引用。
- en: Referenced before assignment really is our clue as to what's going on here。What
    it's saying is。It is now making a new variable。And then trying to increment it
    before we've actually assigned it。 So remember， Python types are a little bit。
    Well， a mystery。 We don't know if that's a string。 a bull actually as soon as
    it's created， it's an undefined。 So if you take undefined。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的赋值前引用真的给了我们线索，说明这里发生了什么。它所说的是。现在正在创建一个新变量。然后试图在我们实际赋值之前对其进行递增。所以记住，Python的类型有点。好吧，是个谜。我们不知道那是一个字符串。实际上，一旦它被创建，它就是未定义的。所以如果你取未定义的。
- en: and you try to add one to it， what is the expected behavior。Remember， undefined
    is not0。 It's just simply there's nothing， literally nothing。 It has no idea what
    type it is。So Python' is going to get super confused， super， super fast。And let's
    just continue on with typing away here just to see how bad this can get we're
    going to say。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试给它加一，预期的行为是什么？记住，未定义并不是0。它只是简单地什么都没有，字面上什么都没有。它根本不知道它是什么类型。因此，Python会变得非常困惑，非常、非常快。让我们继续输入，看看这会变得多糟，我们要说。
- en: Counter。Is greater than or equal to the max， Then let's just go ahead and return
    false。Otherwise。 we're just going to return true。See， same problem。 So right here，
    it thinks it's just fine。 it actually knows it's an integer， but right here， it's
    saying it's undefined。 This is what I mean by Python gets very confused very，
    very quickly。Oh， that is frustrating。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器。如果大于或等于最大值，那么我们就直接返回false。否则，我们就返回true。你看，问题相同。所以在这里，它认为没问题。它实际上知道这是一个整数，但在这里，它却说这是未定义的。这就是我所说的Python会非常快地变得非常困惑。哦，这真让人沮丧。
- en: So we're going to fix this problem by saying。Logo。Mouner。And notice it's got
    the exact same name。So really what we're doing is we're saying use the global
    variable called counter and give it this same name here。Save that。 And as soon
    as you save it， you notice in telecentense is smart enough to know that， hey。
    this is actually defined now and we can start working with it， and it knows it's
    an integer。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们要通过说。Logo。Mouner来修复这个问题。注意它有完全相同的名称。所以我们实际上是在说使用名为计数器的全局变量，并在这里赋予它同样的名称。保存它。保存后，你会注意到IntelliSense足够聪明地知道，嘿。这实际上是现在定义的，我们可以开始使用它，而且它知道这是一个整数。
- en: Let's go ahead and just see the global keyword in action here。 I'm going to
    make a variable called limit。 It's going to be 5。And I want to increment our counter
    using that。 So Im say 4 x in range。And we're going to use our limit。Go ahead and
    get a variable from that function。Using that limit。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看全局关键字在这里的实际应用。我将创建一个名为limit的变量。它将是5。我想用这个来递增我们的计数器。所以我说4 x在范围内。我们将使用我们的限制。从那个函数中获取一个变量。使用那个限制。
- en: Let's go ahead and print it out。Or print out our counter。And just for giggles。
    let's go ahead and print out。Just done。 So we can see it actually worked。Go ahead
    run， Sure enough。 Oh，'m done。 So it's working as expected now， and it's all because
    of this simple little keyword right here。Now， standard practice， I tend to avoid
    modifying global variables inside of a function for this very reason。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印出来。或者打印我们的计数器。为了好玩，让我们打印出来。完成。所以我们可以看到它确实有效。继续运行，果然。哦，我完成了。所以现在一切都按预期工作，这一切都要归功于这个简单的小关键字。在标准实践中，我倾向于避免在函数内部修改全局变量，正是出于这个原因。
- en: for example， let's just say。I want to grab this。And make an entire new function
    out of it。 And I go。 home， I don't need that global。 I just want a variable called
    counter。 And I don't need that。 Now。 suddenly， you guessed it， we are right back
    to the exact same issue。 So now it gets very confusing about which counter we're
    talking about and in which function。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，假设。我想抓住这个。并把它做成一个完整的新函数。我去。家里，我不需要那个全局变量。我只想要一个名为计数器的变量。我不需要那个。现在，突然，你猜到了，我们又回到了同样的问题。所以现在很难搞清楚我们在谈论哪个计数器以及在什么函数中。
- en: You can very easily fix it by just doing this， but then of course。 now you're
    going back to modifying a global variable。 which is not really a good programming
    practice。When in doubt。 we're going to have a conversation about encapsulation
    later。 but you want to encapsulate or use pretty much everything internal to your
    scope without going up modifying other scopes。![](img/d5b9b4b1de0f36c8a154c3be6260d944_5.png)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地通过这样做来修复它，但当然。现在你又回到了修改全局变量，这实际上不是一个好的编程实践。当你有疑问时。我们稍后会讨论封装，但你希望封装或使用几乎所有内部作用域的内容，而不是去修改其他作用域。![](img/d5b9b4b1de0f36c8a154c3be6260d944_5.png)
