- en: ã€åŒè¯­å­—å¹•+èµ„æ–™ä¸‹è½½ã€‘ç”¨ Python å’Œ Numpy å®ç°æœ€çƒ­é—¨çš„12ä¸ªæœºå™¨å­¦ä¹ ç®—æ³•ï¼Œå½»åº•ææ¸…æ¥šå®ƒä»¬çš„å·¥ä½œåŸç†ï¼ï¼œå®æˆ˜æ•™ç¨‹ç³»åˆ—ï¼ - P13ï¼šL13-
    Kå‡å€¼ - ShowMeAI - BV1wS4y1f7z1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ã€åŒè¯­å­—å¹•+èµ„æ–™ä¸‹è½½ã€‘ç”¨ Python å’Œ Numpy å®ç°æœ€çƒ­é—¨çš„12ä¸ªæœºå™¨å­¦ä¹ ç®—æ³•ï¼Œå½»åº•ææ¸…æ¥šå®ƒä»¬çš„å·¥ä½œåŸç†ï¼ï¼œå®æˆ˜æ•™ç¨‹ç³»åˆ—ï¼ - P13ï¼šL13-
    Kå‡å€¼ - ShowMeAI - BV1wS4y1f7z1
- en: Hi everybody and welcome to a new machine learning from Sct tutorial Todayã€‚
    we are going to implement the K means algorithm using only built and Python modules
    and Nmpyã€‚ The goal of the K means is to cluster a data set into K different clusters
    and here we have a unlabeled dataset setã€‚ So we are dealing with an unsupervised
    learning technique and each sample should be assigned to the cluster with the
    nearest mean So let's have a look at some images to see what this meansã€‚
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§å®¶å¥½ï¼Œæ¬¢è¿æ¥åˆ°æ–°çš„æœºå™¨å­¦ä¹ æ•™ç¨‹ã€‚ä»Šå¤©ï¼Œæˆ‘ä»¬å°†ä»…ä½¿ç”¨å†…ç½®å’ŒPythonæ¨¡å—ä»¥åŠNumpyå®ç°Kå‡å€¼ç®—æ³•ã€‚Kå‡å€¼çš„ç›®æ ‡æ˜¯å°†æ•°æ®é›†èšç±»ä¸ºKä¸ªä¸åŒçš„èšç±»ï¼Œè¿™é‡Œæˆ‘ä»¬æœ‰ä¸€ä¸ªæœªæ ‡è®°çš„æ•°æ®é›†ã€‚æ‰€ä»¥æˆ‘ä»¬æ­£åœ¨å¤„ç†ä¸€ç§æ— ç›‘ç£å­¦ä¹ æŠ€æœ¯ï¼Œæ¯ä¸ªæ ·æœ¬åº”è¯¥åˆ†é…ç»™ä¸å…¶æœ€è¿‘çš„å‡å€¼çš„èšç±»ã€‚è®©æˆ‘ä»¬çœ‹çœ‹ä¸€äº›å›¾åƒä»¥äº†è§£è¿™æ„å‘³ç€ä»€ä¹ˆã€‚
- en: So here we have our unlabeled data and now in this case we want to find three
    different clusters So should look like thisã€‚And then we assign the labels to the
    closest clusterï¼Œ so to the center of the closest clusterã€‚So yeahï¼Œ this is what
    we want to do and how are we going to achieve this So this is an iterative optimization
    techniqueã€‚ so first we initialize our cluster centers so we randomly pick some
    samples and say these are our first centers and then we do these two steps until
    we are conversedã€‚
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯æˆ‘ä»¬çš„æœªæ ‡è®°æ•°æ®ï¼Œç°åœ¨åœ¨è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬æƒ³æ‰¾åˆ°ä¸‰ä¸ªä¸åŒçš„èšç±»ã€‚æ‰€ä»¥åº”è¯¥çœ‹èµ·æ¥åƒè¿™æ ·ã€‚ç„¶åæˆ‘ä»¬å°†æ ‡ç­¾åˆ†é…ç»™æœ€è¿‘çš„èšç±»ï¼Œå³æœ€è¿‘èšç±»çš„ä¸­å¿ƒã€‚æ‰€ä»¥è¿™æ˜¯æˆ‘ä»¬æƒ³è¦åšçš„ï¼Œæˆ‘ä»¬å°†å¦‚ä½•å®ç°è¿™ä¸€ç‚¹ã€‚è¿™æ˜¯ä¸€ç§è¿­ä»£ä¼˜åŒ–æŠ€æœ¯ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬åˆå§‹åŒ–èšç±»ä¸­å¿ƒï¼Œéšæœºé€‰æ‹©ä¸€äº›æ ·æœ¬å¹¶è¯´è¿™äº›æ˜¯æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªä¸­å¿ƒï¼Œç„¶åæˆ‘ä»¬æ‰§è¡Œè¿™ä¸¤ä¸ªæ­¥éª¤ï¼Œç›´åˆ°æ”¶æ•›ã€‚
- en: So firstï¼Œ we update our cluster labelsï¼Œ which means we assign the points to
    the nearest cluster centerã€‚And the cluster sender is also called centroidã€‚And
    nextï¼Œ we update our centroidsã€‚ So now we set the centerï¼Œ the new center to the
    mean of each clusterã€‚ and we iteratively do this until there's no more changeã€‚
    So let's againã€‚
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬æ›´æ–°æˆ‘ä»¬çš„èšç±»æ ‡ç­¾ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å°†ç‚¹åˆ†é…ç»™æœ€è¿‘çš„èšç±»ä¸­å¿ƒã€‚èšç±»ä¸­å¿ƒä¹Ÿç§°ä¸ºè´¨å¿ƒã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ›´æ–°æˆ‘ä»¬çš„è´¨å¿ƒã€‚ç°åœ¨æˆ‘ä»¬å°†æ–°çš„ä¸­å¿ƒè®¾ç½®ä¸ºæ¯ä¸ªèšç±»çš„å‡å€¼ï¼Œæˆ‘ä»¬é‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œç›´åˆ°æ²¡æœ‰æ›´å¤šå˜åŒ–ã€‚è®©æˆ‘ä»¬å†æ¥ä¸€æ¬¡ã€‚
- en: have a look at the images to see how this is workingã€‚ So firstï¼Œ we have our
    unlabeled data setã€‚And now we randomly pick three centroidsã€‚ So here I've drawn
    themã€‚ So I hope you can see themã€‚ So these are our initial centroidsã€‚ And now
    we assign the labels to theã€‚Of the data to theã€‚ to the label of the closest centroidã€‚
    So this is our first initializationã€‚
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹ä¸€ä¸‹å›¾åƒä»¥äº†è§£è¿™ä¸ªæ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬æœ‰æˆ‘ä»¬çš„æœªæ ‡è®°æ•°æ®é›†ã€‚ç°åœ¨æˆ‘ä»¬éšæœºé€‰æ‹©ä¸‰ä¸ªè´¨å¿ƒã€‚è¿™é‡Œæˆ‘ç”»äº†å®ƒä»¬ã€‚æˆ‘å¸Œæœ›ä½ èƒ½çœ‹åˆ°å®ƒä»¬ã€‚è¿™äº›æ˜¯æˆ‘ä»¬çš„åˆå§‹è´¨å¿ƒã€‚ç°åœ¨æˆ‘ä»¬å°†æ ‡ç­¾åˆ†é…ç»™æ•°æ®ä¸­ä¸æœ€è¿‘è´¨å¿ƒçš„æ ‡ç­¾ã€‚è¿™æ˜¯æˆ‘ä»¬çš„ç¬¬ä¸€æ¬¡åˆå§‹åŒ–ã€‚
- en: And now we start optimizingã€‚ So now we update our centroidsã€‚ So we calculate
    the new mean for each clusterã€‚ So I think this centroid will be moved to something
    like hereã€‚ And this will maybeï¼Œ maybe be hereã€‚ And the green centroid will be
    moved to maybe hereã€‚ So let's see what's happeningã€‚ Yeahï¼Œ so this is the new centroidsã€‚And
    now we update our labelã€‚
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¼€å§‹ä¼˜åŒ–ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æ›´æ–°æˆ‘ä»¬çš„è´¨å¿ƒã€‚æˆ‘ä»¬è®¡ç®—æ¯ä¸ªèšç±»çš„æ–°å‡å€¼ã€‚æˆ‘è®¤ä¸ºè¿™ä¸ªè´¨å¿ƒä¼šç§»åŠ¨åˆ°è¿™é‡Œï¼Œè€Œè¿™ä¸ªå¯èƒ½ä¼šåœ¨è¿™é‡Œã€‚ç»¿è‰²è´¨å¿ƒå¯èƒ½ä¼šç§»åŠ¨åˆ°è¿™é‡Œã€‚è®©æˆ‘ä»¬çœ‹çœ‹å‘ç”Ÿäº†ä»€ä¹ˆã€‚æ˜¯çš„ï¼Œè¿™æ˜¯æ–°çš„è´¨å¿ƒã€‚ç°åœ¨æˆ‘ä»¬æ›´æ–°æˆ‘ä»¬çš„æ ‡ç­¾ã€‚
- en: our labelsã€‚ So now we check which is the closest centroid for each labelã€‚ so
    maybe these will become blue and more of these will become orangeã€‚So yeahï¼Œ this
    is the next stepã€‚ And now againï¼Œ we update our centroidã€‚ So I think this one will
    further move to to the rightã€‚And this one will move up here and this one will
    maybe stay the sameã€‚ So yeahï¼Œ this is the next stepã€‚
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„æ ‡ç­¾ã€‚æ‰€ä»¥ç°åœ¨æˆ‘ä»¬æ£€æŸ¥æ¯ä¸ªæ ‡ç­¾çš„æœ€è¿‘è´¨å¿ƒã€‚ä¹Ÿè®¸è¿™äº›ä¼šå˜æˆè“è‰²ï¼Œè€Œæ›´å¤šçš„ä¼šå˜æˆæ©™è‰²ã€‚æ‰€ä»¥è¿™æ˜¯ä¸‹ä¸€æ­¥ã€‚ç°åœ¨å†æ¬¡æ›´æ–°æˆ‘ä»¬çš„è´¨å¿ƒã€‚æˆ‘è®¤ä¸ºè¿™ä¸ªä¼šè¿›ä¸€æ­¥å‘å³ç§»åŠ¨ï¼Œè€Œè¿™ä¸ªä¼šå‘ä¸Šç§»åŠ¨ï¼Œè¿™ä¸ªå¯èƒ½ä¼šä¿æŒä¸å˜ã€‚æ‰€ä»¥è¿™æ˜¯ä¸‹ä¸€æ­¥ã€‚
- en: And now againï¼Œ we update the labelsã€‚ So I think these will become orange nowã€‚
    and these will become blueã€‚ and now we are almost doneã€‚ So maybe here are some
    slight shiftsã€‚ So againï¼Œ update the centroidsã€‚ then againï¼Œ the labels then the
    centroids than the labels And now there's no more changeã€‚ So now we are convergedã€‚And
    yeahï¼Œ so this is the whole approachã€‚
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨å†æ¬¡æ›´æ–°æ ‡ç­¾ã€‚æˆ‘è®¤ä¸ºè¿™äº›ç°åœ¨ä¼šå˜æˆæ©™è‰²ï¼Œè€Œè¿™äº›ä¼šå˜æˆè“è‰²ã€‚ç°åœ¨æˆ‘ä»¬å‡ ä¹å®Œæˆäº†ã€‚ä¹Ÿè®¸è¿™é‡Œæœ‰ä¸€äº›å¾®å°çš„å˜åŒ–ã€‚å†æ¬¡æ›´æ–°è´¨å¿ƒï¼Œç„¶åå†æ¬¡æ›´æ–°æ ‡ç­¾ï¼Œç„¶åæ˜¯è´¨å¿ƒï¼Œç„¶åæ˜¯æ ‡ç­¾ã€‚ç°åœ¨æ²¡æœ‰æ›´å¤šå˜åŒ–ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å·²ç»æ”¶æ•›äº†ã€‚è¿™å°±æ˜¯æ•´ä¸ªæ–¹æ³•ã€‚
- en: And the only math that we need for this is the Euclidean distanceã€‚ So I already
    showed you this in the tutorial about the Can nearest navaã€‚Algorithmã€‚ the Euclidean
    distance between two vectors is defined as the square root of the sum over the
    squared distancesã€‚
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦çš„å”¯ä¸€æ•°å­¦æ˜¯æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚æ‰€ä»¥æˆ‘åœ¨å…³äºKè¿‘é‚»ç®—æ³•çš„æ•™ç¨‹ä¸­å·²ç»å‘ä½ å±•ç¤ºè¿‡è¿™ä¸ªã€‚ä¸¤ä¸ªå‘é‡ä¹‹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»å®šä¹‰ä¸ºå¹³æ–¹å’Œçš„å¹³æ–¹æ ¹ã€‚
- en: '![](img/b78b3a13800e496c831fda09c2e14c17_1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b78b3a13800e496c831fda09c2e14c17_1.png)'
- en: So this is all we needã€‚ So now we can startã€‚ So let's import nuy as N Pï¼Œ of
    courseã€‚ And then I will sayï¼Œ I will set a random seat toï¼Œ let's say 42ï¼Œ you don't
    need thisã€‚ but I want to reproduce my data laterã€‚ And since we are using a random
    initializationã€‚ I want toã€‚ to have the same resultsï¼Œ or I want toã€‚To reproduce
    my resultsã€‚ So I will set a random seat hereã€‚
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯æˆ‘ä»¬æ‰€éœ€çš„ä¸€åˆ‡ã€‚æ‰€ä»¥ç°åœ¨æˆ‘ä»¬å¯ä»¥å¼€å§‹ã€‚è®©æˆ‘ä»¬å¯¼å…¥nuyä½œä¸ºN Pï¼Œå½“ç„¶ã€‚ç„¶åæˆ‘ä¼šè¯´ï¼Œæˆ‘å°†è®¾ç½®ä¸€ä¸ªéšæœºç§å­ï¼Œå‡è®¾æ˜¯42ï¼Œä½ ä¸éœ€è¦è¿™ä¸ªï¼Œä½†æˆ‘æƒ³ç¨åé‡ç°æˆ‘çš„æ•°æ®ã€‚ç”±äºæˆ‘ä»¬ä½¿ç”¨éšæœºåˆå§‹åŒ–ï¼Œæˆ‘å¸Œæœ›å¾—åˆ°ç›¸åŒçš„ç»“æœï¼Œæˆ–è€…æˆ‘æƒ³é‡ç°æˆ‘çš„ç»“æœã€‚æ‰€ä»¥æˆ‘ä¼šåœ¨è¿™é‡Œè®¾ç½®ä¸€ä¸ªéšæœºç§å­ã€‚
- en: And now let's define our Euclidean distance function firstã€‚ So Euclidean distance
    of two vectorsã€‚ x1 and x2ã€‚ So this will be a global functionã€‚ And here we have
    to implement the formula that I just showed youã€‚ and we can do this in one lineã€‚
    So we say return and nuy firstï¼Œ we have the square root offã€‚ And then we have
    the sum nu pi sumã€‚ And then we have the sum over all the distancesã€‚
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬å…ˆå®šä¹‰æˆ‘ä»¬çš„æ¬§å‡ é‡Œå¾—è·ç¦»å‡½æ•°ã€‚æ‰€ä»¥ä¸¤ä¸ªå‘é‡çš„æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚x1å’Œx2ã€‚æ‰€ä»¥è¿™å°†æ˜¯ä¸€ä¸ªå…¨å±€å‡½æ•°ã€‚æˆ‘ä»¬å¿…é¡»å®ç°æˆ‘åˆšæ‰ç»™ä½ å±•ç¤ºçš„å…¬å¼ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€è¡Œæ¥å®Œæˆã€‚æ‰€ä»¥æˆ‘ä»¬è¯´è¿”å›ï¼Œnuyé¦–å…ˆï¼Œæˆ‘ä»¬æœ‰å¹³æ–¹æ ¹ã€‚ç„¶åæˆ‘ä»¬æœ‰sum
    nu pi sumã€‚ç„¶åæˆ‘ä»¬å¯¹æ‰€æœ‰è·ç¦»æ±‚å’Œã€‚
- en: So we can say x1 minus x2 to the power of2ã€‚ So the square distancesã€‚ So this
    is the functionã€‚ And now we can implement our K means classã€‚ So this will have
    an in itã€‚Which has selfã€‚ And then it will get a Kã€‚ So this will be the number
    of clustersã€‚ And by defaultï¼Œ let's say it's 5ã€‚ Then it will get a max itsã€‚ So
    this is the maximum number of iterationsã€‚
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥è¯´x1å‡å»x2çš„å¹³æ–¹ã€‚æ‰€ä»¥å¹³æ–¹è·ç¦»ã€‚è¿™å°±æ˜¯å‡½æ•°ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥å®ç°æˆ‘ä»¬çš„Kå‡å€¼ç±»ã€‚æ‰€ä»¥è¿™å°†æœ‰ä¸€ä¸ªinitã€‚å®ƒæœ‰selfã€‚ç„¶åå®ƒä¼šå¾—åˆ°ä¸€ä¸ªKã€‚æ‰€ä»¥è¿™å°†æ˜¯èšç±»çš„æ•°é‡ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå‡è®¾æ˜¯5ã€‚ç„¶åå®ƒä¼šå¾—åˆ°ä¸€ä¸ªmax
    itsã€‚è¿™æ˜¯æœ€å¤§è¿­ä»£æ¬¡æ•°ã€‚
- en: we want to do for our optimizationã€‚ And by defaultï¼Œ let's say it's 100ã€‚ And
    then it will also get a Boolean plot steps equals falseã€‚ So you don't need thisã€‚
    but I'm going to implement an additional function here to plot the different steps
    like we've just seenã€‚ Soã€‚Yeahï¼Œ so firstï¼Œ we set them or we store themã€‚ So we say
    self dot K equals K self dot max iters equals max iters and self dot plot steps
    equals plot stepsã€‚
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¦ä¸ºæˆ‘ä»¬çš„ä¼˜åŒ–åšçš„äº‹æƒ…ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå‡è®¾æ˜¯100ã€‚ç„¶åå®ƒè¿˜ä¼šå¾—åˆ°ä¸€ä¸ªå¸ƒå°”å€¼plot stepsç­‰äºfalseã€‚æ‰€ä»¥ä½ ä¸éœ€è¦è¿™ä¸ªï¼Œä½†æˆ‘å°†å®ç°ä¸€ä¸ªé™„åŠ åŠŸèƒ½æ¥ç»˜åˆ¶ä¸åŒçš„æ­¥éª¤ï¼Œå°±åƒæˆ‘ä»¬åˆšåˆšçœ‹åˆ°çš„é‚£æ ·ã€‚æ‰€ä»¥ï¼Œé¦–å…ˆï¼Œæˆ‘ä»¬è®¾ç½®å®ƒä»¬æˆ–å­˜å‚¨å®ƒä»¬ã€‚æ‰€ä»¥æˆ‘ä»¬è¯´self
    dot Kç­‰äºKï¼Œself dot max itersç­‰äºmax itersï¼Œself dot plot stepsç­‰äºplot stepsã€‚
- en: And now we create our empty clusters and centroidsã€‚ So self dotã€‚Clus equalsã€‚Oopsã€‚Equalsã€‚
    and now here we want to be careful because this is importantã€‚ So this is a list
    of listsã€‚ So a list of sample indicesã€‚For each clusterã€‚ and in the beginningï¼Œ
    each cluster has an empty listã€‚ So we sayï¼Œ and we use list comprehension and then
    say we say have an empty list for underscore in range self dot Kã€‚
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬åˆ›å»ºç©ºçš„èšç±»å’Œä¸­å¿ƒç‚¹ã€‚æ‰€ä»¥self dotã€‚Clusç­‰äºã€‚Oopsã€‚Equalsã€‚ç°åœ¨æˆ‘ä»¬è¦å°å¿ƒï¼Œå› ä¸ºè¿™å¾ˆé‡è¦ã€‚æ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªåˆ—è¡¨çš„åˆ—è¡¨ã€‚æ¯ä¸ªèšç±»çš„æ ·æœ¬ç´¢å¼•åˆ—è¡¨ã€‚å¼€å§‹æ—¶ï¼Œæ¯ä¸ªèšç±»éƒ½æœ‰ä¸€ä¸ªç©ºåˆ—è¡¨ã€‚æ‰€ä»¥æˆ‘ä»¬è¯´ï¼Œæˆ‘ä»¬ä½¿ç”¨åˆ—è¡¨æ¨å¯¼ï¼Œç„¶åè¯´æˆ‘ä»¬æœ‰ä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œunderscoreåœ¨èŒƒå›´self
    dot Kä¸­ã€‚
- en: So for each clusterï¼Œ we initialize an empty listã€‚And then we say our self dot
    centroids equalsã€‚ and this will also be an empty listã€‚ And here we are going to
    store the feature vectors or the mean feature vector for each clusterã€‚ So mean
    feature vector for each clusterã€‚ So here we are having actual samplesã€‚ And here
    we just store the indicesã€‚ So this is importantã€‚And now we can continueã€‚
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¯ä¸ªèšç±»ï¼Œæˆ‘ä»¬åˆå§‹åŒ–ä¸€ä¸ªç©ºåˆ—è¡¨ã€‚ç„¶åæˆ‘ä»¬è¯´æˆ‘ä»¬çš„self dot centroidsç­‰äºã€‚è¿™ä¹Ÿå°†æ˜¯ä¸€ä¸ªç©ºåˆ—è¡¨ã€‚è¿™é‡Œæˆ‘ä»¬å°†å­˜å‚¨æ¯ä¸ªèšç±»çš„ç‰¹å¾å‘é‡æˆ–å‡å€¼ç‰¹å¾å‘é‡ã€‚æ‰€ä»¥æ¯ä¸ªèšç±»çš„å‡å€¼ç‰¹å¾å‘é‡ã€‚è¿™é‡Œæˆ‘ä»¬æœ‰å®é™…çš„æ ·æœ¬ã€‚æˆ‘ä»¬åªå­˜å‚¨ç´¢å¼•ã€‚è¿™å¾ˆé‡è¦ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥ç»§ç»­ã€‚
- en: So now usually we would implement a fit and a predict methodã€‚ But since we are
    having a unsupervised learning technique hereï¼Œ we and we don't have any label
    dataã€‚ we just have to implement the predict methodã€‚ Soï¼Œ and we don't need this
    the fit methodã€‚ So let's define our predict methodã€‚With self and Xã€‚And hereï¼Œ firstï¼Œ
    let's store our dataã€‚
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: é€šå¸¸æˆ‘ä»¬ä¼šå®ç°fitå’Œpredictæ–¹æ³•ã€‚ä½†ç”±äºæˆ‘ä»¬è¿™é‡Œä½¿ç”¨çš„æ˜¯æ— ç›‘ç£å­¦ä¹ æŠ€æœ¯ï¼Œå¹¶ä¸”æ²¡æœ‰æ ‡ç­¾æ•°æ®ï¼Œæˆ‘ä»¬åªéœ€è¦å®ç°predictæ–¹æ³•ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬ä¸éœ€è¦fitæ–¹æ³•ã€‚ç°åœ¨è®©æˆ‘ä»¬å®šä¹‰æˆ‘ä»¬çš„predictæ–¹æ³•ã€‚ç”¨selfå’ŒXã€‚è¿™é‡Œï¼Œé¦–å…ˆï¼Œè®©æˆ‘ä»¬å­˜å‚¨æˆ‘ä»¬çš„æ•°æ®ã€‚
- en: self x equals xã€‚ and then the dimensionsã€‚ So self number of samples and self
    dot number of features equals x dot shape because we need this laterã€‚ And as alwaysï¼Œ
    this is a nuy and D arrayã€‚And soï¼Œ yeahã€‚ So now let's do the steps we just talked
    aboutã€‚ So firstï¼Œ we have toã€‚Initialize ourã€‚Our centroidsã€‚And then we do a optimizationã€‚
    So here we can say four underscore in range self dot max itsã€‚
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: self xç­‰äºxã€‚ç„¶åæ˜¯ç»´åº¦ã€‚å› æ­¤self number of sampleså’Œself dot number of featuresç­‰äºx dot
    shapeï¼Œå› ä¸ºæˆ‘ä»¬ç¨åéœ€è¦è¿™ä¸ªã€‚å’Œå¾€å¸¸ä¸€æ ·ï¼Œè¿™æ˜¯ä¸€ä¸ªnuyå’ŒDæ•°ç»„ã€‚å› æ­¤ï¼Œæ˜¯çš„ã€‚ç°åœ¨è®©æˆ‘ä»¬æ‰§è¡Œåˆšæ‰è®¨è®ºçš„æ­¥éª¤ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬è¦åˆå§‹åŒ–æˆ‘ä»¬çš„ã€‚æˆ‘ä»¬çš„ä¸­å¿ƒç‚¹ã€‚ç„¶åæˆ‘ä»¬è¿›è¡Œä¼˜åŒ–ã€‚å› æ­¤åœ¨è¿™é‡Œæˆ‘ä»¬å¯ä»¥è¯´å››ä¸ªä¸‹åˆ’çº¿åœ¨èŒƒå›´å†…self
    dot max itsã€‚
- en: And now here in our loop firstï¼Œ we update our clustersã€‚Soï¼Œ let's sayï¼Œ update
    clustersã€‚And thenã€‚ we update the centsã€‚And then we check for conversiongsã€‚Checkã€‚If
    convergedã€‚And if soï¼Œ then we breakã€‚ And at the endï¼Œ we want to classify the samples
    as the index of their clustersã€‚ So here we say returnã€‚Returnã€‚Cluster labelsã€‚ So
    this is what we have to doã€‚So now let's startã€‚
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨åœ¨æˆ‘ä»¬çš„å¾ªç¯ä¸­ï¼Œé¦–å…ˆæ›´æ–°æˆ‘ä»¬çš„ç°‡ã€‚æ‰€ä»¥ï¼Œå‡è®¾æˆ‘ä»¬æ›´æ–°ç°‡ã€‚ç„¶åï¼Œæˆ‘ä»¬æ›´æ–°ä¸­å¿ƒç‚¹ã€‚æ¥ç€æ£€æŸ¥æ˜¯å¦æ”¶æ•›ã€‚æ£€æŸ¥ã€‚å¦‚æœæ”¶æ•›äº†ã€‚é‚£æˆ‘ä»¬å°±è·³å‡ºå¾ªç¯ã€‚æœ€åï¼Œæˆ‘ä»¬æƒ³è¦å°†æ ·æœ¬åˆ†ç±»ä¸ºå…¶ç°‡çš„ç´¢å¼•ã€‚å› æ­¤è¿™é‡Œæˆ‘ä»¬è¯´è¿”å›ã€‚è¿”å›ã€‚ç°‡æ ‡ç­¾ã€‚è¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦åšçš„ã€‚ç°åœ¨è®©æˆ‘ä»¬å¼€å§‹å§ã€‚
- en: So let's say we want to initialize our centroidsã€‚ So we want to randomly pick
    some samplesã€‚ So let's say random sample indices equalsã€‚ and now we use list comprehensionã€‚
    So or noï¼Œ sorryã€‚ here I can use nuy dot random dot choiceã€‚And this will get self
    dot number of samplesï¼Œ and self dotã€‚Kï¼Œ and we also have to say replace equals
    false because we don't want to pick the same indices twiceã€‚
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æƒ³è¦åˆå§‹åŒ–æˆ‘ä»¬çš„ä¸­å¿ƒç‚¹ã€‚æˆ‘ä»¬æƒ³è¦éšæœºé€‰æ‹©ä¸€äº›æ ·æœ¬ã€‚å› æ­¤å‡è®¾éšæœºæ ·æœ¬ç´¢å¼•ç­‰äºã€‚ç°åœ¨æˆ‘ä»¬ä½¿ç”¨åˆ—è¡¨æ¨å¯¼å¼ã€‚å“¦ä¸ï¼ŒæŠ±æ­‰ã€‚åœ¨è¿™é‡Œæˆ‘å¯ä»¥ä½¿ç”¨nuy dot
    random dot choiceã€‚è¿™å°†è·å–self dot number of sampleså’Œself dot Kï¼Œæˆ‘ä»¬è¿˜éœ€è¦è¯´replaceç­‰äºfalseï¼Œå› ä¸ºæˆ‘ä»¬ä¸æƒ³é€‰æ‹©ç›¸åŒçš„ç´¢å¼•ä¸¤æ¬¡ã€‚
- en: So this will be an array of size self dot Kã€‚ And for each entryã€‚ it will pick
    a random choice between 0 and the number of samplesã€‚And nowï¼Œ we assignã€‚The according
    sample that belongs to this index to our centroidsã€‚ So we say self dot centroids
    equalsã€‚ And now here we use list comprehensionã€‚ So we say self dot Xã€‚
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†æ˜¯ä¸€ä¸ªå¤§å°ä¸ºself dot Kçš„æ•°ç»„ã€‚å¯¹äºæ¯ä¸ªæ¡ç›®ï¼Œå®ƒå°†éšæœºé€‰æ‹©0åˆ°æ ·æœ¬æ•°é‡ä¹‹é—´çš„ä¸€ä¸ªå€¼ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬åˆ†é…ã€‚ä¸æ­¤ç´¢å¼•å¯¹åº”çš„æ ·æœ¬ç»™æˆ‘ä»¬çš„ä¸­å¿ƒç‚¹ã€‚å› æ­¤æˆ‘ä»¬è¯´self
    dot centroidsç­‰äºã€‚ç°åœ¨è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨åˆ—è¡¨æ¨å¯¼å¼ã€‚æ‰€ä»¥æˆ‘ä»¬è¯´self dot Xã€‚
- en: Of the current index for index in random samplingdicesã€‚So this is the initialization
    of our centroidsã€‚ And now we can do the optimizationã€‚ So firstã€‚ we say we update
    our clustersã€‚ So we say self dot clusters equals self dotï¼Œ create clustersã€‚ and
    this will get self dot centroidsã€‚ So this is a help of functionã€‚
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å‰ç´¢å¼•ä¸ºindexçš„éšæœºé‡‡æ ·ç´¢å¼•ã€‚å› æ­¤è¿™æ˜¯æˆ‘ä»¬ä¸­å¿ƒç‚¹çš„åˆå§‹åŒ–ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥è¿›è¡Œä¼˜åŒ–ã€‚å› æ­¤é¦–å…ˆã€‚æˆ‘ä»¬è¯´æ›´æ–°æˆ‘ä»¬çš„ç°‡ã€‚å› æ­¤æˆ‘ä»¬è¯´self dot clustersç­‰äºself
    dot create clustersã€‚è¿™å°†è·å–self dot centroidsã€‚è¿™æ˜¯ä¸€ä¸ªå¸®åŠ©å‡½æ•°ã€‚
- en: create clusters that we are going to implement nowã€‚ So define create clusters
    with self and the centsã€‚So here we assign the samples to the closest centroids
    to create our clustersã€‚ So first we haveã€‚An empty list of lists for our clustersã€‚And
    now we iterate over our dataã€‚
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ›å»ºæˆ‘ä»¬ç°åœ¨è¦å®ç°çš„ç°‡ã€‚å› æ­¤å®šä¹‰create clustersï¼Œå‚æ•°ä¸ºselfå’Œcentsã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†æ ·æœ¬åˆ†é…ç»™æœ€æ¥è¿‘çš„ä¸­å¿ƒç‚¹ä»¥åˆ›å»ºæˆ‘ä»¬çš„ç°‡ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªç©ºçš„åˆ—è¡¨åˆ—è¡¨ç”¨äºæˆ‘ä»¬çš„ç°‡ã€‚ç°åœ¨æˆ‘ä»¬éå†æˆ‘ä»¬çš„æ•°æ®ã€‚
- en: So we say for index and sample in enumerate self dot Xã€‚ So this enumerate function
    will give us the current index and the current sampleã€‚ Now we want to get the
    closest centroidã€‚ And we want to have the index of thisã€‚ So we say centroid index
    equals self dot closestã€‚Centroidã€‚And this will getï¼Œ get the current sampleã€‚
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥æˆ‘ä»¬è¯´å¯¹äºindexå’Œsampleåœ¨enumerate self dot Xä¸­ã€‚å› æ­¤è¿™ä¸ªenumerateå‡½æ•°å°†ç»™æˆ‘ä»¬å½“å‰ç´¢å¼•å’Œå½“å‰æ ·æœ¬ã€‚ç°åœ¨æˆ‘ä»¬æƒ³è¦è·å–æœ€è¿‘çš„ä¸­å¿ƒç‚¹ã€‚æˆ‘ä»¬æƒ³è¦è·å–å®ƒçš„ç´¢å¼•ã€‚å› æ­¤æˆ‘ä»¬è¯´centroid
    indexç­‰äºself dot closestã€‚Centroidã€‚è¿™å°†è·å–å½“å‰æ ·æœ¬ã€‚
- en: and then it will get the centroidã€‚ So this will be another helper function that
    weã€‚ we will create in a secondã€‚ But now let's continue hereã€‚ So when we have the
    centroid indexã€‚ we appendã€‚Or we take the currentã€‚Clusterï¼Œ so the clusters of thisã€‚Centroid
    indexã€‚ And then we appendã€‚The current indexã€‚ So we put the current sample index
    in the closest clusterã€‚
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åå®ƒå°†è·å–ä¸­å¿ƒç‚¹ã€‚è¿™å°†æ˜¯å¦ä¸€ä¸ªå¸®åŠ©å‡½æ•°ï¼Œæˆ‘ä»¬ä¼šåœ¨ç¨ååˆ›å»ºã€‚ä½†ç°åœ¨æˆ‘ä»¬ç»§ç»­ã€‚å› æ­¤ï¼Œå½“æˆ‘ä»¬æœ‰ä¸­å¿ƒç‚¹ç´¢å¼•æ—¶ã€‚æˆ‘ä»¬é™„åŠ ã€‚æˆ–è€…å–å½“å‰ã€‚ç°‡ï¼Œå› æ­¤è¿™ä¸ªã€‚ä¸­å¿ƒç‚¹ç´¢å¼•çš„ç°‡ã€‚ç„¶åæˆ‘ä»¬é™„åŠ ã€‚å½“å‰ç´¢å¼•ã€‚æ‰€ä»¥æˆ‘ä»¬æŠŠå½“å‰æ ·æœ¬ç´¢å¼•æ”¾å…¥æœ€è¿‘çš„ç°‡ä¸­ã€‚
- en: And then we return our clustersã€‚So this is how we create our clustersã€‚ and now
    we need the define closest centroid functionã€‚ which gets self and a sample and
    the centroidsã€‚Andã€‚Here we calculate the distances of the current sample to each
    centroidã€‚And thenï¼Œ want to get theã€‚
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬è¿”å›æˆ‘ä»¬çš„ç°‡ã€‚è¿™å°±æ˜¯æˆ‘ä»¬å¦‚ä½•åˆ›å»ºæˆ‘ä»¬çš„ç°‡ã€‚ç°åœ¨æˆ‘ä»¬éœ€è¦å®šä¹‰closest centroidå‡½æ•°ï¼Œå‚æ•°ä¸ºselfã€æ ·æœ¬å’Œä¸­å¿ƒç‚¹ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬è®¡ç®—å½“å‰æ ·æœ¬åˆ°æ¯ä¸ªä¸­å¿ƒç‚¹çš„è·ç¦»ã€‚ç„¶åï¼Œæˆ‘ä»¬æƒ³è¦è·å–ã€‚
- en: The centroid or the index of the centroidï¼Œ which has theï¼Œ the closest distanceã€‚
    So let's calculate all the distances with list comprehensionã€‚ So here we use the
    Euclidean distance function we already haveã€‚ So the Euclidean distance of a sample
    and of eachã€‚Centroid pointã€‚ So point4 point in centsã€‚
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: è´¨å¿ƒæˆ–è´¨å¿ƒçš„ç´¢å¼•ï¼Œå…¶å…·æœ‰æœ€è¿‘çš„è·ç¦»ã€‚å› æ­¤ï¼Œè®©æˆ‘ä»¬ç”¨åˆ—è¡¨æ¨å¯¼è®¡ç®—æ‰€æœ‰çš„è·ç¦»ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨å·²ç»æœ‰çš„æ¬§å‡ é‡Œå¾—è·ç¦»å‡½æ•°ã€‚å› æ­¤ï¼Œæ ·æœ¬ä¸æ¯ä¸ªè´¨å¿ƒç‚¹ä¹‹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚å› æ­¤ï¼Œç‚¹4ç‚¹åœ¨è´¨å¿ƒä¸­ã€‚
- en: And then we want we so we have all the distances hereã€‚ and now we want to see
    which is the minimum or the index with the minimum distanceã€‚ So we can use Ny
    arc min hereã€‚ So we say closest index equals Ny arc min of this distancesã€‚And
    thenã€‚ you simplyã€‚Return itã€‚ So return the closest indexã€‚ So now we have thisã€‚
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬æƒ³è¦çš„ï¼Œæˆ‘ä»¬è¿™é‡Œæœ‰æ‰€æœ‰çš„è·ç¦»ï¼Œç°åœ¨æˆ‘ä»¬æƒ³çœ‹çœ‹å“ªä¸ªæ˜¯æœ€å°çš„ï¼Œæˆ–è€…æ˜¯æœ€å°è·ç¦»çš„ç´¢å¼•ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œä½¿ç”¨Ny arc minã€‚æ‰€ä»¥æˆ‘ä»¬è¯´æœ€è¿‘çš„ç´¢å¼•ç­‰äºè¿™äº›è·ç¦»çš„Ny
    arc minã€‚ç„¶åï¼Œä½ åªéœ€è¿”å›å®ƒã€‚å› æ­¤ï¼Œè¿”å›æœ€è¿‘çš„ç´¢å¼•ã€‚æ‰€ä»¥ç°åœ¨æˆ‘ä»¬æœ‰è¿™ä¸ªã€‚
- en: and now we created our clustersï¼Œ and now we can continue with our optimizationã€‚
    So here we update our centroids as the next stepsã€‚ But before we want to store
    the centroidsã€‚ So let's say centroids alts equals self dot centroids so that we
    can check for convergence laterã€‚ And then we say self dot centroids equals self
    dot getã€‚Centroidsã€‚Of thisã€‚
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬åˆ›å»ºäº†æˆ‘ä»¬çš„ç°‡ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥ç»§ç»­ä¼˜åŒ–ã€‚å› æ­¤ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬æ›´æ–°è´¨å¿ƒä½œä¸ºä¸‹ä¸€æ­¥ã€‚ä½†åœ¨æ­¤ä¹‹å‰ï¼Œæˆ‘ä»¬æƒ³è¦å­˜å‚¨è´¨å¿ƒã€‚æ‰€ä»¥æˆ‘ä»¬è¯´è´¨å¿ƒaltsç­‰äºself dot
    centroidsï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥ç¨åæ£€æŸ¥æ”¶æ•›æƒ…å†µã€‚ç„¶åæˆ‘ä»¬è¯´self dot centroidsç­‰äºself dot getã€‚è´¨å¿ƒã€‚è¿™ã€‚
- en: And this will get the self clustersã€‚ So this is another functionã€‚This will assign
    the mean value of the clusters to the centroidã€‚ So for each clusterã€‚ we now calculate
    the meanã€‚ So let's define thisï¼Œ defineã€‚Getã€‚å¯ã€‚Notice do I get centsã€‚Which gets
    self and the clustersã€‚Soã€‚Hereï¼Œ we initialize our centroids with zeros in the beginningã€‚
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ ·ä¼šå¾—åˆ°è‡ªæˆ‘ç°‡ã€‚æ‰€ä»¥è¿™æ˜¯å¦ä¸€ä¸ªåŠŸèƒ½ã€‚è¿™ä¸ªå°†æŠŠç°‡çš„å‡å€¼åˆ†é…ç»™è´¨å¿ƒã€‚å› æ­¤ï¼Œå¯¹äºæ¯ä¸ªç°‡ï¼Œæˆ‘ä»¬ç°åœ¨è®¡ç®—å‡å€¼ã€‚è®©æˆ‘ä»¬å®šä¹‰è¿™ä¸ªï¼Œå®šä¹‰ã€‚è·å–ã€‚å¯ã€‚æ³¨æ„æˆ‘æ˜¯å¦å¾—åˆ°äº†è´¨å¿ƒã€‚è¿™ä¸ªå¾—åˆ°è‡ªæˆ‘å’Œç°‡ã€‚å› æ­¤ï¼Œåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åœ¨å¼€å§‹æ—¶ç”¨é›¶åˆå§‹åŒ–æˆ‘ä»¬çš„è´¨å¿ƒã€‚
- en: So let's say centroidsã€‚Equals nuai zerosã€‚ And this will be of size self K andã€‚Self
    dot Nã€‚Featuresã€‚ and here this should be a two pullã€‚ So we have to be careful hereã€‚
    So for each clusterã€‚ we will store the feature Eaã€‚ So that's why it has to have
    this dimensionsã€‚And now we iterate over the clustersã€‚ So we say four cluster index
    and cluster in enumerateã€‚Clutersã€‚
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥æˆ‘ä»¬è¯´è´¨å¿ƒç­‰äºnuaié›¶ã€‚è¿™æ ·å°†æ˜¯self Kå’Œself dot Nç‰¹å¾çš„å¤§å°ã€‚è€Œè¿™é‡Œåº”è¯¥æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ã€‚æ‰€ä»¥æˆ‘ä»¬å¿…é¡»å°å¿ƒè¿™é‡Œã€‚å› æ­¤ï¼Œå¯¹äºæ¯ä¸ªç°‡ï¼Œæˆ‘ä»¬å°†å­˜å‚¨ç‰¹å¾Eaã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå®ƒå¿…é¡»å…·æœ‰è¿™ä¸ªç»´åº¦ã€‚ç°åœ¨æˆ‘ä»¬éå†ç°‡ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è¯´å››ä¸ªç°‡ç´¢å¼•å’Œç°‡åœ¨enumerate.Clutersä¸­ã€‚
- en: Andã€‚Then we calculate the cluster meanã€‚ So cluster mean equals N pi mean of
    our self dot x of this cluster indicesã€‚ğŸ¤¢ï¼ŒAnd this should be along the first axisã€‚So
    againï¼Œ let's have a look at what this meansã€‚ So ourã€‚ as I saidï¼Œ our clusters is
    a list of listsã€‚ So if we have just a current clusterã€‚ then this is a listï¼Œ and
    this is a list of the indices that are in this clusterã€‚
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬è®¡ç®—ç°‡å‡å€¼ã€‚å› æ­¤ï¼Œç°‡å‡å€¼ç­‰äºN piå‡å€¼æˆ‘ä»¬çš„è‡ªæˆ‘.xå’Œè¿™ä¸ªç°‡çš„ç´¢å¼•ã€‚ğŸ¤¢ï¼Œè€Œä¸”è¿™åº”è¯¥æ²¿ç€ç¬¬ä¸€è½´ã€‚å› æ­¤ï¼Œå†æ¬¡è®©æˆ‘ä»¬çœ‹çœ‹è¿™æ„å‘³ç€ä»€ä¹ˆã€‚å› æ­¤ï¼Œæ­£å¦‚æˆ‘æ‰€è¯´ï¼Œæˆ‘ä»¬çš„ç°‡æ˜¯ä¸€ä¸ªåˆ—è¡¨çš„åˆ—è¡¨ã€‚æ‰€ä»¥å¦‚æœæˆ‘ä»¬åªæœ‰ä¸€ä¸ªå½“å‰ç°‡ï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œè€Œè¿™æ˜¯ä¸€ä¸ªåœ¨è¿™ä¸ªç°‡ä¸­çš„ç´¢å¼•åˆ—è¡¨ã€‚
- en: So if we call self dot X with this indicesã€‚Then it will only return the samples
    that are in the current clustersã€‚In the current clusterã€‚ And then we calculate
    the meanã€‚ So this is what what what's going to happen hereã€‚ And now once we have
    our meanã€‚ we assign it to the current cluster So to the current centroidsã€‚ So
    we say centroids of the currentã€‚
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥å¦‚æœæˆ‘ä»¬ç”¨è¿™ä¸ªç´¢å¼•è°ƒç”¨self dot Xã€‚å®ƒå°†ä»…è¿”å›åœ¨å½“å‰ç°‡ä¸­çš„æ ·æœ¬ã€‚åœ¨å½“å‰ç°‡ä¸­ã€‚ç„¶åæˆ‘ä»¬è®¡ç®—å‡å€¼ã€‚æ‰€ä»¥è¿™å°±æ˜¯å°†è¦å‘ç”Ÿçš„äº‹æƒ…ã€‚ç°åœ¨ä¸€æ—¦æˆ‘ä»¬å¾—åˆ°äº†å‡å€¼ï¼Œæˆ‘ä»¬å°†å…¶åˆ†é…ç»™å½“å‰ç°‡çš„è´¨å¿ƒã€‚å› æ­¤ï¼Œæˆ‘ä»¬è¯´å½“å‰çš„è´¨å¿ƒç­‰äºå½“å‰ç°‡çš„å‡å€¼ã€‚
- en: Cluster index equals clusterã€‚Meanã€‚And then we are done and can return the centroidsã€‚Soï¼Œ
    yeahã€‚ So now we have our new centroidsã€‚ and now we check if we are convergedã€‚
    So we say if self dotã€‚Is convergedã€‚Then we will break so we can stop hereã€‚And
    this will get the centroidsã€‚Old and the new new onesã€‚ So self do centsã€‚ And this
    is another helper functionã€‚This will simplyã€‚
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬å®Œæˆäº†ï¼Œå¯ä»¥è¿”å›è´¨å¿ƒã€‚æ‰€ä»¥ï¼Œæ˜¯çš„ã€‚ç°åœ¨æˆ‘ä»¬æœ‰äº†æ–°çš„è´¨å¿ƒã€‚ç°åœ¨æˆ‘ä»¬æ£€æŸ¥æ˜¯å¦æ”¶æ•›ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è¯´å¦‚æœself dotã€‚å·²æ”¶æ•›ã€‚é‚£ä¹ˆæˆ‘ä»¬å°†ä¸­æ–­ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œåœæ­¢ã€‚è¿™å°†å¾—åˆ°æ—§çš„å’Œæ–°çš„è´¨å¿ƒã€‚å› æ­¤ï¼Œself
    do centsã€‚è¿™æ˜¯å¦ä¸€ä¸ªå¸®åŠ©å‡½æ•°ã€‚è¿™ä¸ªå°†ç®€å•ã€‚
- en: Calculate the distances between each old and new centroids for all the centsã€‚
    and check if this is0ã€‚Soï¼Œ define is convergedã€‚Self and centsï¼Œ old and new centroidsã€‚So
    againã€‚ we calculate the distances with less comprehenionã€‚ This turns as equalsã€‚
    And here we calculate calculate the Eucladan distance of centroids old of Iã€‚
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡ç®—æ‰€æœ‰è´¨å¿ƒä¹‹é—´çš„è·ç¦»ï¼Œæ£€æŸ¥æ˜¯å¦ä¸º0ã€‚æ‰€ä»¥ï¼Œå®šä¹‰is convergedã€‚selfå’Œæ—§çš„æ–°è´¨å¿ƒã€‚æ‰€ä»¥æˆ‘ä»¬å†æ¬¡è®¡ç®—è·ç¦»ï¼Œä½¿ç”¨è¾ƒå°‘çš„ç†è§£ã€‚è¿™å˜æˆäº†ç›¸ç­‰ã€‚è¿™é‡Œæˆ‘ä»¬è®¡ç®—è´¨å¿ƒæ—§çš„æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚
- en: So the current centroid vectorã€‚And the new oneï¼Œ So centroidsã€‚Iã€‚4 I in range
    self dot kã€‚ğŸ¼So for each clusterï¼Œ it will look at the old and the new centroid
    vector and calculate the Euclidean distance and store it in this listã€‚ And then
    we can return someã€‚Distancesã€‚Equals equals 0ã€‚ So this is a build in function that
    will iterate over these entries and calculate or sum it upã€‚
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å‰è´¨å¿ƒå‘é‡å’Œæ–°çš„è´¨å¿ƒï¼Œself.dot.kèŒƒå›´å†…çš„iã€‚å¯¹äºæ¯ä¸ªèšç±»ï¼Œå®ƒå°†æŸ¥çœ‹æ—§çš„å’Œæ–°çš„è´¨å¿ƒå‘é‡ï¼Œè®¡ç®—æ¬§å‡ é‡Œå¾—è·ç¦»å¹¶å°†å…¶å­˜å‚¨åœ¨åˆ—è¡¨ä¸­ã€‚ç„¶åæˆ‘ä»¬å¯ä»¥è¿”å›ä¸€äº›è·ç¦»ï¼Œç­‰äº0ã€‚è¿™æ˜¯ä¸€ä¸ªå†…ç½®å‡½æ•°ï¼Œå®ƒä¼šéå†è¿™äº›æ¡ç›®å¹¶è¿›è¡Œè®¡ç®—æˆ–æ±‚å’Œã€‚
- en: And so if this is0ï¼Œ then there is no more change in our centroidsã€‚ So we say
    it is convergedã€‚Soã€‚ yeahï¼Œ so now we have thisã€‚ And now we want to return the cluster
    labelsã€‚ So let's say return self dotã€‚Get cluster labelsã€‚And this will get self
    thoughtã€‚Clutersã€‚So here for each sampleï¼Œ we will get the label of the cluster
    it was assigned toã€‚
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¿™æ˜¯0ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„è´¨å¿ƒå°±æ²¡æœ‰æ›´å¤šå˜åŒ–ã€‚æ‰€ä»¥æˆ‘ä»¬è¯´å®ƒå·²ç»æ”¶æ•›äº†ã€‚å¥½å§ï¼Œç°åœ¨æˆ‘ä»¬æœ‰è¿™ä¸ªã€‚ç°åœ¨æˆ‘ä»¬æƒ³è¦è¿”å›èšç±»æ ‡ç­¾ã€‚æˆ‘ä»¬å¯ä»¥è¿”å›self.dot.get
    cluster labelsã€‚è¿™æ ·å°±èƒ½è·å–selfçš„èšç±»æ ‡ç­¾ã€‚å¯¹äºæ¯ä¸ªæ ·æœ¬ï¼Œæˆ‘ä»¬å°†å¾—åˆ°å®ƒè¢«åˆ†é…åˆ°çš„èšç±»çš„æ ‡ç­¾ã€‚
- en: So let's create this right hereã€‚ So define get cluster labels with and the clustersã€‚And
    so firstã€‚ we say our labels equals a nuyã€‚Ety arrayã€‚Of sizeï¼Œ self dot number of
    samplesã€‚ So for each sampleã€‚ we want to returnï¼Œ which is theã€‚The cluster it was
    assigned toï¼Œ But be careful hereã€‚ because these labels are not the actual labels
    of our data because we don't know themã€‚
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åœ¨è¿™é‡Œåˆ›å»ºè¿™ä¸ªã€‚å®šä¹‰get cluster labelså’Œclustersã€‚é¦–å…ˆï¼Œæˆ‘ä»¬è¯´æˆ‘ä»¬çš„æ ‡ç­¾ç­‰äºä¸€ä¸ªå¤§å°ä¸ºself.dot number of
    samplesçš„ç©ºæ•°ç»„ã€‚å¯¹äºæ¯ä¸ªæ ·æœ¬ï¼Œæˆ‘ä»¬æƒ³è¿”å›å®ƒè¢«åˆ†é…çš„èšç±»ã€‚ä½†æ˜¯è¿™é‡Œè¦å°å¿ƒï¼Œå› ä¸ºè¿™äº›æ ‡ç­¾å¹¶ä¸æ˜¯æˆ‘ä»¬æ•°æ®çš„å®é™…æ ‡ç­¾ï¼Œå› ä¸ºæˆ‘ä»¬ä¸çŸ¥é“å®ƒä»¬ã€‚
- en: So this is just the index of the cluster it was assigned toã€‚Soï¼Œ yeahã€‚ So now
    we iterate over the clusterã€‚ So for cluster indexã€‚And alsoï¼Œ cluster in enumerateã€‚Clutersã€‚And
    then we iterate over the current clusterã€‚ So for sample index in clusterã€‚So againã€‚
    this is a list of listï¼Œ and each cluster has a list has all the the sample indices
    of the samples that are in this clusterã€‚
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åªæ˜¯å®ƒè¢«åˆ†é…åˆ°çš„èšç±»çš„ç´¢å¼•ã€‚å¥½å§ï¼Œç°åœ¨æˆ‘ä»¬éå†èšç±»ã€‚å¯¹äºèšç±»ç´¢å¼•ä¸­çš„èšç±»å’Œenumerate.clutersä¸­çš„èšç±»ã€‚ç„¶åæˆ‘ä»¬éå†å½“å‰èšç±»ã€‚å¯¹äºèšç±»ä¸­çš„æ¯ä¸ªæ ·æœ¬ç´¢å¼•ï¼Œè¿™åˆæ˜¯ä¸€ä¸ªåˆ—è¡¨çš„åˆ—è¡¨ï¼Œæ¯ä¸ªèšç±»éƒ½æœ‰ä¸€ä¸ªåŒ…å«è¯¥èšç±»ä¸­æ‰€æœ‰æ ·æœ¬ç´¢å¼•çš„åˆ—è¡¨ã€‚
- en: So for each sample index in this current clusterï¼Œ we say labels of the sample
    index equalsã€‚The current cluster indexã€‚And then we return our labelsã€‚ And now
    we are doneã€‚So one more thing that I want to implementï¼Œ but you don't need this
    is to have a plot functionã€‚ So define find plot and selfã€‚And here we are going
    to use matpl lab so I can sayï¼Œ importã€‚Muchã€‚
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºå½“å‰èšç±»ä¸­çš„æ¯ä¸ªæ ·æœ¬ç´¢å¼•ï¼Œæˆ‘ä»¬è¯´æ ·æœ¬ç´¢å¼•çš„æ ‡ç­¾ç­‰äºå½“å‰èšç±»ç´¢å¼•ã€‚ç„¶åæˆ‘ä»¬è¿”å›æˆ‘ä»¬çš„æ ‡ç­¾ã€‚ç°åœ¨æˆ‘ä»¬å®Œæˆäº†ã€‚æˆ‘è¿˜æƒ³å®ç°ä¸€ä»¶äº‹ï¼Œä½†ä½ ä¸éœ€è¦çš„æ˜¯ç»˜å›¾å‡½æ•°ã€‚å®šä¹‰find
    plotå’Œselfã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†ä½¿ç”¨matplotlibï¼Œæ‰€ä»¥æˆ‘å¯ä»¥è¯´importã€‚
- en: Ploot lip dot pi plot S P L Tï¼Œ And I'm not going to explain the details hereã€‚
    but if you want to see more tutorials about my plot lipï¼Œ then please leave some
    commentsã€‚So let's implement the plot methodã€‚ So hereï¼Œ I simply want toã€‚Ploot theã€‚
    the data and to which cluster it belongsã€‚ And then also the centroidsã€‚ So let's
    create our figureã€‚
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨plt.plotï¼Œæˆ‘ä¸æ‰“ç®—åœ¨è¿™é‡Œè§£é‡Šç»†èŠ‚ï¼Œä½†å¦‚æœä½ æƒ³çœ‹åˆ°æ›´å¤šå…³äºæˆ‘çš„plotçš„æ•™ç¨‹ï¼Œè¯·ç•™ä¸‹è¯„è®ºã€‚è®©æˆ‘ä»¬å®ç°ç»˜å›¾æ–¹æ³•ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘æƒ³ç®€å•åœ°ç»˜åˆ¶æ•°æ®åŠå…¶æ‰€å±çš„èšç±»ï¼Œä»¥åŠè´¨å¿ƒã€‚è®©æˆ‘ä»¬åˆ›å»ºæˆ‘ä»¬çš„å›¾å½¢ã€‚
- en: So F a X equals Pï¼Œ L T dot subã€‚Plootsï¼Œ and let's give this a fixed size of sizeã€‚
    Let's sayï¼Œ12 by 8ã€‚ And then we iterate over our clustersã€‚ So for I and index inã€‚Sell
    inï¼Œ in nomã€‚Marade self dot clustersã€‚ And now we get the current pointã€‚ So point
    equals self dot Xã€‚Of the indexã€‚ but we have to transpose it hereã€‚And now we scatter
    the pointã€‚ So A X starts scatterã€‚
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾ç½®axç­‰äºplt.subplotï¼Œå¹¶ç»™å®ƒä¸€ä¸ªå›ºå®šçš„å¤§å°ï¼Œæ¯”å¦‚12ä¹˜8ã€‚ç„¶åæˆ‘ä»¬éå†æˆ‘ä»¬çš„èšç±»ã€‚å¯¹äºç´¢å¼•ä¸­çš„æ¯ä¸ªiï¼Œåœ¨self.dot clustersä¸­ã€‚ç°åœ¨æˆ‘ä»¬å¾—åˆ°å½“å‰çš„ç‚¹ï¼Œpointç­‰äºself.dot
    Xçš„ç´¢å¼•ï¼Œä½†æˆ‘ä»¬å¿…é¡»åœ¨è¿™é‡Œè½¬ç½®å®ƒã€‚ç°åœ¨æˆ‘ä»¬æ•£ç‚¹å›¾ã€‚
- en: And here I unpack the pointã€‚And nowï¼Œ so this will plot all the pointsã€‚And for
    each clusterã€‚ it will use a different colorã€‚And now we do theï¼Œ we plot all the
    centroidsã€‚ So for point in self dot centsã€‚A x dot scatterã€‚ And againï¼Œ we unfold
    our pointã€‚ and then we say marker equalsã€‚Xï¼Œ so it has a marker signï¼Œ and color
    equalsã€‚
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œæˆ‘è§£åŒ…äº†è¿™ä¸ªç‚¹ã€‚ç°åœ¨ï¼Œè¿™å°†ç»˜åˆ¶æ‰€æœ‰çš„ç‚¹ã€‚å¯¹äºæ¯ä¸ªèšç±»ï¼Œå®ƒå°†ä½¿ç”¨ä¸åŒçš„é¢œè‰²ã€‚ç°åœ¨æˆ‘ä»¬ç»˜åˆ¶æ‰€æœ‰çš„è´¨å¿ƒã€‚æ‰€ä»¥å¯¹äºç‚¹åœ¨ self.dot centsã€‚A
    x.dot.scatterã€‚å†ä¸€æ¬¡ï¼Œæˆ‘ä»¬è§£å¼€æˆ‘ä»¬çš„ç‚¹ã€‚ç„¶åæˆ‘ä»¬è¯´ marker ç­‰äºã€‚Xï¼Œæ‰€ä»¥å®ƒæœ‰ä¸€ä¸ªæ ‡è®°ç¬¦å·ï¼Œcolor ç­‰äºã€‚
- en: Black and line width equals 2ã€‚Soï¼Œ and then we have to say PLT dot showï¼Œ of courseã€‚Andã€‚So
    this is the plot functionã€‚ And nowï¼Œ during our optimizationï¼Œ if we set plot steps
    to trueã€‚Then we want to plot after we updated our clustersï¼Œ so we sayã€‚If self
    dotã€‚Ploot stepsã€‚ then self dot plotã€‚And againï¼Œ we also want to plot after we updated
    our centroidsã€‚
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: é»‘è‰²å’Œçº¿å®½ç­‰äº 2ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¿…é¡»è¯´ PLT.dot.showï¼Œå½“ç„¶ã€‚è¿™ä¸ªæ˜¯ç»˜å›¾å‡½æ•°ã€‚åœ¨æˆ‘ä»¬çš„ä¼˜åŒ–è¿‡ç¨‹ä¸­ï¼Œå¦‚æœæˆ‘ä»¬å°† plot steps è®¾ç½®ä¸º trueã€‚é‚£ä¹ˆæˆ‘ä»¬æƒ³åœ¨æ›´æ–°èšç±»åè¿›è¡Œç»˜å›¾ï¼Œæ‰€ä»¥æˆ‘ä»¬è¯´ã€‚å¦‚æœ
    self.dot Ploot stepsï¼Œé‚£ä¹ˆ self.dot plotã€‚å†ä¸€æ¬¡ï¼Œæˆ‘ä»¬è¿˜æƒ³åœ¨æ›´æ–°è´¨å¿ƒåè¿›è¡Œç»˜å›¾ã€‚
- en: So we put it right hereã€‚ and now we are doneã€‚ So now let's run thisã€‚ and I hope
    that everything is workingã€‚ So let's clear this and run our scriptã€‚Andã€‚Ohã€‚ I missed
    a comma hereï¼Œ line 37ã€‚Update centï¼Œ the centroids old equalsã€‚The current onesã€‚![](img/b78b3a13800e496c831fda09c2e14c17_3.png)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥æˆ‘ä»¬æŠŠå®ƒæ”¾åœ¨è¿™é‡Œã€‚ç°åœ¨æˆ‘ä»¬å®Œæˆäº†ã€‚æ‰€ä»¥ç°åœ¨è®©æˆ‘ä»¬è¿è¡Œè¿™ä¸ªã€‚æˆ‘å¸Œæœ›ä¸€åˆ‡éƒ½èƒ½æ­£å¸¸å·¥ä½œã€‚è®©æˆ‘ä»¬æ¸…ç†ä¸€ä¸‹å¹¶è¿è¡Œæˆ‘ä»¬çš„è„šæœ¬ã€‚å“¦ã€‚æˆ‘åœ¨è¿™é‡Œæ¼æ‰äº†ä¸€ä¸ªé€—å·ï¼Œè¡Œ 37ã€‚æ›´æ–°è´¨å¿ƒï¼Œæ—§çš„è´¨å¿ƒç­‰äºã€‚å½“å‰çš„ï¼![](img/b78b3a13800e496c831fda09c2e14c17_3.png)
- en: So againï¼Œ let's try thisã€‚ And now it's workingã€‚ So here we haveã€‚ I created a
    data set with four different clustersã€‚ and we can see that it correctly could
    identify themã€‚![](img/b78b3a13800e496c831fda09c2e14c17_5.png)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥å†æ¬¡ï¼Œè®©æˆ‘ä»¬è¯•ä¸€ä¸‹ã€‚ç°åœ¨å®ƒæ­£åœ¨å·¥ä½œã€‚è¿™é‡Œæˆ‘åˆ›å»ºäº†ä¸€ä¸ªåŒ…å«å››ä¸ªä¸åŒèšç±»çš„æ•°æ®é›†ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å®ƒæ­£ç¡®åœ°è¯†åˆ«äº†å®ƒä»¬ã€‚![](img/b78b3a13800e496c831fda09c2e14c17_5.png)
- en: So let's set plot steps to true and don't plot it at the endã€‚ And now let's
    run it againã€‚![](img/b78b3a13800e496c831fda09c2e14c17_7.png)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è®©æˆ‘ä»¬æŠŠ plot steps è®¾ç½®ä¸º trueï¼Œå¹¶ä¸”åœ¨æœ€åä¸ç»˜å›¾ã€‚ç°åœ¨è®©æˆ‘ä»¬å†è¿è¡Œä¸€æ¬¡ï¼![](img/b78b3a13800e496c831fda09c2e14c17_7.png)
- en: To see the different stepsã€‚ So hereï¼Œ this is after our initializationã€‚ So we
    randomly picked some samples and said these are our first centroidsã€‚ So maybe
    the initialization is not very good hereï¼Œ butã€‚You could find out the clusters
    correctly laterã€‚ So let's see what's happeningã€‚
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æŸ¥çœ‹ä¸åŒçš„æ­¥éª¤ã€‚æ‰€ä»¥è¿™é‡Œï¼Œè¿™æ˜¯æˆ‘ä»¬åˆå§‹åŒ–ä¹‹åçš„çŠ¶æ€ã€‚æˆ‘ä»¬éšæœºé€‰å–äº†ä¸€äº›æ ·æœ¬ï¼Œå¹¶è¡¨ç¤ºè¿™äº›æ˜¯æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªè´¨å¿ƒã€‚å› æ­¤ï¼Œåˆå§‹åŒ–å¯èƒ½ä¸æ˜¯å¾ˆå¥½ï¼Œä½†ã€‚ä½ å¯ä»¥åœ¨åé¢æ­£ç¡®æ‰¾åˆ°èšç±»ã€‚é‚£ä¹ˆæˆ‘ä»¬æ¥çœ‹çœ‹å‘ç”Ÿäº†ä»€ä¹ˆã€‚
- en: So now we are so then we are starting to optimizeã€‚ So now in the next stepã€‚
    we are calculating the new centroidsã€‚So I think the centroid of the blue cluster
    is moving to maybe over here and the orange centroid is moving to down hereã€‚ So
    let's look at the next stepã€‚ So yeahï¼Œ and now we are updating the labelsã€‚ So I
    think these here are no longer orange but red and greenã€‚Soã€‚Yeahã€‚
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ç°åœ¨æˆ‘ä»¬å¼€å§‹ä¼˜åŒ–ã€‚ç°åœ¨åœ¨ä¸‹ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬æ­£åœ¨è®¡ç®—æ–°çš„è´¨å¿ƒã€‚æˆ‘è®¤ä¸ºè“è‰²èšç±»çš„è´¨å¿ƒæ­£åœ¨ç§»åŠ¨åˆ°è¿™é‡Œï¼Œè€Œæ©™è‰²è´¨å¿ƒæ­£åœ¨ç§»åŠ¨åˆ°ä¸‹é¢ã€‚è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹ä¸‹ä¸€æ­¥ã€‚æ‰€ä»¥æ˜¯çš„ï¼Œç°åœ¨æˆ‘ä»¬åœ¨æ›´æ–°æ ‡ç­¾ã€‚æˆ‘è®¤ä¸ºè¿™äº›ä¸å†æ˜¯æ©™è‰²ï¼Œè€Œæ˜¯çº¢è‰²å’Œç»¿è‰²ã€‚æ‰€ä»¥ã€‚æ˜¯çš„ã€‚
- en: and also some of them are now redã€‚ And now we update our centroids againã€‚ So
    I think this will further move over hereã€‚ This will move down hereã€‚And these will
    move a little bitã€‚ So yeahã€‚And now we again update our labelsã€‚ So I think more
    of them will become red and more of them here will become greenã€‚Soï¼Œ and now againã€‚
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜æœ‰ä¸€äº›ç°åœ¨å˜æˆäº†çº¢è‰²ã€‚ç°åœ¨æˆ‘ä»¬å†æ¬¡æ›´æ–°æˆ‘ä»¬çš„è´¨å¿ƒã€‚æˆ‘è®¤ä¸ºè¿™å°†è¿›ä¸€æ­¥ç§»åŠ¨åˆ°è¿™é‡Œã€‚è¿™ä¸ªä¼šå‘ä¸‹ç§»åŠ¨ã€‚è¿™äº›ä¼šç§»åŠ¨ä¸€ç‚¹ã€‚æ‰€ä»¥æ˜¯çš„ã€‚ç°åœ¨æˆ‘ä»¬å†æ¬¡æ›´æ–°æˆ‘ä»¬çš„æ ‡ç­¾ã€‚æˆ‘è®¤ä¸ºæ›´å¤šçš„å°†å˜æˆçº¢è‰²ï¼Œè¿™é‡Œæ›´å¤šçš„å°†å˜æˆç»¿è‰²ã€‚æ‰€ä»¥ï¼Œç°åœ¨å†æ¬¡ã€‚
- en: we update our centroidã€‚ So I think this will further move over hereã€‚ The red
    centroid will move over hereã€‚ This is already goodã€‚ And the green 1 or moves over
    hereã€‚ I thinkã€‚Soï¼Œ yepï¼Œ that's thatã€‚ And now againï¼Œ we update the labelsã€‚ now againã€‚
    the centroids and the labelsã€‚ And now I think we are convergedã€‚ Soï¼Œ yeahã€‚
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ›´æ–°æˆ‘ä»¬çš„è´¨å¿ƒã€‚æˆ‘è®¤ä¸ºè¿™å°†è¿›ä¸€æ­¥ç§»åŠ¨åˆ°è¿™é‡Œã€‚çº¢è‰²è´¨å¿ƒå°†ç§»åŠ¨åˆ°è¿™é‡Œã€‚è¿™å·²ç»å¾ˆå¥½äº†ã€‚ç»¿è‰²çš„è´¨å¿ƒä¹Ÿç§»åŠ¨åˆ°è¿™é‡Œã€‚æˆ‘è®¤ä¸ºã€‚æ˜¯çš„ï¼Œå°±æ˜¯è¿™æ ·ã€‚ç°åœ¨æˆ‘ä»¬å†æ¬¡æ›´æ–°æ ‡ç­¾ã€‚ç°åœ¨å†æ¬¡ï¼Œè´¨å¿ƒå’Œæ ‡ç­¾ã€‚ç°åœ¨æˆ‘è®¤ä¸ºæˆ‘ä»¬å·²ç»æ”¶æ•›äº†ã€‚æ‰€ä»¥ï¼Œæ˜¯çš„ã€‚
- en: this is how the K meanss worksã€‚ And I hope you understood everythingã€‚ And if
    you liked itã€‚ please subscribe to the channel and see you next time byã€‚![](img/b78b3a13800e496c831fda09c2e14c17_9.png)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯ K å‡å€¼å¦‚ä½•å·¥ä½œçš„ã€‚æˆ‘å¸Œæœ›ä½ ç†è§£äº†ä¸€åˆ‡ã€‚å¦‚æœä½ å–œæ¬¢ï¼Œè¯·è®¢é˜…é¢‘é“ï¼Œä¸‹æ¬¡å†è§ï¼![](img/b78b3a13800e496c831fda09c2e14c17_9.png)
- en: '![](img/b78b3a13800e496c831fda09c2e14c17_10.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b78b3a13800e496c831fda09c2e14c17_10.png)'
