- en: ã€åŒè¯­å­—å¹•+èµ„æ–™ä¸‹è½½ã€‘SQLå¸¸ç”¨çŸ¥è¯†ç‚¹åˆè¾‘â€”â€”é«˜æ•ˆä¼˜é›…çš„å­¦ä¹ æ•™ç¨‹ï¼Œå¤æ‚SQLå‰–æä¸æœ€ä½³å®è·µï¼ï¼œå¿«é€Ÿå…¥é—¨ç³»åˆ—ï¼ - P10ï¼šL10- ANDã€OR å’Œ NOT
    è¿ç®—ç¬¦ - ShowMeAI - BV1Pu41117ku
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ã€åŒè¯­å­—å¹•+èµ„æ–™ä¸‹è½½ã€‘SQLå¸¸ç”¨çŸ¥è¯†ç‚¹åˆè¾‘â€”â€”é«˜æ•ˆä¼˜é›…çš„å­¦ä¹ æ•™ç¨‹ï¼Œå¤æ‚SQLå‰–æä¸æœ€ä½³å®è·µï¼ï¼œå¿«é€Ÿå…¥é—¨ç³»åˆ—ï¼ - P10ï¼šL10- ANDã€OR å’Œ NOT
    è¿ç®—ç¬¦ - ShowMeAI - BV1Pu41117ku
- en: In this tutorial I'm going to show you how to combine multiple search conditions
    when filtering dataã€‚ so let's say we want to get all the customers that are born
    after January 1 1990 who also happen to have more than 1000 points so this is
    where we use the and operator so we type out and and after we type out another
    condition like pointsã€‚
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªæ•™ç¨‹ä¸­ï¼Œæˆ‘å°†å‘ä½ å±•ç¤ºå¦‚ä½•åœ¨è¿‡æ»¤æ•°æ®æ—¶ç»„åˆå¤šä¸ªæœç´¢æ¡ä»¶ã€‚æ‰€ä»¥å‡è®¾æˆ‘ä»¬æƒ³è¦è·å–åœ¨1990å¹´1æœˆ1æ—¥åå‡ºç”Ÿçš„æ‰€æœ‰å®¢æˆ·ï¼Œå¹¶ä¸”ä»–ä»¬çš„ç§¯åˆ†è¶…è¿‡1000ï¼Œè¿™æ—¶æˆ‘ä»¬ä½¿ç”¨ä¸è¿ç®—ç¬¦ï¼Œå› æ­¤æˆ‘ä»¬è¾“å…¥å¹¶ï¼Œç„¶ååœ¨è¾“å…¥å¦ä¸€ä¸ªæ¡ä»¶ï¼Œæ¯”å¦‚ç§¯åˆ†ã€‚
- en: ğŸ˜Šï¼ŒGreater than 1000ã€‚ Nowï¼Œ when we execute this queryã€‚ we only get customers
    who have both these conditionsã€‚ Let's take a lookã€‚ So executeã€‚ we only have two
    customersã€‚ And if you lookï¼Œ both these people are born after 1990ã€‚ And they have
    more than 1000 pointsã€‚ So this is the and operatorã€‚ when me use this operatorã€‚
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ˜Šï¼Œå¤§äº1000ã€‚ç°åœ¨ï¼Œå½“æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢æ—¶ï¼Œæˆ‘ä»¬åªè·å¾—æ»¡è¶³è¿™ä¸¤ä¸ªæ¡ä»¶çš„å®¢æˆ·ã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ã€‚æ‰€ä»¥æ‰§è¡Œã€‚æˆ‘ä»¬åªæœ‰ä¸¤ä½å®¢æˆ·ã€‚å¦‚æœä½ çœ‹ï¼Œè¿™ä¸¤ä½éƒ½æ˜¯åœ¨1990å¹´åå‡ºç”Ÿï¼Œå¹¶ä¸”ä»–ä»¬çš„ç§¯åˆ†è¶…è¿‡1000ã€‚è¿™å°±æ˜¯ä¸è¿ç®—ç¬¦çš„ä½œç”¨ã€‚
- en: both these conditions should be trueã€‚ In contrast to the and operatorï¼Œ we have
    the or operatorã€‚ So with orï¼Œ if at least one of these conditions is trueã€‚ that
    row will be returned in the results setã€‚ Let's take a lookã€‚ Now we execute this
    query againã€‚ instead of two records we haveã€‚ğŸ˜Šï¼ŒQuite a few recordsã€‚ So for exampleã€‚
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªæ¡ä»¶éƒ½åº”è¯¥ä¸ºçœŸã€‚ä¸ä¸è¿ç®—ç¬¦ç›¸å¯¹ï¼Œæˆ‘ä»¬æœ‰æˆ–è¿ç®—ç¬¦ã€‚æ‰€ä»¥ä½¿ç”¨æˆ–æ—¶ï¼Œåªè¦è¿™ä¸¤ä¸ªæ¡ä»¶ä¸­çš„è‡³å°‘ä¸€ä¸ªä¸ºçœŸï¼Œè¯¥è¡Œå°±ä¼šåœ¨ç»“æœé›†ä¸­è¿”å›ã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ã€‚ç°åœ¨æˆ‘ä»¬å†æ¬¡æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ã€‚ç»“æœä¸æ˜¯ä¸¤æ¡è®°å½•ï¼Œè€Œæ˜¯ğŸ˜Šï¼Œç›¸å½“å¤šçš„è®°å½•ã€‚æ‰€ä»¥ä¾‹å¦‚ã€‚
- en: we have this person who is not born after 1990ï¼Œ but if you look at their pointsã€‚
    they have more than 1000 pointsã€‚ So any customer records that satisfies at least
    one of these conditions will be returnedã€‚ Now let's take this to the next levelã€‚
    Let's say we want to get customers who are either born after 1990 or they should
    have at least 1 thousand00 points and live in Virginiaã€‚ So this is how we do thisã€‚We
    type out andï¼Œ and then we add another conditionï¼Œ state equals Virginiaã€‚
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰è¿™ä¸ªäººåœ¨1990å¹´åå‡ºç”Ÿï¼Œä½†å¦‚æœä½ çœ‹ä»–ä»¬çš„ç§¯åˆ†ï¼Œä»–ä»¬è¶…è¿‡äº†1000åˆ†ã€‚å› æ­¤ï¼Œä»»ä½•æ»¡è¶³è‡³å°‘ä¸€ä¸ªæ¡ä»¶çš„å®¢æˆ·è®°å½•éƒ½ä¼šè¢«è¿”å›ã€‚ç°åœ¨è®©æˆ‘ä»¬å°†å…¶æå‡åˆ°ä¸‹ä¸€ä¸ªå±‚æ¬¡ã€‚å‡è®¾æˆ‘ä»¬æƒ³è¦è·å–åœ¨1990å¹´åå‡ºç”Ÿçš„å®¢æˆ·ï¼Œæˆ–è€…ä»–ä»¬åº”è¯¥è‡³å°‘æœ‰100000ç§¯åˆ†å¹¶ä¸”å±…ä½åœ¨å¼—å‰å°¼äºšå·ã€‚æ‰€ä»¥æˆ‘ä»¬è¿™æ ·åšã€‚æˆ‘ä»¬è¾“å…¥å¹¶ï¼Œç„¶åæ·»åŠ å¦ä¸€ä¸ªæ¡ä»¶ï¼Œå·ç­‰äºå¼—å‰å°¼äºšã€‚
- en: Let's execute this query and see what we getã€‚ We only get full recordsã€‚ So these
    are the customers that are born either after 1990 or they have more than 1000
    points and live in Virginiaã€‚ If you look at the first customer hereï¼Œ this person
    is not born after 1990ã€‚ but you can see that she lives in Virginia and she has
    more than 1000 pointsã€‚
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ï¼Œçœ‹çœ‹æˆ‘ä»¬å¾—åˆ°ä»€ä¹ˆã€‚æˆ‘ä»¬åªå¾—åˆ°å®Œæ•´çš„è®°å½•ã€‚å› æ­¤ï¼Œè¿™äº›å®¢æˆ·è¦ä¹ˆæ˜¯åœ¨1990å¹´åå‡ºç”Ÿï¼Œè¦ä¹ˆç§¯åˆ†è¶…è¿‡1000ä¸”å±…ä½åœ¨å¼—å‰å°¼äºšã€‚å¦‚æœä½ çœ‹è¿™é‡Œçš„ç¬¬ä¸€ä¸ªå®¢æˆ·ï¼Œè¿™ä¸ªäººå¹¶æ²¡æœ‰åœ¨1990å¹´åå‡ºç”Ÿï¼Œä½†ä½ å¯ä»¥çœ‹åˆ°å¥¹ä½åœ¨å¼—å‰å°¼äºšï¼Œå¹¶ä¸”ç§¯åˆ†è¶…è¿‡1000ã€‚
- en: So the last two conditions are true for this customerã€‚Now when combining multiple
    logical operatorsã€‚ you need to be aware of the order of these operatorsã€‚ so earlier
    I talked about the order of arithmetic operatorsã€‚ I told you that multiplication
    have a higher order than addition and subtraction and we can use parenthses to
    override the default order we have the same concept in logical operators So the
    and operator is always evaluated first So when this query is executed the query
    execution engine first evaluates this condition because here we're using an and
    it doesn't matter that we typed out this condition after the first condition because
    the and operator has a higher precedence Now you can always change the order using
    parenthsesis and this also makes sure code cleaner and easier to understandã€‚
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥æœ€åä¸¤ä¸ªæ¡ä»¶å¯¹äºè¿™ä¸ªå®¢æˆ·æ˜¯æˆç«‹çš„ã€‚ç°åœ¨ï¼Œåœ¨ç»„åˆå¤šä¸ªé€»è¾‘è¿ç®—ç¬¦æ—¶ï¼Œä½ éœ€è¦æ³¨æ„è¿™äº›è¿ç®—ç¬¦çš„é¡ºåºã€‚æ—©äº›æ—¶å€™æˆ‘è°ˆåˆ°äº†ç®—æœ¯è¿ç®—ç¬¦çš„é¡ºåºã€‚æˆ‘å‘Šè¯‰è¿‡ä½ ï¼Œä¹˜æ³•çš„ä¼˜å…ˆçº§é«˜äºåŠ æ³•å’Œå‡æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ‹¬å·æ¥è¦†ç›–é»˜è®¤é¡ºåºï¼Œé€»è¾‘è¿ç®—ç¬¦ä¹Ÿæœ‰ç›¸åŒçš„æ¦‚å¿µã€‚æ‰€ä»¥ä¸è¿ç®—ç¬¦æ€»æ˜¯ä¼˜å…ˆè®¡ç®—ã€‚å› æ­¤ï¼Œå½“æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢æ—¶ï¼ŒæŸ¥è¯¢æ‰§è¡Œå¼•æ“é¦–å…ˆè¯„ä¼°è¿™ä¸ªæ¡ä»¶ï¼Œå› ä¸ºåœ¨è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯ä¸è¿ç®—ç¬¦ï¼Œå³ä½¿æˆ‘ä»¬åœ¨ç¬¬ä¸€ä¸ªæ¡ä»¶åè¾“å…¥äº†è¿™ä¸ªæ¡ä»¶ä¹Ÿæ— æ‰€è°“ï¼Œå› ä¸ºä¸è¿ç®—ç¬¦å…·æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§ã€‚ç°åœ¨ï¼Œä½ å§‹ç»ˆå¯ä»¥ä½¿ç”¨æ‹¬å·æ”¹å˜é¡ºåºï¼Œè¿™ä¹Ÿç¡®ä¿äº†ä»£ç æ›´ç®€æ´ï¼Œæ›´æ˜“äºç†è§£ã€‚
- en: ğŸ˜Šï¼ŒSo here we can put parenthesesisã€‚Around is last two conditionsã€‚And also we
    can put these on a new lineã€‚ğŸ˜Šï¼ŒFor clarityï¼Œ something like thisã€‚So anyone who reads
    this code can easily understand what is the intent of this queryï¼Ÿ
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ˜Šï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨æœ€åä¸¤ä¸ªæ¡ä»¶å‘¨å›´åŠ ä¸Šæ‹¬å·ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥æŠŠè¿™äº›æ”¾åœ¨æ–°çš„ä¸€è¡Œã€‚ğŸ˜Šï¼Œä¸ºäº†æ¸…æ™°ï¼Œåƒè¿™æ ·ã€‚æ‰€ä»¥ä»»ä½•é˜…è¯»è¿™æ®µä»£ç çš„äººéƒ½å¯ä»¥å¾ˆå®¹æ˜“ç†è§£è¿™ä¸ªæŸ¥è¯¢çš„æ„å›¾ï¼Ÿ
- en: Now we also have another logical operator called notï¼Œ and we use that to negate
    a conditionã€‚ let me show youï¼Œ so I'm going to simplify our word clauseã€‚ğŸ˜Šï¼ŒLet's
    sayã€‚Re're searchingching for customers who were born after 1990ï¼Œ or they have
    more than 100 pointsã€‚ If we execute this queryï¼Œ we getã€‚These peopleï¼Œ customers
    with ID1ï¼Œ 3ï¼Œ5ï¼Œ and so onã€‚
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬è¿˜æœ‰å¦ä¸€ä¸ªé€»è¾‘æ“ä½œç¬¦ç§°ä¸ºéï¼Œæˆ‘ä»¬ç”¨å®ƒæ¥å¦å®šä¸€ä¸ªæ¡ä»¶ã€‚è®©æˆ‘ç»™ä½ æ¼”ç¤ºä¸€ä¸‹ï¼Œæ‰€ä»¥æˆ‘å°†ç®€åŒ–æˆ‘ä»¬çš„â€œæˆ–â€å­å¥ã€‚ğŸ˜Šå‡è®¾æˆ‘ä»¬æ­£åœ¨å¯»æ‰¾1990å¹´åå‡ºç”Ÿçš„å®¢æˆ·ï¼Œæˆ–è€…ä»–ä»¬çš„ç§¯åˆ†è¶…è¿‡100ã€‚
    å¦‚æœæˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ï¼Œæˆ‘ä»¬å¾—åˆ°ã€‚è¿™äº›äººï¼Œå®¢æˆ·IDä¸º1ã€3ã€5ï¼Œç­‰ç­‰ã€‚
- en: Now we can use the not operator to negate this conditionã€‚ so we apply not here
    and preferably we also put parenthesis around this conditionã€‚ Nowã€‚ when we execute
    this queryï¼Œ we'll see other customers that are not in the current result setã€‚
    Let's take a lookã€‚ğŸ˜Šï¼ŒSo instead of customers with IDsï¼Œ 1ï¼Œ3ï¼Œ5ï¼Œ6ï¼Œ and so onã€‚
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥ä½¿ç”¨éæ“ä½œç¬¦æ¥å¦å®šè¿™ä¸ªæ¡ä»¶ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨è¿™é‡Œåº”ç”¨éæ“ä½œç¬¦ï¼Œå¹¶ä¸”æœ€å¥½åœ¨è¿™ä¸ªæ¡ä»¶å‘¨å›´åŠ ä¸Šæ‹¬å·ã€‚ç°åœ¨ï¼Œå½“æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢æ—¶ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°å…¶ä»–ä¸åœ¨å½“å‰ç»“æœé›†ä¸­çš„å®¢æˆ·ã€‚è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ã€‚ğŸ˜Šå› æ­¤ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„å®¢æˆ·IDä¸º1ã€3ã€5ã€6ï¼Œç­‰ç­‰ã€‚
- en: we get the customers with IDs 2ï¼Œ4ï¼Œ and 10ã€‚Now technicallyã€‚ these customers were
    born before 1990 and they have less than 1000 pointsã€‚ So if you look hereã€‚This
    first customer was born before 1990ï¼Œ and he has less than 1000 pointsã€‚ How did
    I know thatã€‚ Let me show you a trick that I learned in mathã€‚Whenever you have
    a not operatorã€‚
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¾—åˆ°çš„å®¢æˆ·IDä¸º2ã€4å’Œ10ã€‚ç°åœ¨ä»æŠ€æœ¯ä¸Šè®²ï¼Œè¿™äº›å®¢æˆ·å‡ºç”Ÿåœ¨1990å¹´ä¹‹å‰ï¼Œå¹¶ä¸”ç§¯åˆ†å°‘äº1000ã€‚æ‰€ä»¥å¦‚æœä½ çœ‹çœ‹è¿™é‡Œï¼Œç¬¬ä¸€ä¸ªå®¢æˆ·å‡ºç”Ÿåœ¨1990å¹´ä¹‹å‰ï¼Œå¹¶ä¸”ä»–çš„ç§¯åˆ†å°‘äº1000ã€‚æˆ‘æ€ä¹ˆçŸ¥é“çš„ï¼Ÿè®©æˆ‘å‘Šè¯‰ä½ æˆ‘åœ¨æ•°å­¦ä¸­å­¦åˆ°çš„ä¸€ä¸ªæŠ€å·§ã€‚æ¯å½“ä½ æœ‰ä¸€ä¸ªéæ“ä½œç¬¦æ—¶ã€‚
- en: you can simplify your expression like thisã€‚We apply the knot operator to the
    first conditionã€‚People who were born after 1990ã€‚How can we ne this conditionï¼Œ
    Wellã€‚ the greater than operator becomes less than or equal toã€‚ That is the inverse
    of that conditionã€‚ rightã€‚Now we apply the no to or to negate the orã€‚ What do we
    get we get andã€‚Finallyã€‚
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥è¿™æ ·ç®€åŒ–ä½ çš„è¡¨è¾¾å¼ã€‚æˆ‘ä»¬å°†éæ“ä½œç¬¦åº”ç”¨äºç¬¬ä¸€ä¸ªæ¡ä»¶ï¼Œå³åœ¨1990å¹´åå‡ºç”Ÿçš„äººã€‚æˆ‘ä»¬å¦‚ä½•å¦å®šè¿™ä¸ªæ¡ä»¶å‘¢ï¼Ÿå—¯ï¼Œå¤§äºæ“ä½œç¬¦å˜æˆäº†å°äºæˆ–ç­‰äºã€‚è¿™å°±æ˜¯è¯¥æ¡ä»¶çš„é€†ã€‚å¯¹å§ï¼Ÿç°åœ¨æˆ‘ä»¬åº”ç”¨â€œéâ€æ¥å¦å®šâ€œæˆ–â€ã€‚æˆ‘ä»¬å¾—åˆ°äº†â€œä¸â€ã€‚æœ€åã€‚
- en: apply the nut operator on the last conditionï¼Œ people who have more than 1000
    pointsã€‚ When we negate this conditionï¼Œ we get customers with less than or equal
    to 1000 pointsã€‚ Now we can remove the not operator to simplify thisã€‚ We don't
    need parenthses anymore because we only have two conditions that are combined
    with an andã€‚
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ€åä¸€ä¸ªæ¡ä»¶ä¸Šåº”ç”¨éæ“ä½œç¬¦ï¼Œå³æ‹¥æœ‰è¶…è¿‡1000ç§¯åˆ†çš„äººå‘˜ã€‚å½“æˆ‘ä»¬å¦å®šè¿™ä¸ªæ¡ä»¶æ—¶ï¼Œæˆ‘ä»¬å¾—åˆ°çš„å®¢æˆ·æ˜¯ç§¯åˆ†å°‘äºæˆ–ç­‰äº1000çš„å®¢æˆ·ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥å»æ‰éæ“ä½œç¬¦ä»¥ç®€åŒ–è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬ä¸å†éœ€è¦æ‹¬å·ï¼Œå› ä¸ºæˆ‘ä»¬åªæœ‰ä¸¤ä¸ªæ¡ä»¶æ˜¯é€šè¿‡â€œä¸â€è¿æ¥çš„ã€‚
- en: Here is the resultã€‚As you can seeï¼Œ this is much easier to read and understand
    people who were born before this date and they have less than1 thousand00 pointsã€‚![](img/13b5d6507d3427a9bc38b390177c87ae_1.png)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ç»“æœã€‚æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œè¿™æ ·é˜…è¯»å’Œç†è§£è¦å®¹æ˜“å¾—å¤šï¼Œå‡ºç”Ÿåœ¨è¿™ä¸ªæ—¥æœŸä¹‹å‰çš„äººï¼Œä»–ä»¬çš„ç§¯åˆ†å°‘äº1000ã€‚![](img/13b5d6507d3427a9bc38b390177c87ae_1.png)
- en: ã€‚
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ã€‚
- en: '![](img/13b5d6507d3427a9bc38b390177c87ae_3.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13b5d6507d3427a9bc38b390177c87ae_3.png)'
- en: All right here's your exerciseã€‚From the Order items tableã€‚Get the items for
    order number 6ã€‚ where the total price for that item is greater than 30ã€‚Al right
    here's the order items table in this table we have these columnsï¼Œ order IDï¼Œ product
    IDã€‚ quantity and unit price if I multiply the quantity by unit price we can get
    the total cost of that item and then we can compare it with 30 so let's go ahead
    and write this queryã€‚
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½çš„ï¼Œè¿™é‡Œæ˜¯ä½ çš„ç»ƒä¹ ã€‚ä»è®¢å•é¡¹è¡¨ä¸­è·å–è®¢å•å·ä¸º6çš„é¡¹ç›®ï¼Œå…¶ä¸­è¯¥é¡¹ç›®çš„æ€»ä»·æ ¼å¤§äº30ã€‚å¥½çš„ï¼Œè¿™é‡Œæ˜¯è®¢å•é¡¹è¡¨ï¼Œåœ¨è¿™ä¸ªè¡¨ä¸­æˆ‘ä»¬æœ‰è¿™äº›åˆ—ï¼šè®¢å•IDã€äº§å“IDã€æ•°é‡å’Œå•ä»·ã€‚å¦‚æœæˆ‘å°†æ•°é‡ä¹˜ä»¥å•ä»·ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°è¯¥é¡¹ç›®çš„æ€»æˆæœ¬ï¼Œç„¶åæˆ‘ä»¬å¯ä»¥å°†å…¶ä¸30è¿›è¡Œæ¯”è¾ƒï¼Œæ‰€ä»¥è®©æˆ‘ä»¬ç»§ç»­ç¼–å†™è¿™ä¸ªæŸ¥è¯¢ã€‚
- en: Selectã€‚Starã€‚From Order itemsã€‚Where here we need two conditionsï¼Œ one is for the
    orderã€‚ so order under ID should be 6ã€‚And the second conditionï¼Œ we want to calculate
    the total priceã€‚ so we get the unit priceã€‚ğŸ˜Šï¼ŒMultiply it by quantityã€‚And this value
    should be greater than 30ã€‚ so as we can seeï¼Œ we can use an arithmetic expression
    in a word classã€‚
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: é€‰æ‹©æ‰€æœ‰ã€‚æ¥è‡ªè®¢å•é¡¹è¡¨ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬éœ€è¦ä¸¤ä¸ªæ¡ä»¶ï¼Œä¸€ä¸ªæ˜¯è®¢å•ã€‚æ‰€ä»¥è®¢å•IDåº”è¯¥æ˜¯6ã€‚ç¬¬äºŒä¸ªæ¡ä»¶ï¼Œæˆ‘ä»¬æƒ³è¦è®¡ç®—æ€»ä»·æ ¼ã€‚æ‰€ä»¥æˆ‘ä»¬è·å–å•ä»·ã€‚ğŸ˜Šå°†å…¶ä¹˜ä»¥æ•°é‡ã€‚è¿™ä¸ªå€¼åº”è¯¥å¤§äº30ã€‚æ‰€ä»¥å¦‚æˆ‘ä»¬æ‰€è§ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨â€œæˆ–â€å­å¥ä¸­ä½¿ç”¨ç®—æœ¯è¡¨è¾¾å¼ã€‚
- en: it's not limited to the select class okayã€‚ğŸ˜Šï¼ŒNow let's execute this query and
    see what we getã€‚We should get only one itemã€‚That is for product1ï¼Œ here the quantity
    is 4 and unit price is just over $8ã€‚ so the total price for this item is greater
    than 30ã€‚
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¹¶ä¸å±€é™äºé€‰æ‹©ç±»ã€‚å¥½çš„ï¼ŒğŸ˜Šç°åœ¨è®©æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ï¼Œçœ‹çœ‹æˆ‘ä»¬å¾—åˆ°ä»€ä¹ˆã€‚æˆ‘ä»¬åº”è¯¥åªå¾—åˆ°ä¸€ä¸ªé¡¹ç›®ã€‚è¯¥é¡¹ç›®ä¸ºäº§å“1ï¼Œæ•°é‡ä¸º4ï¼Œå•ä»·ç•¥é«˜äº$8ï¼Œå› æ­¤è¯¥é¡¹ç›®çš„æ€»ä»·æ ¼å¤§äº30ã€‚
- en: '![](img/13b5d6507d3427a9bc38b390177c87ae_5.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13b5d6507d3427a9bc38b390177c87ae_5.png)'
