- en: 【双语字幕+资料下载】1小时掌握Python正则表达式的所有技巧！这些实用技巧可以极大加速你的查找过程~＜技能提升系列＞ - P1：Regular Expressions
    in Python - FULL COURSE (1 HOUR) - Programming Tutorial - ShowMeAI - BV1UL4y1474A
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 【双语字幕+资料下载】1小时掌握Python正则表达式的所有技巧！这些实用技巧可以极大加速你的查找过程~＜技能提升系列＞ - P1：Python中的正则表达式
    - 完整课程（1小时） - 编程教程 - ShowMeAI - BV1UL4y1474A
- en: Hey， guys， welcome to a new Python tutorial Today， I want to show you how we
    can work with regular expressions in Python。 Regular expressions or short R E
    or rex is a powerful method that is used to search for matching text patterns。
    For example， typical patterns that can be extracted from large text files with
    regular expressions or emails or domain names。😊，So at the end of this tutorial，
    you will be able to understand what this regular expression here does。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，大家好，欢迎来到新的Python教程。今天，我想展示如何在Python中使用正则表达式。正则表达式，简称RE或rex，是一种用于搜索匹配文本模式的强大方法。例如，可以使用正则表达式从大型文本文件中提取的典型模式包括电子邮件或域名。😊所以在这个教程结束时，你将能够理解这个正则表达式的作用。
- en: And theres a lot to cover in this tutorial。 Don't be overwhelmed。 I promise
    that once you have understood the concepts， it's not so hard any more。 and it
    can simplify and speed up your search tasks a lot。 So if you watch the whole tutorial
    and you will be able to understand any pattern that you want to look up。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程有很多内容要讲。不要感到不知所措。我保证一旦你理解了这些概念，就不会再那么难了。它可以大大简化和加速你的搜索任务。所以如果你观看整个教程，你将能够理解任何你想查找的模式。
- en: So now let me quickly show you what we will cover in this video。![](img/da8ee5de7a086ab699eec08ed957b1f1_1.png)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我快速展示一下我们将在这个视频中覆盖的内容。![](img/da8ee5de7a086ab699eec08ed957b1f1_1.png)
- en: So， of course， we will see how we work with the R module in Python。 Then I will
    show you what methods we have to search for matches。 what we can do with a match
    object。 Then we will talk about matter characters and more special sequences that
    can be used in patterns。 Then we talk about sets， quantifiers， Con。 And then grouping，
    then modifications。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将看到如何在Python中使用R模块。然后我会向你展示我们有哪些方法来查找匹配项，以及我们可以对匹配对象做什么。接着我们会谈谈元字符和可以在模式中使用的更多特殊序列。然后我们会谈谈集合、量词、Con。接着是分组，以及修改。
- en: So how we can modify strings with Rs。 And at the end， I show you some different
    compilation flags。![](img/da8ee5de7a086ab699eec08ed957b1f1_3.png)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用Rs修改字符串。在最后，我会给你展示一些不同的编译标志。![](img/da8ee5de7a086ab699eec08ed957b1f1_3.png)
- en: So let's start。 So as I already said， Python has a built in module that is called
    R E。 which we can use to work with regular expressions。 So we have to import R
    R。 And then we can start working with regular expressions。 So let me show you
    a very simple example first。 So let's say， here I have some test strings already。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们开始吧。正如我所说，Python有一个内置模块叫做RE，我们可以用它来处理正则表达式。因此我们需要导入RR。然后我们可以开始使用正则表达式。让我先给你展示一个非常简单的例子。假设我这里已经有一些测试字符串。
- en: So let me copy and paste this here。 So this is our test strings。![](img/da8ee5de7a086ab699eec08ed957b1f1_5.png)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我在这里复制并粘贴一下。这是我们的测试字符串。![](img/da8ee5de7a086ab699eec08ed957b1f1_5.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_6.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_6.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_7.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_7.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_8.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_8.png)'
- en: And now， let's say， for example， we want to search for the pattern ABC。 So we
    see we have this three times here。 And now let's say we want to look for ABC。
    and we create a pattern。 So let's say pattern equals。 and then we use the R E
    module and the compile method。 And then here we say R。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想搜索模式ABC。所以我们看到这里有三次。现在假设我们想查找ABC。我们创建一个模式。假设模式等于。然后我们使用RE模块和compile方法。然后在这里我们说R。
- en: and then the string ABC。 So I we'll explain what R means in a second。 And then
    we can use this pattern to find matches。 So we say matches equals pattern dot
    find iter。 And then we want to find the matches from the test string。 And now
    this will be a object that we can iterate over。 So we can say for matches in matches。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后字符串是ABC。所以我们稍后会解释R的意思。然后我们可以使用这个模式来查找匹配项。所以我们说匹配项等于模式点find iter。然后我们想从测试字符串中找到匹配项。现在这将是一个可以迭代的对象。所以我们可以说对于匹配项中的每个匹配。
- en: And then we simply。![](img/da8ee5de7a086ab699eec08ed957b1f1_10.png)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们简单地。![](img/da8ee5de7a086ab699eec08ed957b1f1_10.png)
- en: Print the match。So now let's run this。 And then we see we have two matches。
    So this is a match object。 and we can see more details。 So， for example， we can
    see the span。 So this is the start and the end position。 So this is 3，4 and 5。😊，And
    this is our match， ABC。 and a second match at position 12。 So this is position
    or index 12 in our string。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 打印匹配项。现在让我们运行这个。然后我们看到有两个匹配项。这是一个匹配对象，我们可以看到更多细节。例如，我们可以看到跨度。这是开始和结束位置。因此这是3，4和5。😊，这是我们的匹配项，ABC。第二个匹配在位置12。因此这是我们字符串中的位置或索引12。
- en: So we see that we have two matches here。 and what we also see here that our
    regular expression is k sensitive。 So it doesn't include the。Uppercase ABC into
    our matches。 So this is one thing that we must know。![](img/da8ee5de7a086ab699eec08ed957b1f1_12.png)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们看到这里有两个匹配项。我们还看到我们的正则表达式是区分大小写的。因此，它不包含大写的ABC在我们的匹配中。这是我们必须知道的一件事。![](img/da8ee5de7a086ab699eec08ed957b1f1_12.png)
- en: So one thing that I want to mention here is that instead of compiling our pattern
    explicitly。 we can use the find It method directly on the R E module。 So we could
    also just write that our matches equals R E dot find Iter。 And then we want to
    look for our， let's say， string R ABC， And then from our test string。😊。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我想提到的一件事是，我们可以直接在RE模块上使用findIt方法，而不是显式编译我们的模式。因此，我们也可以直接写成我们的匹配等于RE.dot findIter。然后我们想查找我们的，比如说，字符串R
    ABC，以及我们的测试字符串。😊
- en: So you can use it directly on the R E module。 And then we will， if we run this。
    we will see that we get the same results。 So there is not much。![](img/da8ee5de7a086ab699eec08ed957b1f1_14.png)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以直接在RE模块上使用它。如果我们运行这个，我们会看到得到相同的结果。因此没有太多的区别。![](img/da8ee5de7a086ab699eec08ed957b1f1_14.png)
- en: Of a difference here。 But I prefer to do it this way to explicitly compile the
    pattern and bind it to this object here。 So this improves readability and is also
    a little bit more flexible。So I prefer it this way。 but you should know that you
    can use both ways。![](img/da8ee5de7a086ab699eec08ed957b1f1_16.png)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太大区别。但我更喜欢这种方式来显式编译模式并将其绑定到这个对象上。因此，这提高了可读性，并且也稍微灵活一些。所以我更喜欢这样，但你应该知道你可以用两种方式。![](img/da8ee5de7a086ab699eec08ed957b1f1_16.png)
- en: And now let's talk about the why I'm using this R here briefly。 So this means
    that this is a raw string。So， for example。 if I have a string A and this includes
    some special characters like a tap。 So a backslash T that this is a tap or a back
    slash N for new line。 And then I have a string。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们简要谈谈我在这里使用R的原因。这意味着这是一个原始字符串。例如，如果我有一个字符串A，并且它包含一些特殊字符，比如制表符。所以反斜杠T是制表符，或者反斜杠N是换行符。然后我有一个字符串。
- en: So now if I print this。 Then you will see that we have the tap here at the beginning。
    So it didn't print the backslash T。 And in a pattern。 I usually want to look for
    the actual characters in my pattern。 So then I can write an R here。 And then this
    means that this is a raw string。 So Python will print this the same way as it
    is specified here。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在如果我打印这个。然后你会看到一开始有一个制表符。所以它没有打印反斜杠T。在模式中，我通常想查找我模式中的实际字符。因此我可以在这里写一个R。这意味着这是一个原始字符串。所以Python将以这里指定的方式打印它。
- en: 😊，And yeah， so I recommend to always use a raw string for your patent。 You can
    use just a normal string， but remember that you should use a raw string。![](img/da8ee5de7a086ab699eec08ed957b1f1_18.png)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 😊，是的，我建议总是为你的模式使用原始字符串。你可以使用普通字符串，但请记住，你应该使用原始字符串。![](img/da8ee5de7a086ab699eec08ed957b1f1_18.png)
- en: And yeah， so this is a short example how a regular expression is used。 So typically
    we come up with our pattern， then we compile it。 and then we use the pattern to
    find our matches。 And I will show you the different methods that we have on the
    matches now。 So now let's go over the methods to search for matches。 So we already
    have seen the find iter。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是一个简单的例子，说明如何使用正则表达式。通常我们先想出我们的模式，然后编译它，然后使用模式来查找匹配项。我将向你展示现在我们在匹配项上有的不同方法。现在让我们来看看搜索匹配项的方法。我们已经看到了find
    iter。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_20.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_20.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_21.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_21.png)'
- en: methodethod and this will give us a match object。 and I will show you what we
    can do with a match object in a second。 So now let's talk about the other methods。
    So there are three other methods。 So we can use the dot match method。 So here
    dot match。 Then we have search。 and then we also have find all。 So。😊，Now， let's
    look about the find all method first。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 方法将给我们一个匹配对象。我将稍后告诉你我们可以用匹配对象做什么。现在让我们谈谈其他方法。有三种其他方法。我们可以使用点匹配方法。所以这里点匹配。然后我们有搜索。然后我们还有查找所有。所以。😊，现在，让我们先看一下查找所有方法。
- en: So if we can say pattern dot find all， then we will simply get the string。 So
    if you see here。 I'm printing the whole match object。 So now if I want just a
    string， then I can use find all。 and now if I run this， then it will just print
    the two strings that I'm looking for。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们可以说模式点查找所有，那么我们将简单地得到字符串。所以如果你在这里看到。我正在打印整个匹配对象。现在如果我只想要一个字符串，那么我可以使用查找所有。现在如果我运行这个，它将仅打印我寻找的两个字符串。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_23.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_23.png)'
- en: So this is defined find all methods。Now， the match method determines if the
    expression matches at the beginning of the string。 So this will only return one
    match。 So here I can say match equals pattern and then match。And now。 if I print
    the match， So let's print。The match and run this。 Then we will see this is none
    because the match looks only for patterns at the beginning of our string。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就定义了查找所有方法。现在，匹配方法确定表达式是否在字符串的开头匹配。所以这只会返回一个匹配。所以在这里我可以说匹配等于模式，然后匹配。现在。如果我打印匹配，那么让我们打印。匹配并运行这个。然后我们会看到这是
    none，因为匹配只查找我们字符串开头的模式。
- en: So ABC is not at the beginning。 So now if I use 1，2，3 as a pattern。 then we
    will see this is at the beginning， So this will return one match。 And we also
    have the pattern here again。 But again， the match does only return the first。![](img/da8ee5de7a086ab699eec08ed957b1f1_25.png)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 ABC 不是在开头。现在如果我使用 1，2，3 作为模式。然后我们会看到这是在开头，所以这将返回一个匹配。我们在这里也有这个模式。但是再次强调，匹配只返回第一个。![](img/da8ee5de7a086ab699eec08ed957b1f1_25.png)
- en: Match if it is at the beginning of the string。And now we also have the search
    method。 so the search method scans through the string and looks for any location
    where the RE matches。So if you use， for example， let's look for the match ABC
    again。 Then we will see this will return none because ABC has to be at the beginning。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配如果它在字符串的开头。现在我们也有搜索方法。所以搜索方法扫描字符串并查找正则表达式匹配的任何位置。所以如果你使用，例如，让我们再次查找匹配 ABC。然后我们会看到这将返回
    none，因为 ABC 必须在开头。
- en: And now if we use the search method， then it will find the match object again。
    And it will simply return the first match。 So we have search， match， find all
    and find iter。 And this is my preferred method。 So from now on， I will only use
    this one。And then we also have some function that can be used to modify an object。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们使用搜索方法，那么它将再次找到匹配对象。它将简单地返回第一个匹配。所以我们有搜索、匹配、查找所有和查找迭代。这是我首选的方法。从现在起，我只会使用这个。然后我们还有一些可以用来修改对象的函数。
- en: So we also have split and s。 So I will come to them later。So now let's continue
    using the find iter method。 and let's have a look at what we can do with the match
    object。 So again， let's say our matches equals pattern。 and then find iter。 and
    then let's iterate over this。 So for match in matches。 and then we want to print
    the match。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们还有分割和 s。稍后我会讲到它们。所以现在让我们继续使用查找迭代方法。让我们看看我们可以对匹配对象做什么。因此，再次假设我们的匹配等于模式，然后查找迭代。然后让我们对其进行迭代。所以对匹配中的每一个匹配。然后我们想打印匹配。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_27.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_27.png)'
- en: Then。![](img/da8ee5de7a086ab699eec08ed957b1f1_29.png)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后。![](img/da8ee5de7a086ab699eec08ed957b1f1_29.png)
- en: Again， we see we have the whole match object here， and we can use four different
    methods on this so we can use the group method。 We can use the start and the end
    method。And we can get the spam， so。Let's start with the span。 So this will give
    me the。Start and the stop index where this pattern is located。 So let's print
    the match dot span。 So then we simply get this as a tuple here。So。We get 3 and
    6。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们看到这里有整个匹配对象，我们可以在此上使用四种不同的方法，所以我们可以使用组方法。我们可以使用开始和结束方法。我们还可以获取跨度。所以。让我们先从跨度开始。这将给我提供该模式的位置的开始和停止索引。所以让我们打印匹配的跨度。然后我们简单地将其作为元组获取。所以。我们得到
    3 和 6。
- en: So this is a tuer， and we can also get the。Just the start and the end right
    away by saying print match dot start and。Print match dot。And。Oh， sorry。 Here is
    I dot match dot start。So then we get the start in the stop index。 And now let's
    talk about the group method。 So now。 if we call match dot group， then we will
    get or print the。Actual string of the match。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个匹配对象，我们还可以立即获取开始和结束，只需说 print match dot start 和 print match dot。哦，抱歉。这里是我
    dot match dot start。因此我们得到开始和停止索引。现在我们来谈谈 group 方法。因此，如果我们调用 match dot group，那么我们将获取或打印匹配的实际字符串。
- en: And we can also give this group method arguments to find the group 0 or  one
    and or 2。 And we will talk about this grouping later。 But for now on。 if you just
    want the string then from the match， then just call match dot group or group 0。
    So this is the same。😊，And yes， these are the four different methods that we can
    use on a match object。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以给这个 group 方法传递参数以查找组 0 或 1 和 2。我们稍后会讨论这个分组。但目前，如果你只想从匹配中获取字符串，只需调用 match
    dot group 或 group 0。这是一样的。😊 是的，这些是我们可以在匹配对象上使用的四种不同方法。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_31.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_31.png)'
- en: And now let's come to the meta characters。 So in regular expressions。 there
    are these me characters that have a special meaning。 So these are all the me characters
    we must know。 And you don't have to know them by heart。 So I recommend that you
    keep a cheatee sheet somewhere with all this stuff。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看元字符。在正则表达式中，有一些元字符具有特殊含义。这些都是我们必须了解的元字符。你不需要记住它们，所以我建议你在某个地方保留一张备忘单，上面有所有这些内容。
- en: And I will also provide a cheat sheet on my website。 So you can check it out
    on Python minuseng dot com。 And this is all you need to know。😊。![](img/da8ee5de7a086ab699eec08ed957b1f1_33.png)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我还会在我的网站上提供一张备忘单。你可以在 Python minuseng dot com 上查看。这就是你需要知道的全部。😊！![](img/da8ee5de7a086ab699eec08ed957b1f1_33.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_34.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_34.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_35.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_35.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_36.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_36.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_37.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_37.png)'
- en: So now let's talk about these me characters one by one。![](img/da8ee5de7a086ab699eec08ed957b1f1_39.png)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们一个一个地谈谈这些元字符。![](img/da8ee5de7a086ab699eec08ed957b1f1_39.png)
- en: And then I will show you what this means。 So the first one is the dot。 So the
    dot means that we want to look for any character。 So any character except a new
    line character， then the carrot means that we want to look for a pattern that
    starts with that starts with the pattern we are looking for。 So that starts with
    a string。 hello， for example， then the dollar sign is the opposite。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我会向你展示这意味着什么。第一个是点。点表示我们要寻找任何字符。也就是除了换行符以外的任何字符，之后的插入符号意味着我们想要寻找一个以我们正在寻找的模式开头的模式。因此，它是以一个字符串开头，比如
    hello，然后美元符号则相反。
- en: if we want to look for a string at the end of our text。![](img/da8ee5de7a086ab699eec08ed957b1f1_41.png)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查找文本末尾的字符串。![](img/da8ee5de7a086ab699eec08ed957b1f1_41.png)
- en: Then we have some quantifiers。 So the asterisk， the plus and square brackets。
    and I will talk about them later in more detail。![](img/da8ee5de7a086ab699eec08ed957b1f1_43.png)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一些量词。所以星号、加号和方括号。我稍后会更详细地谈论它们。![](img/da8ee5de7a086ab699eec08ed957b1f1_43.png)
- en: Then we have the set operator， which I will also cover later。Then we have conditions。And
    grouping with parentheses。 So I will also talk about this later。 And， of course，
    we have to look。 we have the back slash。 So with the backlash， we can get more
    special sequences or we can escape character。 So， for example， if we actually
    want to search for the dot。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有集合运算符，我稍后会涵盖这个。接着我们有条件和用括号进行分组。因此，我也会稍后讨论这个。当然，我们还要查看反斜杠。通过反斜杠，我们可以获得更多特殊序列或转义字符。所以，例如，如果我们实际上想要搜索点。
- en: Then we have to escape this in our pattern。![](img/da8ee5de7a086ab699eec08ed957b1f1_45.png)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们必须在模式中转义这个。![](img/da8ee5de7a086ab699eec08ed957b1f1_45.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_46.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_46.png)'
- en: So now let's talk about the first three and show you some examples。![](img/da8ee5de7a086ab699eec08ed957b1f1_48.png)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈前三个，并给你一些例子。![](img/da8ee5de7a086ab699eec08ed957b1f1_48.png)
- en: And then later， we will cover the other meta characters in more detail。 So now，
    first。 let's say we want to look for the dot and then print all the matches。 Then
    we see we get all。![](img/da8ee5de7a086ab699eec08ed957b1f1_50.png)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将更详细地讨论其他元字符。所以现在，首先。假设我们想寻找点号，然后打印所有匹配项。然后我们看到我们得到了所有的。![](img/da8ee5de7a086ab699eec08ed957b1f1_50.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_51.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_51.png)'
- en: All the characters in our string， because the dots is looking for any character，
    except new line。![](img/da8ee5de7a086ab699eec08ed957b1f1_53.png)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们字符串中的所有字符，因为点号寻找任何字符，除了换行符。![](img/da8ee5de7a086ab699eec08ed957b1f1_53.png)
- en: So， this is the dot。And now， let's say we have a dot here at the end。 And we
    actually want to get this dot。 So then we escape it with a back slash。 And now。
    if we run this， then we just get the dot。 So now let's print the whole match object。![](img/da8ee5de7a086ab699eec08ed957b1f1_55.png)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是点号。现在，假设我们在结尾有一个点。实际上我们想得到这个点。因此我们用反斜杠进行转义。现在，如果我们运行这个，那么我们只会得到点号。现在让我们打印整个匹配对象。![](img/da8ee5de7a086ab699eec08ed957b1f1_55.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_56.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_56.png)'
- en: Then we get the dot， and we see that it is at this position。 So this is the
    dots。 And then let's have a look at the carrot。 So this is the carrot。 So let's
    say we want to look for  one to 3。 if it starts with this。And then we get one
    match object。 And for example， now， if we look for ABC， then it will return nothing
    because it's not at the beginning。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得到点号，看到它在这个位置。所以这是点号。然后我们来看一下插入符号。这是插入符号。假设我们想查找1到3。如果它以这个开头。然后我们得到了一个匹配对象。比如现在，如果我们查找ABC，那么它将返回空，因为它不在开头。
- en: And the opposite， if we want to have a look， if we want to look if this is at
    the end。 So then we can say dollar here。 And now if we run this。 and this will
    find nothing because again。 sorry， we have the。AndCo on here。This will find nothing
    because， as I said， it is case sensitive。 Now， if I am looking for upper case，
    ABC and dollar at the end。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，如果我们想看看这个是否在结尾。那么我们可以在这里说美元符号。现在如果我们运行这个。它将找不到任何内容，因为抱歉，我们这里有AndCo。这将找不到任何内容，因为如我所说，它是区分大小写的。现在，如果我查找大写的ABC和结尾的美元符号。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_58.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_58.png)'
- en: So then it found the match at the end。![](img/da8ee5de7a086ab699eec08ed957b1f1_60.png)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它在结尾找到了匹配项。![](img/da8ee5de7a086ab699eec08ed957b1f1_60.png)
- en: Alright， so now we will talk about the other meta charactersers later。 And now
    let's look at some more special characters。 So there are more special characters
    that start with a backlash。 So there is the back backlash and small D， this looks
    for any ditchit。 So0 until 9。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们稍后将讨论其他元字符。现在我们来看看一些更特殊的字符。还有更多以反斜杠开头的特殊字符。所以有反斜杠和小D，这表示寻找任何数字。0到9。
- en: Then there is the capital backlash capital D。 So this matches any nonditchit
    character。 Then there is backslash small S。 This matches any white space character，
    For example。 space tap or new line。 Then we have backslash capital is S。 this
    matches any nonwhitespace character。 So for all these patterns， all these special
    characters。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是大写反斜杠大写D。所以这个匹配任何非数字字符。接着有反斜杠小写S。这个匹配任何空格字符，例如空格、制表符或换行符。然后我们有反斜杠大写S，这个匹配任何非空格字符。所以对于所有这些模式，所有这些特殊字符。
- en: the capital pattern is kind of the opposite of the small character here。😊。![](img/da8ee5de7a086ab699eec08ed957b1f1_62.png)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 大写模式在这里有点相反于小写字符。😊。![](img/da8ee5de7a086ab699eec08ed957b1f1_62.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_63.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_63.png)'
- en: So then we have backlashlash small W。 This matches any word character。 So we
    have characters from a to C。 We also have all the capital characters。 and also
    ditches and the underscore。Then the capital Ws the opposites of any non word character。
    non alpha numeric character。Then， we have the。Back slash B。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有反斜杠小写W。这个匹配任何单词字符。所以我们有从a到C的字符。我们还有所有的大写字符，以及数字和下划线。然后大写W是任何非单词字符的相反，即非字母数字字符。然后，我们有反斜杠B。
- en: So this matches where the specified characters are at the beginning or at the
    end of a word。![](img/da8ee5de7a086ab699eec08ed957b1f1_65.png)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这与指定字符位于单词的开头或结尾时匹配。![](img/da8ee5de7a086ab699eec08ed957b1f1_65.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_66.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_66.png)'
- en: And again， we have the opposite。 So where this is not at the beginning。 So let's
    have a look at them in detail。![](img/da8ee5de7a086ab699eec08ed957b1f1_68.png)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一次，我们有相反的情况。因此在这里不是在开头。让我们详细看看它们。![](img/da8ee5de7a086ab699eec08ed957b1f1_68.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_69.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_69.png)'
- en: So let's use another test string here。 So let's， for example， use this one。![](img/da8ee5de7a086ab699eec08ed957b1f1_71.png)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在这里使用另一个测试字符串。比如说，使用这个。![](img/da8ee5de7a086ab699eec08ed957b1f1_71.png)
- en: And now， if we want to look for any ditchit here， we can simply say we want
    to look for back slash D。 And now if you run this， then we will see we have three
    matches， the dts 1，2， and 3， Now。 if we use the opposites So capital D's or any
    non ditchit。 then it will find all the characters except 1，2， and 3。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想查找任何数字字符，我们可以简单地说我们想查找反斜杠D。现在如果你运行这个，那么我们会看到有三个匹配，dts 1、2和3。现在。如果我们使用相反的情况。所以大写D或任何非数字字符。那么它会找到所有的字符，除了1、2和3。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_73.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_73.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_74.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_74.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_75.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_75.png)'
- en: Then let's have a look at the white space。 So backslash S finds any white space
    character。 So here we see we have a space here， a space here and a space here。
    And then again， the opposite。 any non white space character is any other character。😊，So
    this is the S special character。Then。 let's have a look at。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们看看空格。因此反斜杠S找到任何空格字符。这里我们看到有一个空格，这里有一个空格，还有一个空格。然后再一次，相反的情况。任何非空格字符就是其他任何字符。😊，所以这是S特殊字符。然后。让我们看看。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_77.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_77.png)'
- en: the。W character。 So any alphanumeric character。 So if I put in a W here。 then
    it finds all the word characters。![](img/da8ee5de7a086ab699eec08ed957b1f1_79.png)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: W字符。所以任何字母数字字符。如果我在这里放一个W，那么它会找到所有的字词字符。![](img/da8ee5de7a086ab699eec08ed957b1f1_79.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_80.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_80.png)'
- en: And again， the opposite capital D， This will just find the spaces in this example。
    And now let's have a look at the。![](img/da8ee5de7a086ab699eec08ed957b1f1_82.png)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，相反的大写D，这只会找到这个例子中的空格。现在让我们看看。![](img/da8ee5de7a086ab699eec08ed957b1f1_82.png)
- en: back slash。B， so now if I am looking for hello， then it will find it because
    it is at the beginning of a block。And a block is not only the beginning of a string，
    but the beginning。Of any block that follows a white space character。 So， for example，
    if we look for。Hey。Then。 it will also find there。嗯。Hey， but it will only find
    this pattern and not this one。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠B，所以现在如果我在寻找hello，那么它会找到，因为它在一个块的开头。一个块不仅是字符串的开头，而是任何后面跟着空格字符的块的开头。例如，如果我们寻找。Hey。那么。它也会在那里找到。嗯。Hey，但它只会找到这个模式，而不是这个。
- en: because it's looking for matches that are at the beginning of a block。So for
    example。 if we put this。Before a space， then it will find。Then it will find this
    pattern or this match， too。And again， the opposite。 Now， if we are looking for
    this and we put。Oh， he here again。Then it will find this hay， because it is not
    at the beginning of a block where this is at the beginning of a block。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它正在查找位于块开头的匹配项。例如，如果我们在空格之前放这个，那么它将找到。然后它也会找到这个模式或这个匹配项。再一次，相反的情况。如果我们在寻找这个并且放。哦，他在这里。然后它会找到这个hay，因为它不在一个块的开头，而这个在块的开头。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_84.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_84.png)'
- en: So these are the special sequence， special characters that we should know。![](img/da8ee5de7a086ab699eec08ed957b1f1_86.png)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些是我们应该知道的特殊序列，特殊字符。![](img/da8ee5de7a086ab699eec08ed957b1f1_86.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_87.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_87.png)'
- en: And now， let's continue with sets。![](img/da8ee5de7a086ab699eec08ed957b1f1_89.png)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论集合。![](img/da8ee5de7a086ab699eec08ed957b1f1_89.png)
- en: So we can use square brackets to look for sets。 And let me show you what this
    means。 So let's say we only have this string now。 But now， let's say we only want
    to look for。![](img/da8ee5de7a086ab699eec08ed957b1f1_91.png)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用方括号来查找集合。让我给你展示这意味着什么。假设我们现在只有这个字符串。但现在，假设我们只想查找。![](img/da8ee5de7a086ab699eec08ed957b1f1_91.png)
- en: And nonnumeric characters。 So only for these ones， then we can use a set for
    this。 So a set is a pattern between square brackets。 And now here in this set。
    we can use multiple multiple characters that we want to look up。 For example。
    we want to look for a L and a O。And now， if we run this， then it will find all
    these characters。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以及非数字字符。所以仅限于这些字符，我们可以为此使用一个集合。因此，集合是在方括号之间的模式。在这个集合中，我们可以使用多个我们想要查找的字符。例如，我们想查找
    L 和 O。现在，如果我们运行这个，它将找到所有这些字符。
- en: And you must be careful here because it doesn't look for L O。 but for any single
    character that we put into this set。And we can also specify ranges here。 we can。
    instead of， let's say， we also want to have the H and the E。 Then it will find
    any。![](img/da8ee5de7a086ab699eec08ed957b1f1_93.png)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须小心，因为它不是查找 L O，而是查找我们放入这个集合中的任何单个字符。我们也可以在这里指定范围。我们可以。比如说，我们还想要 H 和 E。那么它将找到任何。![](img/da8ee5de7a086ab699eec08ed957b1f1_93.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_94.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_94.png)'
- en: Character here。That is not a number。And also， not the backlash not the underscore。
    So we can also specify a range here。 And this is a very typical。 very common example
    and regular expressions to use a dash C。 So A to C。 So all the。![](img/da8ee5de7a086ab699eec08ed957b1f1_96.png)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的字符。那不是数字。而且也不是反斜杠，不是下划线。所以我们也可以在这里指定一个范围。这是一个非常典型的、非常常见的例子，正则表达式使用连字符 C。因此从
    A 到 C。因此所有的。![](img/da8ee5de7a086ab699eec08ed957b1f1_96.png)
- en: Lower case characters。 Now if you run this。Sometimes it's not saving this file
    automatically。 So now。 if you run this， then we see that we will find。![](img/da8ee5de7a086ab699eec08ed957b1f1_98.png)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 小写字母。现在如果你运行这个。有时它不会自动保存这个文件。所以现在。如果你运行这个，我们会发现。![](img/da8ee5de7a086ab699eec08ed957b1f1_98.png)
- en: All the。![](img/da8ee5de7a086ab699eec08ed957b1f1_100.png)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的。![](img/da8ee5de7a086ab699eec08ed957b1f1_100.png)
- en: Letters here。 And we can also look for dits。 So let's say we want only the ditits
    2 and 3。 And again。 here， we can have a range。 So we can say 1 to 9。 So this is，
    or let's say0 to 9。 And this will find all the ditches。 So this is the same as
    using back slash D to find a ditit。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的字母。我们也可以查找数字。所以我们可以说我们只想要数字 2 和 3。再一次，在这里，我们可以有一个范围。所以我们可以说 1 到 9。因此，这是，或者说
    0 到 9。这将找到所有的数字。因此，这与使用反斜杠 D 查找数字是相同的。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_102.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_102.png)'
- en: And so， yeah， so if you want to specify a。Range， then the the dash can be used
    to。 to declare to define the range。 And now if you use it after a range。 then
    it's looking for the actual dash。 So now if you also want to look up a dash。 then
    we can find it here。 And if you put it between two things， then it is a range。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，是的，如果你想指定一个范围，那么连字符可以用于声明以定义范围。如果你在一个范围后使用它，那么它就是在查找实际的连字符。所以现在，如果你还想查找一个连字符，那么我们可以在这里找到它。如果你把它放在两个事物之间，那么它就是一个范围。
- en: So be careful here。And we can also。Right our different range is back to back。
    So for example。 if you have。Hello here in upper case letters。 And first of all。
    let's say we only want the lower case letters。 And then we also want to have all
    the uppercase characters from A to C。 Then we can write this back to back so we
    can say small， A to C or a dash C， then capital a dash C。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里要小心。我们也可以。将不同的范围背靠背地写出来。例如。如果你在这里有“Hello”用大写字母。首先，我们可以说我们只想要小写字母。然后我们还想要从
    A 到 C 的所有大写字母。然后我们可以背靠背地写出这个，所以我们可以说小写字母，A 到 C 或 a - C，然后大写 A - C。
- en: Then this will also include all the uppercase characters。 And again。 we can
    use back to back and also include numbers。![](img/da8ee5de7a086ab699eec08ed957b1f1_104.png)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这也会包括所有的大写字母。再次，我们可以使用背靠背的方式，也包括数字。![](img/da8ee5de7a086ab699eec08ed957b1f1_104.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_105.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_105.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_106.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_106.png)'
- en: So， yeah。 then it also finds the numbers here。 So the ditits。 So， yeah。 so this
    is how we can use sets with this brackets。![](img/da8ee5de7a086ab699eec08ed957b1f1_108.png)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，是的。然后它也找到这里的数字。所以这些数字。所以，是的。这就是我们如何使用带有这些括号的集合。![](img/da8ee5de7a086ab699eec08ed957b1f1_108.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_109.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_109.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_110.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_110.png)'
- en: And now let's talk about quantifier。 So we have these quantifier， the meta characters。
    So we have a an asterisk。 So a the the multiplication sign。 This means0 or more。
    Then we have the plus this means one or more。 Then we have the question mark。
    So this means0 or one。 And this means， or this can be used when we want to look
    for an optional character。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈量词。我们有这些量词，元字符。我们有一个星号。这是乘法符号。这意味着0个或更多。然后我们有加号，这意味着1个或更多。然后是问号，这意味着0个或1个。这可以用于查找可选字符。
- en: So it may be there， but it may also be not there。![](img/da8ee5de7a086ab699eec08ed957b1f1_112.png)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能存在，也可能不存在。![](img/da8ee5de7a086ab699eec08ed957b1f1_112.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_113.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_113.png)'
- en: Then if we want to look for a specific exact number， we can use curly braces。
    and then a number here will look for the exact number。And then we can also specify
    a range with minimum and maximum。 So if we put two numbers between the curly braces，
    then it's looking for a range。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查找一个特定的确切数字，可以使用花括号。这里的数字将查找确切的数字。我们也可以用最小值和最大值指定一个范围。所以如果我们在花括号之间放两个数字，那就是在查找一个范围。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_115.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_115.png)'
- en: Okay， so let's have a look at them in detail。 So let's say we have a string。
    let's say hello。 underscore 1，2，3。 And now let's say we want to have or we want
    to find diits。 And remember。 we can do this with with backlashlash D。 and then
    it will find all the digits。 and let's say we want to look if we have0 or more。
    So then we use an asterisk。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们详细看看它们。假设我们有一个字符串，比如说“hello_1,2,3”。现在假设我们想查找“diits”。请记住，我们可以用反斜杠D来做到这一点，然后它会找到所有的数字。假设我们想查找0个或更多。所以我们使用星号。
- en: And then it will also find all the other characters here。 because here there
    is no diitchit。 but it was looking for0 or more。 and in this case， our match is
    just an empty string。😊。![](img/da8ee5de7a086ab699eec08ed957b1f1_117.png)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它还会找到这里的所有其他字符。因为这里没有“diitchit”，但它在查找0个或更多。在这种情况下，我们的匹配就是一个空字符串。😊。![](img/da8ee5de7a086ab699eec08ed957b1f1_117.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_118.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_118.png)'
- en: And then again， an empty string， empty string， empty string。 And then here we
    have diitchits。 and then it will combine them into one match。 So now， if we just
    use the。And use it without a quantifier。 Then it puts any every single ditchit
    S one match。 And if we want to look for0 or more， we can use this with an asterisk。
    And now in this case。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次，一个空字符串，空字符串，空字符串。这里我们有“diitchits”，然后它会将它们组合成一个匹配项。所以现在，如果我们只使用这个，而不带量词。它会将每一个“ditchit”作为一个匹配项。如果我们想查找0个或更多，可以使用带星号的这个。在这种情况下。
- en: a plus is better。 So we want to look for one or more。 And then we will see it
    has only one match。 and it combined all the ditits into one match。 Then let's
    say we want to look for a diitchit that has an underscore in front of it。 So let's
    say we want to look for underscore and then the diitchit。 then it will find the
    one。 And but now let's say we don't know if there is an underscore or not。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 加号更好。所以我们想查找1个或更多。然后我们会看到它只有一个匹配项，并且它将所有的“ditits”合并为一个匹配项。然后假设我们想查找前面有下划线的“diitchit”。假设我们想查找下划线和“diitchit”，它就会找到那个。但现在假设我们不知道是否有下划线。
- en: So now if the string looks like this。 And then if we run it， then it doesn't
    find a string， a match。 And then we can say that the underscore is。![](img/da8ee5de7a086ab699eec08ed957b1f1_120.png)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果字符串看起来像这样。然后如果我们运行它，它就不会找到字符串，也没有匹配项。我们可以说下划线是。![](img/da8ee5de7a086ab699eec08ed957b1f1_120.png)
- en: Optional by using the question mark。 And now if we run it， it finds all the
    matches。Because it doesn't has an underscore。 And now， if we do it like this。
    then it will find the same matches because it can also have an underscore here。So
    this is the question mark。And now let's talk about specific ranges or or a specific
    number of， of。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用问号来实现可选性。如果我们运行它，就会找到所有的匹配项。因为它没有下划线。如果我们这样做，那么它会找到相同的匹配项，因为这里也可以有一个下划线。这就是问号。现在让我们讨论特定范围或特定数字。
- en: Characters， so now if you want to look for three ditits。 then we can see a dititchit
    and then curly race and then 3。 Then it will find our match。 So now if we are
    looking for four of the ditits and runners， then we don't have a match。 and we
    can also use a range here。 So this can be can be between one and 3。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 字符，现在如果你想查找三个数字，那么我们可以看到一个数字匹配，然后是花括号，然后是3。这样它就能找到匹配。因此，现在如果我们在寻找四个数字和运行者，那么我们没有匹配。我们也可以在这里使用范围。所以这可以是1到3之间。
- en: and then it will also find the match。😊，So these are the quantifiers。 Now。 let's
    stop for a second with all the concepts and just make or just do an example。 So
    let me copy this。![](img/da8ee5de7a086ab699eec08ed957b1f1_122.png)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它也会找到匹配。😊这些是量词。现在，让我们停下来，停一下所有概念，做一个例子。所以让我复制这个。![](img/da8ee5de7a086ab699eec08ed957b1f1_122.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_123.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_123.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_124.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_124.png)'
- en: String here。 And now let's use some of the concepts that we already know。So
    let's say our string is now the date string。 So this is dates in different formats。
    So。 for example， here， we have the day then the month and then the year。 and this
    is separated by a colon。 Then here it its the year first。 then a colon。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串在这里。现在让我们使用一些我们已经知道的概念。假设我们的字符串现在是日期字符串。这是不同格式的日期。例如，这里我们有日期、月份和年份，它们由冒号分隔。然后这里是年份在前面，然后是一个冒号。
- en: Then here we have year month and day separated by a dash。 Then here by a s。
    and also by an underscore。![](img/da8ee5de7a086ab699eec08ed957b1f1_126.png)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在这里我们有年份、月份和日期，由破折号分隔。然后这里由s分隔，也由下划线分隔。![](img/da8ee5de7a086ab699eec08ed957b1f1_126.png)
- en: And now， let's say， we only want to extract。The dates with this format so year，
    month and day。 and only with a dash in between， so。![](img/da8ee5de7a086ab699eec08ed957b1f1_128.png)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们只想提取这种格式的日期，即年份、月份和日期，并且只有破折号分隔。![](img/da8ee5de7a086ab699eec08ed957b1f1_128.png)
- en: Let's do this so。The first thing we can do is now here is to look for。![](img/da8ee5de7a086ab699eec08ed957b1f1_130.png)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样做。我们可以做的第一件事是现在在这里查找。![](img/da8ee5de7a086ab699eec08ed957b1f1_130.png)
- en: This patterns of 4，2。 and again， two ditits。 So we can write this up。 So backlash
    D， backlash D。 back slash D。 And then let's say， first of all。![](img/da8ee5de7a086ab699eec08ed957b1f1_132.png)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式是4，2，再加上两个数字。所以我们可以写这个。所以反斜杠D，反斜杠D，反斜杠D。然后我们假设，首先。![](img/da8ee5de7a086ab699eec08ed957b1f1_132.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_133.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_133.png)'
- en: We want to look for any character between。 So remember， the point is a meta
    character。 So this is looking。 if we have a look at this here， this is looking
    for any character。 except new line。![](img/da8ee5de7a086ab699eec08ed957b1f1_135.png)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要查找任意字符。因此，请记住，点号是一个元字符。所以这是在查找。如果我们在这里看，这就是在查找任意字符，除了换行符。![](img/da8ee5de7a086ab699eec08ed957b1f1_135.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_136.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_136.png)'
- en: Then we have two diits。 So backlashlash D， Then again， we can have any character
    and then D and。![](img/da8ee5de7a086ab699eec08ed957b1f1_138.png)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有两个数字。所以反斜杠D，那么再次，我们可以有任意字符，然后是D和。![](img/da8ee5de7a086ab699eec08ed957b1f1_138.png)
- en: Back slash D。 So， for example， if our string has also some text in it。 and now
    if we run this。![](img/da8ee5de7a086ab699eec08ed957b1f1_140.png)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠D。所以，例如，如果我们的字符串中还有一些文本，现在如果我们运行这个。![](img/da8ee5de7a086ab699eec08ed957b1f1_140.png)
- en: Now， it's called dates， the string。 Now， if we run this， then it will find all
    the。![](img/da8ee5de7a086ab699eec08ed957b1f1_142.png)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它被称为日期字符串。现在，如果我们运行这个，它将找到所有的。![](img/da8ee5de7a086ab699eec08ed957b1f1_142.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_143.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_143.png)'
- en: 嗯。All the statess with， with the numbers。 but only in this format。 So 4，2，2。
    So， for example。 it didn't put the text here， the hello text in here。 and it didn't
    put this date in here because it has a different format。![](img/da8ee5de7a086ab699eec08ed957b1f1_145.png)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯。所有的状态都有数字，但只有这种格式。所以是4，2，2。例如，它没有把文本放在这里，hello文本没有在这里，也没有把这个日期放在这里，因为它的格式不同。![](img/da8ee5de7a086ab699eec08ed957b1f1_145.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_146.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_146.png)'
- en: So， now。This is our first try。 and now what we can do here is， for example。
    the next thing we want to do is to find only these in this format。 So now let's
    have a look at。 So let's exchange the dot by a dash。 So this is looking for an
    actual dash。 And then we have only the dates in this format。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在。这是我们的第一次尝试。我们可以做的事情是，例如。我们想做的下一件事是找到这种格式的内容。现在让我们看看。我们将点替换为破折号。所以这是在寻找一个实际的破折号。然后我们只有这种格式的日期。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_148.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_148.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_149.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_149.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_150.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_150.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_151.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_151.png)'
- en: So 4，2 and two numbers separated by a dash。 And let's say we this may also be
    a valid date。 So we can also looking for a slash as an separator here so then
    we can use a set。So remember。 a set is defined in square bracketets， and then
    we can define the characters that may be at this position。 So， for example， we
    have a dash and we have also or may have a slash。 And again。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所以4，2和两个用破折号分隔的数字。假设这可能也是一个有效的日期。所以我们还可以在这里使用斜杠作为分隔符，这样我们就可以使用一个集合。记住，集合是在方括号中定义的，我们可以定义在这个位置可能出现的字符。例如，我们有一个破折号，可能还有一个斜杠。再次强调。
- en: here we are using a set。 So then we have dash slash。And are closing our set。
    And now。 if we run this again， then we see。![](img/da8ee5de7a086ab699eec08ed957b1f1_153.png)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用一个集合。所以我们有破折号斜杠。并且关闭我们的集合。现在，如果我们再运行一次，就会看到。![](img/da8ee5de7a086ab699eec08ed957b1f1_153.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_154.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_154.png)'
- en: 3， we see that this is also included in the matches。 And now， let's say， for
    example。 we are looking only for dates in May or June。 So how do we do that， So
    the month here。![](img/da8ee5de7a086ab699eec08ed957b1f1_156.png)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 3，我们看到这也包含在匹配中。现在，假设，例如。我们只在寻找五月或六月的日期。那么我们该怎么做呢，这里是月份。![](img/da8ee5de7a086ab699eec08ed957b1f1_156.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_157.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_157.png)'
- en: So what we do here is now， this is not。![](img/da8ee5de7a086ab699eec08ed957b1f1_159.png)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们现在做的是，这不是。![](img/da8ee5de7a086ab699eec08ed957b1f1_159.png)
- en: Any diitchit。 So here we are only looking for month。![](img/da8ee5de7a086ab699eec08ed957b1f1_161.png)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数字。所以这里我们只在寻找月份。![](img/da8ee5de7a086ab699eec08ed957b1f1_161.png)
- en: 0，5 and 0，6。 So we always have a0 here， and then we can again use a set。 And
    here we can use let's say only 5 and 6。 And now if we run this。 and we only have
    the dates in May or June。 And remember， we can also use a range here。 So let's
    say we want to have May， June and July。 then we can say 5 to 7。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 0，5和0，6。所以我们这里总是有一个0，然后我们可以再次使用一个集合。这里我们可以说只有5和6。现在如果我们运行这个。我们只得到五月或六月的日期。记住，我们也可以在这里使用范围。所以假设我们想要有五月、六月和七月。然后我们可以说从5到7。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_163.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_163.png)'
- en: And then we have all the dates from May to July。And now let's use a quantifier
    here。 So instead of writing for D's here， backslash D， we can say D and then curly
    braces and use the quantifier for。 So we want to have exactly four ditits here。
    And here we want to have exactly two diits。So then we can do it like this。 So
    this finds all the dates in。And May June or July in this format。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有从五月到七月的所有日期。现在让我们在这里使用一个量词。所以我们不需要在这里写四个D，而是使用反斜杠D，我们可以说D，然后用花括号，并使用量词。所以我们想要这里有正好四个数字。这里我们想要正好两个数字。这样做可以找到所有在这种格式下的五月、六月或七月的日期。
- en: So this is one typical example， how regular expressions are useful。![](img/da8ee5de7a086ab699eec08ed957b1f1_165.png)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是正则表达式有用的一个典型例子。![](img/da8ee5de7a086ab699eec08ed957b1f1_165.png)
- en: And yeah， so now let's continue。 So we already covered a lot here。 So let's
    talk about conditions next， so。![](img/da8ee5de7a086ab699eec08ed957b1f1_167.png)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，现在让我们继续。所以我们已经涵盖了很多内容。那么接下来我们谈谈条件。![](img/da8ee5de7a086ab699eec08ed957b1f1_167.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_168.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_168.png)'
- en: Let me copy another string and to another example。 So here I have another string
    with some names， so。![](img/da8ee5de7a086ab699eec08ed957b1f1_170.png)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我复制另一个字符串，做另一个例子。所以这里我有另一个包含一些名称的字符串。![](img/da8ee5de7a086ab699eec08ed957b1f1_170.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_171.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_171.png)'
- en: Let me copy and paste this year。 This is my new string。 So here we have a Mr。
    Simpson。 a Mrus Simpson， a Mr。 Brown， a Miss Smith and a Mr。 T。 And sometimes
    we have a dot between Mr and sometimes not。And now， let's just extract all the。Different
    names here。 So， for example， there is some more in our file。 So， for example。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我复制并粘贴一下。这是我的新字符串。这里我们有一个“Mr。Simpson”，一个“Mrus Simpson”，一个“Mr。Brown”，一个“Miss
    Smith”和一个“Mr。T”。有时“Mr”和“.”之间有一个点，有时没有。现在，让我们提取这里的所有不同名字。举个例子，我们的文件中还有一些。举个例子。
- en: we have hellello world。![](img/da8ee5de7a086ab699eec08ed957b1f1_173.png)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有“hellello world”。![](img/da8ee5de7a086ab699eec08ed957b1f1_173.png)
- en: 1，2，3。Date。嗯。And now we only， we want to extract only the names， and we want
    to have the whole name。 So let's build up our pattern here。So let's look for Mr
    first。 So first， we want to look for a Mr。 So M。 And then we have a whitespace。
    So back slash S。 And then we have one or more character。 So word character。 So
    here we use a back slash W。 And then we say plus。 So this， remember。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 1，2，3。日期。嗯。现在我们只想提取名字，并且想要完整的名字。所以让我们在这里构建我们的模式。首先我们查找“Mr”。所以首先，我们想查找一个“Mr”。所以“M”。然后我们有一个空格。所以反斜杠S。然后我们有一个或多个字符。所以单词字符。在这里我们使用反斜杠W。然后我们说加号。所以这个，记住。
- en: this is a quantifier， So one or more。 And then I'm looking for the my string
    here。 and I don't actually write the space here because I have this back slash
    S。 And now if I run this。 then we see that we have one match here。 So this is
    our Mr。 Simpson。 So here we have the M R。 and then a space。 And then。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个量词，表示一个或多个。然后我在这里查找我的字符串。我实际上没有写空格，因为我有这个反斜杠S。现在如果我运行这个，我们可以看到这里有一个匹配项。所以这是我们的“Mr。
    Simpson”。这里我们有“M R”，然后是一个空格。然后。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_175.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_175.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_176.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_176.png)'
- en: 1 or more word characters。 And now， as a next step。 let's also include a Mr
    where we have the dot here。So。We can have the dot。 And now if you just write it
    like this and run it。Then it finds。 sorry。 I have to use back slash dot， of course，
    here， because it's looking for an actual。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 1个或多个单词字符。现在，作为下一步，让我们也包括一个“Mr”，在这里有一个点。所以。我们可以有这个点。现在如果你这样写并运行它。然后它就找到了。抱歉，我必须在这里使用反斜杠点，因为它在寻找一个实际的。
- en: I want to look for the actual dot。![](img/da8ee5de7a086ab699eec08ed957b1f1_178.png)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我想查找实际的点。![](img/da8ee5de7a086ab699eec08ed957b1f1_178.png)
- en: And now it only finds Mr。 Brown and Mr。 T， but not Mr。 Simpson any more。 So
    now， as we just learned。 we have the optional quantifier with a question marks。
    And now let's make our dot optional。 And now if we run this。 Then we have all
    the Mr。![](img/da8ee5de7a086ab699eec08ed957b1f1_180.png)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它只找到“Mr。Brown”和“Mr。T”，而不再找到“Mr。Simpson”。所以现在，正如我们刚刚学习的，我们有一个可选量词，带有问号。现在让我们使点变为可选。现在如果我们运行这个。然后我们有所有的“Mr”。![](img/da8ee5de7a086ab699eec08ed957b1f1_180.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_181.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_181.png)'
- en: And now let's talk about where conditions are useful。 So in this case， we may
    not only have Mrer。 but we may also have a miss or a misses。 So then we can use
    a condition。 So we use parentheses here。 And then we separate them。![](img/da8ee5de7a086ab699eec08ed957b1f1_183.png)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈条件是如何有用的。在这种情况下，我们可能不仅有“Mr”，而且可能还有“miss”或“misses”。所以我们可以使用一个条件。所以我们在这里使用括号。然后我们把它们分开。![](img/da8ee5de7a086ab699eec08ed957b1f1_183.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_184.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_184.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_185.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_185.png)'
- en: So let's have a look at this here。 This meta character is the either or。 So
    now， if we used this。 we can write Mr or miss。![](img/da8ee5de7a086ab699eec08ed957b1f1_187.png)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看这个。这是一个元字符，用于表示“要么...要么...”。所以现在，如果我们使用这个，我们可以写“Mr”或“miss”。![](img/da8ee5de7a086ab699eec08ed957b1f1_187.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_188.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_188.png)'
- en: Or missus。 And then if we run this， then we see it extracted all the names from
    this text。![](img/da8ee5de7a086ab699eec08ed957b1f1_190.png)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 或者“missus”。然后如果我们运行这个，我们可以看到它从文本中提取了所有的名字。![](img/da8ee5de7a086ab699eec08ed957b1f1_190.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_191.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_191.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_192.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_192.png)'
- en: So this is where a condition is useful。And as we have just seen， we grouped
    this condition。Together with the parentheses。 So this is， again， one meta character。And
    now let's talk about grouping a little bit more。 So let's do another example for
    this。 This is also a typical example So let's copy some emails into our text。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是条件有用的地方。正如我们刚才看到的，我们将这个条件与括号分组在一起。这是一个元字符。现在让我们更深入地讨论分组。所以让我们做一个新的例子。这也是一个典型的例子，因此让我们将一些电子邮件复制到我们的文本中。
- en: and let's say we only want to extract the emails from this string here。 So again。
    let's build up our pattern。![](img/da8ee5de7a086ab699eec08ed957b1f1_194.png)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想从这个字符串中提取电子邮件。因此，再次，让我们构建我们的模式。![](img/da8ee5de7a086ab699eec08ed957b1f1_194.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_195.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_195.png)'
- en: So what we can do here is we can use sets to do this。So let's build this up。
    So let's say we want to have some characters here。 So this may be word characters。
    but this may also be a dash and numbers。![](img/da8ee5de7a086ab699eec08ed957b1f1_197.png)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以使用集合来实现。所以让我们构建这个。假设我们想要一些字符。这里可以是字母字符，但也可以是连字符和数字。![](img/da8ee5de7a086ab699eec08ed957b1f1_197.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_198.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_198.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_199.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_199.png)'
- en: So let's use a set here。 and let's use back to back ranges here so we can use
    small a to C or capital a to C。Or also the diitchit 0 to 9。 or we may also have
    a dash here。 So now we are you looking for any of these characters here and we
    want to have multiple of them。 So we say we want to have multiple。 So one or more。
    So this combines this group into one match。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们在这里使用一个集合，并且让我们在这里使用连续的范围，所以我们可以使用小写的a到C或大写的A到C。或者也可以是0到9的数字。或者我们也可以在这里有一个连字符。所以现在我们在寻找这些字符中的任何一个，并且我们希望有多个。我们说我们希望有多个。所以一个或多个。这将这个组合并为一个匹配。
- en: and then it is followed by an at sign。 So now if we compile this and run this。
    then we see that it extracted all these patterns here with any words or numbers
    or dashes and then an at sign。 So this is the name before the email and then。![](img/da8ee5de7a086ab699eec08ed957b1f1_201.png)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它后面跟着一个@符号。所以现在如果我们编译这个并运行它，那么我们看到它提取了所有这些模式，其中包含任何单词或数字或连字符，然后是一个@符号。所以这是电子邮件之前的名称，然后。![](img/da8ee5de7a086ab699eec08ed957b1f1_201.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_202.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_202.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_203.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_203.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_204.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_204.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_205.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_205.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_206.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_206.png)'
- en: Our email can have different domains。 So for example。 we have at Gmail dot com
    at Gm X dot D or at my domain or my dash domain do org。 So we want to extract
    all the different domains。 And the next thing we want to look is to look for only
    for word characters。 So the domain doesn't have a diitchit in it。So the only allowed
    characters are。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的电子邮件可以有不同的域名。例如，我们有在Gmail dot com、Gm X dot D或者我的域名或我的连字符域名do org。因此，我们希望提取所有不同的域名。接下来我们想看的事情是仅寻找字母字符。因此域名中没有连字符。所以唯一允许的字符是。
- en: let's use another set， and here we use again， maybe be a to C， capital A to
    C， and also a dash。 and then we have the dot。So now let's run this。 And， of course，
    there are again， one or more。 So here I have to do a plus。 and then it's looking
    for one or more。So now we see our match also includes the domain name and the
    dot。And then here at the very end。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用另一组，这里我们再次使用，可能是小写的a到C，大写的A到C，以及一个连字符。然后我们有了点。所以现在让我们运行这个。并且，当然，这里可能有一个或多个。所以在这里我必须加一个加号。然后它在寻找一个或多个。所以现在我们看到我们的匹配还包括域名和点。最后在这里。
- en: let's do another set。 So here we say our ending， for example， we can say here
    we have dot。嗯。Sorry。 again， I missed。 I was not looking for an actual dot here。
    So this is a typical mistake that I make。 So now it， for example， it would have
    also found this one here。 but this is not a valid email address。 So I have to
    look for the actual dot by using the back slash。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做另一组。在这里我们说我们的结尾，例如，我们可以说这里有一个点。嗯。抱歉。我又错过了。我没有寻找实际的点。所以这是我犯的一个典型错误。所以现在，例如，它也会找到这个，但这不是有效的电子邮件地址。因此，我必须通过使用反斜杠来寻找实际的点。
- en: And then let's say I'm looking only for dot com， but it can also be dot D or
    dot org。 So。 for example， I can use a group here by using parentheses。 and then
    use the condition here Com or D E or dot org。 So now it would only find these
    endings here and now let's not use a condition。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我只寻找.com结尾，但它也可以是.d或.org。因此，例如，我可以在这里使用一个组，通过使用括号，然后使用条件Com或D或.org。这样它就只会找到这些结尾，现在让我们不使用条件。
- en: but I just wanted to show you the condition here again， but we can also just
    use a set here。 So let's use the set。 and again here we may have。A to C and A
    to C in capital。 And then one or more。And。No ditits here。 So now if you run this，
    then this will extract all the emails for us。 So this is a typical regular expression
    pattern to look for emails。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是想再次向你展示这个条件，但我们也可以在这里使用一个集合。让我们使用这个集合。在这里，我们可能会有大写的A到C。然后是一个或多个。没有数字在这里。如果你运行这个，它将为我们提取所有的电子邮件。这是一个典型的正则表达式模式，用于查找电子邮件。
- en: And this is what I showed you in the beginning。![](img/da8ee5de7a086ab699eec08ed957b1f1_208.png)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我一开始展示给你的。![](img/da8ee5de7a086ab699eec08ed957b1f1_208.png)
- en: So now you understand what this means。 and now let's talk about grouping a little
    bit more。 So there was one case just where I used the condition。 and then I have
    had to use parentheses but we can also explicitly group our match object here
    into different substrs。 So for example， I can put all of these before the a sign
    into a group。 So now let's use parentheses。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你明白这意味着什么了。接下来让我们再谈谈分组。之前我用过一个条件，然后我不得不使用括号，但我们也可以在这里显式地将我们的匹配对象分组到不同的子字符串中。例如，我可以将所有在@符号前面的内容放入一个组。现在让我们使用括号。
- en: and then。![](img/da8ee5de7a086ab699eec08ed957b1f1_210.png)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后。![](img/da8ee5de7a086ab699eec08ed957b1f1_210.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_211.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_211.png)'
- en: Let's use the a sign。 and then let's use the domain name。 So this is one group
    until the dot。 And then we have one group to have the ending year。And now we have
    three groups here。And as I showed you in the beginning， now， if we run this， then
    this will give the same results。 And here we are printing the whole match object。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用@符号。然后让我们使用域名。这是一个组直到点号。然后我们有一个组来获取结尾的年份。现在我们有三个组。正如我一开始所展示的那样，现在，如果我们运行这个，那么这将给出相同的结果。在这里，我们打印整个匹配对象。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_213.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_213.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_214.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_214.png)'
- en: And then we can use the dot group to return the actual string。And this is by
    default。 This is group 0。 So this is the whole match string。 But now we can also
    print the single groups that we just defined。 So we， for example。 we have group
    1，2 and 3 now， and now if we run this and print this， then we see。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用点号组返回实际的字符串。这是默认的。这是组0。因此，这是整个匹配字符串。但现在我们也可以打印我们刚刚定义的单个组。例如，我们现在有组1、2和3，如果我们运行这个并打印它，我们就会看到。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_216.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_216.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_217.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_217.png)'
- en: Let's just print the group one for now here。 Let's comment this out too。 Then
    we see it only prints this group here。 So only the name of the email before the
    Ed sign。 then here， this is the second group。 So now if we print the group 2，
    then this is the domain name。 And if we want to have the ending。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在只打印组1。也让我们注释掉这个。然后我们看到它只打印这个组。因此，只有@符号前面的电子邮件名称，然后这是第二组。如果我们打印组2，这就是域名。如果我们想要结尾。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_219.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_219.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_220.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_220.png)'
- en: Then we can print group 3。 So this is where grouping is useful。 If we only want
    to have a look at specific things in in our match， Then we can use parentheses。
    Now let's move on。 So now let's see we talked about grouping。 Now， let's talk
    about modifications。 So we have two methods to modify a string， So we have the
    split method and we have the sub method。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以打印组3。这就是分组有用的地方。如果我们只想查看匹配中的特定内容，那么我们可以使用括号。现在让我们继续。现在我们谈到了分组，现在让我们谈谈修改。我们有两种方法可以修改字符串，分别是split方法和sub方法。
- en: So let's talk about both of them。 So the split method will split the string
    into a list and splits wherever our regular expression matches。 and the sub method
    will find all substrs where the regular expression matches。 and replaces them
    with a different string。😊。![](img/da8ee5de7a086ab699eec08ed957b1f1_222.png)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们谈谈这两者。分割方法将把字符串分割成一个列表，并在我们的正则表达式匹配的地方进行分割。而sub方法会找到所有匹配正则表达式的子串，并将它们替换为不同的字符串。😊。![](img/da8ee5de7a086ab699eec08ed957b1f1_222.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_223.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_223.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_224.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_224.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_225.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_225.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_226.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_226.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_227.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_227.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_228.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_228.png)'
- en: So let's look at two examples。 So let's say， let me grab a string here， so。![](img/da8ee5de7a086ab699eec08ed957b1f1_230.png)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们来看两个例子。假设让我这里抓一个字符串，好的。![](img/da8ee5de7a086ab699eec08ed957b1f1_230.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_231.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_231.png)'
- en: Let's use this one， again。So this is our test string。 And now we use the pattern
    equals our E dot compile。 And then we are looking for the raw string 1，2。3。![](img/da8ee5de7a086ab699eec08ed957b1f1_233.png)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再用这个。这个是我们的测试字符串。现在我们使用模式等于我们的E点编译。然后我们正在寻找原始字符串1，2，3。![](img/da8ee5de7a086ab699eec08ed957b1f1_233.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_234.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_234.png)'
- en: 嗯。Oh， sorry， let's use a different one。 Do I have it here， No， let's write it
    myself。 So let's say ABC，1，2，3。A，B，C， D， E， F， and capital letters， again，1，2
    3 and ABC。 And now let's say this is our patterns，1，2， and 3。And now we say our
    split it equals。 and then we say pattern dot split and give the test string as
    argument。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯。哦，抱歉，我们换一个。这里有吗？没有，让我自己写。假设我们有ABC，1，2，3。A，B，C，D，E，F，还有大写字母，再来一次，1，2，3和ABC。现在假设这是我们的模式，1，2，和3。然后我们说我们的分割等于。接着我们说模式点分割，并将测试字符串作为参数。
- en: And now let's print the split it。 Now， this will be a list。Where our string
    split it oh， sorry。 this was a bad example。 So let's use ABC as split。 And then
    we have splits where it split it our string into different substrs。 and used this
    pattern here as the split。 So here as the matching split So here it has ABC。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打印分割结果。现在，这将是一个列表。我们的字符串分割了，哦，抱歉。这是一个糟糕的例子。所以我们用ABC作为分割。然后我们有分割结果，它将我们的字符串分割成不同的子串，并将这个模式作为分割使用。所以在这里作为匹配的分割。所以这里有ABC。
- en: So it split our string into this part。 So there we have one to 3 And then this
    part。 And then it found our pattern again， ABC。 And then again， it split the string。
    And then at the end。 we have the rest of the string。 So this is the third substr
    that it found and。And returned with this split method。 So this is the split method。And
    now。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它把我们的字符串分割成了这一部分。我们得到了1到3的部分。然后它又找到了我们的模式ABC。然后又分割了字符串。最后，我们得到了剩下的字符串。这是它找到的第三个子串，并用这个分割方法返回。因此，这就是分割方法。现在。
- en: the sub method with the sub method， we find。All the substrs where our pattern
    matches and then replace them with a different string。 So let's say our testing
    string equals hello world。😊。![](img/da8ee5de7a086ab699eec08ed957b1f1_236.png)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用sub方法，我们找到了所有匹配我们模式的子串，然后用不同的字符串替换它们。假设我们的测试字符串等于hello world。😊。![](img/da8ee5de7a086ab699eec08ed957b1f1_236.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_237.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_237.png)'
- en: And then let's say you are the best world。And use the， so we use the word world
    two times。 And then let's say we want to look for the pattern world。 So we say
    pattern equals our E dot compile。 and then an R raw string。 And here we have world。
    And then we say our spt string equals， and then we use pattern dot sup。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后假设你是世界上最好的。我们使用这个词“世界”两次。然后假设我们想找模式“世界”。所以我们说模式等于我们的E点编译，然后是一个R原始字符串。这里我们有“世界”。然后我们说我们的spt字符串等于，然后我们使用模式点sup。
- en: And then what we want to put in as replacement。 Let's say we want to put in
    planet。And we also have to put in the test string。Now， it took our test string。
    looked for all the matches where pattern matches。 it looked for world and replaced
    them with planet。 So now this will return another string that was modified。 And
    now if we print this。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们想放入替换的内容。假设我们想放入“星球”。我们还需要放入测试字符串。现在，它拿到了我们的测试字符串，查找所有匹配的地方，模式匹配。它查找了“世界”，并将其替换为“星球”。所以现在这将返回一个被修改过的字符串。现在如果我们打印这个。
- en: Then we see it printed Ho planet， you are the best planet。 So this is the sub
    method。 and。😊，Now。 let's do another example to combine all that we have learned。![](img/da8ee5de7a086ab699eec08ed957b1f1_239.png)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看到它打印了 Ho planet，你是最棒的星球。这就是 sub 方法。😊 现在。让我们做另一个例子来结合我们所学的所有内容。![](img/da8ee5de7a086ab699eec08ed957b1f1_239.png)
- en: And again， use the sub method。 And yeah， so let's do this， so。![](img/da8ee5de7a086ab699eec08ed957b1f1_241.png)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 sub 方法。好的，那我们来做这个。![](img/da8ee5de7a086ab699eec08ed957b1f1_241.png)
- en: So let me grab this string here。 So this is our URL string。 So here we have，
    again。 let's say we have different things here。![](img/da8ee5de7a086ab699eec08ed957b1f1_243.png)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我抓取这个字符串。这个是我们的 URL 字符串。这里我们又有不同的东西。![](img/da8ee5de7a086ab699eec08ed957b1f1_243.png)
- en: And then we are only looking for URLs， but they may have different formats。
    So for example。 we have an H TTP URL an H TTPS URL， and then sometimes we have
    a WwW。 and sometimes we don't have this。And then we have the typical domain name，
    and。![](img/da8ee5de7a086ab699eec08ed957b1f1_245.png)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只寻找 URL，但它们可能有不同的格式。例如。我们有一个 H TTP URL，一个 H TTPS URL，然后有时我们有 WwW，有时没有。然后我们有典型的域名，和。![](img/da8ee5de7a086ab699eec08ed957b1f1_245.png)
- en: Ending。![](img/da8ee5de7a086ab699eec08ed957b1f1_247.png)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。![](img/da8ee5de7a086ab699eec08ed957b1f1_247.png)
- en: So， yeah。 So let's extract this。 So let's build up our pattern again So pattern
    equals R E dot compile。 and then a raw string。 So now let's start by saying it
    starts with H T T P。And then a colon and two slashes， and。Then we have W， W， W，
    and then we have a dot。 So an actual dot。And then， we have。1 or more were characters，
    so。For example。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，好的。我们提取这个。我们再次构建我们的模式，模式等于 R E 点 compile，然后是一个原始字符串。现在我们开始说它以 H T T P 开头，然后是一个冒号和两个斜杠，然后我们有
    W，W，W，然后是一个点。一个实际的点。然后，我们有一个或多个字符，所以。例如。
- en: we can use a set here again and use a to C and upper case a to C and also a
    dash here。 So like here。 And so then we have a plus So one or more。And let's put
    this into a group here right away。 So this will return the same thing。 And then
    we can later use this group here。And the next thing。 we again， have a dot。 So
    back slash dot。 And then again。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里再次使用一个 set，使用 a 到 C 和大写 A 到 C 还有一个破折号。就像这里一样。然后我们有一个加号，所以一个或多个。让我们立即将其放入一个组中。这将返回相同的内容。然后我们可以在稍后使用这个组。接下来，我们再次有一个点。所以反斜杠点。然后再次。
- en: we can use a setier a to C and capital a to C。And now let's try this out。 So
    let's say matches equals pattern dot find either。 And then we call this URL。 And
    then for matches in matches， we want to print。![](img/da8ee5de7a086ab699eec08ed957b1f1_249.png)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个 setier 从 a 到 C 和大写的 A 到 C。现在让我们试试这个。假设 matches 等于模式点 find either。然后我们调用这个
    URL。对于 matches 中的每个匹配项，我们想打印。![](img/da8ee5de7a086ab699eec08ed957b1f1_249.png)
- en: The match。 and let's try this and run this。 And then we see we made some mistakes
    here。 And this is because here I have to say plus of course， a one or more and
    now it only found this URL。 because it didn't find this one because we have H
    Ttps here。 and this one doesn't have www。 So the first thing we can do here is
    to use an S。 and this is an optional S。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配。让我们试试并运行它。然后我们看到我们在这里犯了一些错误。这是因为我必须说 plus，当然，一个或多个，现在它只找到了这个 URL。因为它没有找到这个，因为我们这里有
    H Ttps，而这个没有 www。所以我们可以做的第一件事是使用 S，这是一个可选的 S。
- en: So remember S question mark So this is optional then and if we don't put this
    into a group。 then the question mark will only refer to this character here So
    now let's try this out And now we see it also found the H Ttps URL。 and now the
    same thing。![](img/da8ee5de7a086ab699eec08ed957b1f1_251.png)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所以记住 S 问号，这是可选的。如果我们不把它放入一个组中，那么问号只会指代这里的这个字符。现在我们试试这个，现在我们看到它也找到了 H Ttps URL，接下来同样的事情。![](img/da8ee5de7a086ab699eec08ed957b1f1_251.png)
- en: With the Www So this may be there or may not be there。 So again， let's put this
    into a group。And then use an question mark to make this optional。 And now if we
    run this again。 then it still doesn't find it。 And this is because our， it must
    be W W dot。 So back slash dot which must be optional。 And then I don't need it
    here anymore。 So let's run this。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Www 这可能存在也可能不存在。所以再次把它放入一个组中，然后使用问号使其可选。现在如果我们再次运行它，它仍然找不到。这是因为我们必须有 W W
    点。所以反斜杠点也必须是可选的。我不再需要它。现在让我们运行这个。
- en: And then we see that it found all of the URLs and extracted them。 And now let's
    say our string has only the URLls here。 And now let's say we want to return a
    new string where we replaced all of these optional beginnings。 So it should only
    print the actual domain name with the ending。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看到它找到了所有的URL并提取了它们。现在假设我们的字符串只有这些URL。现在假设我们想返回一个新的字符串，其中替换掉所有这些可选前缀。因此，它应该只打印实际的域名及其后缀。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_253.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_253.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_254.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_254.png)'
- en: So as we have learned， we can use the s method。 So we can say instead of just
    finding the matches。 what we want to do here is， let's also print this。 And then
    let's say our spped URL else equals。 and then we use pattern and then sup。 and
    then what we want to put in the replacement here。 So for example， if we just say
    hello， and then U else as a string and then print。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所以正如我们所学，我们可以使用s方法。因此，我们可以说，除了只是找到匹配项。我们在这里想做的是，让我们也打印这个。然后假设我们的spped URL等于。然后我们使用模式，然后sup。然后我们在这里放入替换内容。因此，例如，如果我们只是说hello，然后U等于一个字符串，然后打印。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_256.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_256.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_257.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_257.png)'
- en: The spt URL。 So then we see that this is the new string here。 So it replaced
    all of the matches with hello。 And now， let's say we only want to put this。![](img/da8ee5de7a086ab699eec08ed957b1f1_259.png)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: spt URL。所以我们看到这里是新的字符串。因此，它用hello替换了所有匹配项。现在，假设我们只想放这个。![](img/da8ee5de7a086ab699eec08ed957b1f1_259.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_260.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_260.png)'
- en: In our string and only this， then what we can do here is we can group this，
    and we already did this。![](img/da8ee5de7a086ab699eec08ed957b1f1_262.png)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的字符串中，仅此而已，那么我们在这里可以将其分组，而我们已经这样做过。![](img/da8ee5de7a086ab699eec08ed957b1f1_262.png)
- en: So。We have a group here。 We have a group here。 and let's also put this into
    our group， into a group。![](img/da8ee5de7a086ab699eec08ed957b1f1_264.png)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所以。我们在这里有一个组。我们在这里有一个组。让我们也将这个放入我们的组中，放入一个组。![](img/da8ee5de7a086ab699eec08ed957b1f1_264.png)
- en: And then what we can do is we can use back references to replace them。 So here
    we can say back slash 2 and。We must use a string， So a raw string。And then we
    say back slash 2 and back slash 3。 And now if we run this， then this is our new
    string。 So if I comment this out， then we see then this is our new string。 and
    what happened here， again。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用反向引用来替换它们。因此，这里我们可以说反斜杠2和。我们必须使用一个字符串，所以是一个原始字符串。然后我们说反斜杠2和反斜杠3。现在如果我们运行这个，那么这是我们的新字符串。所以如果我注释掉这个，然后我们看到这是我们的新字符串，发生了什么，重复了一遍。
- en: if we have a look at the group。 So we can say let's print all the different
    group。 So we have matched that group， So this will be the whole。![](img/da8ee5de7a086ab699eec08ed957b1f1_266.png)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下这个组。我们可以说，让我们打印所有不同的组。因此，我们已经匹配了这个组，这将是整体。![](img/da8ee5de7a086ab699eec08ed957b1f1_266.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_267.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_267.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_268.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_268.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_269.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_269.png)'
- en: String。![](img/da8ee5de7a086ab699eec08ed957b1f1_271.png)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串。![](img/da8ee5de7a086ab699eec08ed957b1f1_271.png)
- en: And now so this is group 0 again。 Now， let's have a look at what is group 1。
    So， for example， here。 this is the group1， the first one in parentheses。 And because
    this may be optional。 this may also be none。 So the first URL L has none as the
    first group because it doesn't have W， W。 W。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是组0。现在，让我们看看组1是什么。例如，这里。这是组1，括号中的第一个。而且因为这个可能是可选的。这也可能是无。因此，第一个URL的第一个组没有，因为它没有WWW。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_273.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_273.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_274.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_274.png)'
- en: And this is the first group。 So now let's print the second group。 So this is
    the actual name of the domains at the beginning。 And then the group 3 is the endings
    So dot com dot com dot net。 And now here we use this group2 and group 3 with this
    back reference。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个组。所以现在让我们打印第二个组。这是域名开头的实际名称。然后组3是后缀，如dot com、dot com、dot net。现在我们使用这个group2和group3与这个反向引用。
- en: And then replace the whole found pattern only with the domain name。 So this
    is what happens here。 And so this is also very often used in regular expressions。
    And now you know what this means。![](img/da8ee5de7a086ab699eec08ed957b1f1_276.png)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将整个找到的模式替换为域名。这就是这里发生的事情。因此，这在正则表达式中也非常常用。现在你知道这意味着什么。![](img/da8ee5de7a086ab699eec08ed957b1f1_276.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_277.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_277.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_278.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_278.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_279.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_279.png)'
- en: And I guess， now we are almost。![](img/da8ee5de7a086ab699eec08ed957b1f1_281.png)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我想现在我们差不多了。![](img/da8ee5de7a086ab699eec08ed957b1f1_281.png)
- en: Through with all the context， all the。![](img/da8ee5de7a086ab699eec08ed957b1f1_283.png)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有上下文，所有的。![](img/da8ee5de7a086ab699eec08ed957b1f1_283.png)
- en: Things that I wanted to show you。 And now， as a last thing。 let's quickly talk
    about compilation flags。 So when we compile the pattern。 Then we also have the
    option to use different compilation flags。 So here I listed them。 And again。 you
    don't have to remember them。 Just keep a cheat sheet。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我想给你展示的事情。最后，让我们快速谈谈编译标志。所以当我们编译模式时。我们也有选择使用不同的编译标志。因此我在这里列出了它们。再次强调。你不需要记住它们。只需保持一个备忘单。
- en: So here we have the different compilation flag。 So askki dot all， ignore case。
    local multi line or verse。![](img/da8ee5de7a086ab699eec08ed957b1f1_285.png)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有不同的编译标志。所以问ki点全，忽略大小写。局部多行或诗句。![](img/da8ee5de7a086ab699eec08ed957b1f1_285.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_286.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_286.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_287.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_287.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_288.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_288.png)'
- en: So I recommend that you check out the official documentation to see what all
    of them mean in detail。 And now I。I just want to show you the ignore case compilation
    flex。 So this is also a very common use case。 So let's say we have the string。
    my string equals hello world。 And then we want to look for the string world。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我建议你查看官方文档，以详细了解它们的含义。现在我。我只是想给你展示忽略大小写的编译标志。这也是一个非常常见的用例。假设我们有字符串。我的字符串等于hello
    world。然后我们想查找字符串world。
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_290.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_290.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_291.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_291.png)'
- en: And now， if we compile this and then try to find the matches and print them。
    So print the match。 Now。 if we run this， sorry， this is called my string。 now
    if we run this。 then it doesn't find a string。 So because remember this is case
    sensitive。 Now if we make a capital W。 then it finds the match world。 And let's
    say we don't know what our string is。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们编译这个，然后尝试找到匹配并打印它们。那么打印匹配。现在。如果我们运行这个，抱歉，这叫做我的字符串。现在如果我们运行这个。然后它找不到字符串。因为记住这是区分大小写的。现在如果我们把W大写。那么它找到匹配的world。假设我们不知道我们的字符串是什么。
- en: So it may be upper case， but it may not be upper K。 So it doesn't matter for
    us for us。 then we can just use the compilation fl R E dot ignore case。 so we
    can write this out so we can say ignore case。![](img/da8ee5de7a086ab699eec08ed957b1f1_293.png)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它可能是大写，但可能不是大K。这对我们来说并不重要。然后我们可以使用编译fl R E点忽略大小写。所以我们可以写出这个，所以我们可以说忽略大小写。![](img/da8ee5de7a086ab699eec08ed957b1f1_293.png)
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_294.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_294.png)'
- en: Or we can just say R R E dot I。And then if we use a small W， then it will still
    find the match。 And because now it ignored the cases。 So this is the ignore case
    compilation flag。 And now， yeah。 you also have。![](img/da8ee5de7a086ab699eec08ed957b1f1_296.png)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以简单地说R R E点I。然后如果我们使用小写W，它仍然会找到匹配项。因为现在它忽略了大小写。这就是忽略大小写的编译标志。现在，是的。你还有。![](img/da8ee5de7a086ab699eec08ed957b1f1_296.png)
- en: In these compilation flags。 So I recommend that you check them out for yourself。
    I will provide a link to the official documentation in the description。 And now
    I think we are done。 and now you should be able to understand all the different
    regular expressions。😊。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些编译标志中。所以我建议你自己查看一下。我将在描述中提供官方文档的链接。现在我想我们完成了。现在你应该能够理解所有不同的正则表达式。😊
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_298.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_298.png)'
- en: '![](img/da8ee5de7a086ab699eec08ed957b1f1_299.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ee5de7a086ab699eec08ed957b1f1_299.png)'
- en: I hope it wasn't too complicated for you。 and I hope you enjoyed this tutorial。
    If you like this。 then please consider subscribing to the channel and leave me
    a like and see you next time， bye。![](img/da8ee5de7a086ab699eec08ed957b1f1_301.png)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这对你来说不是太复杂。并且我希望你喜欢这个教程。如果你喜欢这个，请考虑订阅频道并给我点赞，我们下次见，拜拜！![](img/da8ee5de7a086ab699eec08ed957b1f1_301.png)
