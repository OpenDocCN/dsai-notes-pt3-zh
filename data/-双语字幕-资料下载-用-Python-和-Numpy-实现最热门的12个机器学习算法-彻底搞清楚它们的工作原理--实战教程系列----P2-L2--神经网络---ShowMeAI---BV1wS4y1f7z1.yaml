- en: ã€åŒè¯­å­—å¹•+èµ„æ–™ä¸‹è½½ã€‘ç”¨ Python å’Œ Numpy å®ç°æœ€çƒ­é—¨çš„12ä¸ªæœºå™¨å­¦ä¹ ç®—æ³•ï¼Œå½»åº•ææ¸…æ¥šå®ƒä»¬çš„å·¥ä½œåŸç†ï¼ï¼œå®æˆ˜æ•™ç¨‹ç³»åˆ—ï¼ - P2ï¼šL2- ç¥ç»ç½‘ç»œ
    - ShowMeAI - BV1wS4y1f7z1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ã€åŒè¯­å­—å¹•+èµ„æ–™ä¸‹è½½ã€‘ç”¨ Python å’Œ Numpy å®ç°æœ€çƒ­é—¨çš„12ä¸ªæœºå™¨å­¦ä¹ ç®—æ³•ï¼Œå½»åº•ææ¸…æ¥šå®ƒä»¬çš„å·¥ä½œåŸç†ï¼ï¼œå®æˆ˜æ•™ç¨‹ç³»åˆ—ï¼ - P2ï¼šL2- ç¥ç»ç½‘ç»œ
    - ShowMeAI - BV1wS4y1f7z1
- en: Hiï¼Œ everybodyã€‚ Welcome to a new tutorialã€‚ This is the first video of a new series
    called machine learning from scratchã€‚ In this seriesï¼Œ we are going to implement
    popular machine learning algorithms using only built in Python modules and Nyã€‚
    So todayï¼Œ we will start with the key nearest neighbor algorithm or short K and
    N algorithmã€‚ğŸ˜Šã€‚The concept of K And N is fairly easyã€‚ A sample is classified by
    a popularity vote of its nearest neighborsã€‚
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: å—¨ï¼Œå¤§å®¶å¥½ã€‚æ¬¢è¿æ¥åˆ°ä¸€ä¸ªæ–°çš„æ•™ç¨‹ã€‚è¿™æ˜¯ä¸€ä¸ªåä¸ºâ€œä»é›¶å¼€å§‹å­¦ä¹ æœºå™¨å­¦ä¹ â€çš„æ–°ç³»åˆ—çš„ç¬¬ä¸€æœŸè§†é¢‘ã€‚åœ¨è¿™ä¸ªç³»åˆ—ä¸­ï¼Œæˆ‘ä»¬å°†ä»…ä½¿ç”¨å†…ç½®çš„ Python æ¨¡å—å’Œ Numpy
    å®ç°æµè¡Œçš„æœºå™¨å­¦ä¹ ç®—æ³•ã€‚æ‰€ä»¥ä»Šå¤©ï¼Œæˆ‘ä»¬å°†ä»å…³é”®çš„æœ€è¿‘é‚»ç®—æ³•å¼€å§‹ï¼Œç®€ç§° K-N ç®—æ³•ã€‚ğŸ˜Š K-N çš„æ¦‚å¿µéå¸¸ç®€å•ã€‚ä¸€ä¸ªæ ·æœ¬é€šè¿‡å…¶æœ€è¿‘é‚»çš„æŠ•ç¥¨æ¥è¿›è¡Œåˆ†ç±»ã€‚
- en: So let's consider an example with two classes and a two dimensional feature
    vectorã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_1.png)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥æˆ‘ä»¬æ¥è€ƒè™‘ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªç±»åˆ«å’Œä¸€ä¸ªäºŒç»´ç‰¹å¾å‘é‡çš„ä¾‹å­ã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_1.png)
- en: So let's have a look at this figureã€‚ So here we have two classesã€‚ the blue class
    and the orange classï¼Œ and we have feature vectors with two dimensionsã€‚ So we have
    x1 on this axis and x 2 on this axisã€‚And what we do here is we have some training
    samplesã€‚And then for each new sample that we want to classifyã€‚
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è®©æˆ‘ä»¬çœ‹çœ‹è¿™ä¸ªå›¾ã€‚è¿™é‡Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªç±»åˆ«ï¼Œè“è‰²ç±»åˆ«å’Œæ©™è‰²ç±»åˆ«ï¼Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªç»´åº¦çš„ç‰¹å¾å‘é‡ã€‚æ‰€ä»¥åœ¨è¿™ä¸ªè½´ä¸Šæ˜¯ x1ï¼Œåœ¨è¿™ä¸ªè½´ä¸Šæ˜¯ x2ã€‚æˆ‘ä»¬è¿™é‡Œæœ‰ä¸€äº›è®­ç»ƒæ ·æœ¬ã€‚ç„¶åå¯¹äºæ¯ä¸ªæˆ‘ä»¬æƒ³è¦åˆ†ç±»çš„æ–°æ ·æœ¬ã€‚
- en: we calculate the distance of this sample to each of the training samplesã€‚ And
    then we have a look at the nearest neighborsã€‚ So in this caseã€‚ we have a look
    at the three nearest neighborsã€‚ So these onesã€‚ And then we choose or predict the
    label based on the most commonã€‚Class labels hereã€‚
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è®¡ç®—è¿™ä¸ªæ ·æœ¬åˆ°æ¯ä¸ªè®­ç»ƒæ ·æœ¬çš„è·ç¦»ã€‚ç„¶åæˆ‘ä»¬æŸ¥çœ‹æœ€è¿‘çš„é‚»å±…ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æŸ¥çœ‹ä¸‰ä¸ªæœ€è¿‘çš„é‚»å±…ã€‚å°±æ˜¯è¿™äº›ã€‚ç„¶åæˆ‘ä»¬æ ¹æ®æœ€å¸¸è§çš„ç±»åˆ«æ ‡ç­¾æ¥é€‰æ‹©æˆ–é¢„æµ‹æ ‡ç­¾ã€‚
- en: So we have two blue glasses and one orange glassã€‚ So this then will be a blue
    classã€‚And this is the whole concept of the K and Nã€‚And what we also have to know
    is in order to calculate the distancesã€‚We used the Euclidean distanceã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_3.png)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥æˆ‘ä»¬æœ‰ä¸¤ä¸ªè“è‰²çš„ç±»åˆ«å’Œä¸€ä¸ªæ©™è‰²çš„ç±»åˆ«ã€‚æ‰€ä»¥è¿™å°†æ˜¯ä¸€ä¸ªè“è‰²ç±»åˆ«ã€‚è¿™å°±æ˜¯ K-N çš„æ•´ä¸ªæ¦‚å¿µã€‚æˆ‘ä»¬è¿˜éœ€è¦çŸ¥é“çš„æ˜¯ï¼Œä¸ºäº†è®¡ç®—è·ç¦»ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_3.png)
- en: So in a 2D exampleï¼Œ the Euclidean distance of two points is defined as the square
    root overã€‚ and then we have for eachã€‚ğŸ¤¢ï¼ŒFeature vector componentã€‚ we have the squaredã€‚Differenceã€‚
    so we have x 2 minus x1 squared plus y2 minus y1 squaredã€‚ So this is the Euclidean
    distance in a 2D caseã€‚ and in a more general caseï¼Œ the formulaã€‚
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨äºŒç»´ç¤ºä¾‹ä¸­ï¼Œä¸¤ä¸ªç‚¹çš„æ¬§å‡ é‡Œå¾—è·ç¦»å®šä¹‰ä¸ºå¹³æ–¹æ ¹ï¼Œç„¶åæˆ‘ä»¬å¯¹æ¯ä¸ªç‰¹å¾å‘é‡ç»„ä»¶è®¡ç®—å¹³æ–¹å·®ã€‚æ‰€ä»¥æˆ‘ä»¬æœ‰ x2 å‡å» x1 çš„å¹³æ–¹åŠ ä¸Š y2 å‡å» y1 çš„å¹³æ–¹ã€‚æ‰€ä»¥è¿™æ˜¯äºŒç»´æƒ…å†µä¸‹çš„æ¬§å‡ é‡Œå¾—è·ç¦»ï¼Œè€Œåœ¨æ›´ä¸€èˆ¬çš„æƒ…å†µä¸‹ï¼Œå…¬å¼æ˜¯ã€‚
- en: '![](img/46ae3dd4f47308ef10799ea81647c68c_5.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ae3dd4f47308ef10799ea81647c68c_5.png)'
- en: '![](img/46ae3dd4f47308ef10799ea81647c68c_6.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ae3dd4f47308ef10799ea81647c68c_6.png)'
- en: Is defined asã€‚Thisï¼Œ so it's the square root over the sum from I equals 0 to
    nã€‚ where n is the number of dimensionsã€‚ And then we have the sum overã€‚Eachã€‚Componentã€‚
    and for each componentï¼Œ we calculate the squared distance or the square differenceã€‚So
    this is the Euclidean distanceï¼Œ and this is all we have to know in order to implement
    the K and Nã€‚
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å®šä¹‰ä¸ºã€‚è¿™ä¸ªï¼Œæ‰€ä»¥å®ƒæ˜¯ä» I ç­‰äº 0 åˆ° n çš„æ€»å’Œçš„å¹³æ–¹æ ¹ï¼Œå…¶ä¸­ n æ˜¯ç»´åº¦çš„æ•°é‡ã€‚ç„¶åæˆ‘ä»¬å¯¹æ¯ä¸ªç»„ä»¶è¿›è¡Œæ±‚å’Œï¼Œå¯¹äºæ¯ä¸ªç»„ä»¶ï¼Œæˆ‘ä»¬è®¡ç®—å¹³æ–¹è·ç¦»æˆ–å¹³æ–¹å·®ã€‚æ‰€ä»¥è¿™æ˜¯æ¬§å‡ é‡Œå¾—è·ç¦»ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬åœ¨å®ç°
    K-N æ—¶éœ€è¦çŸ¥é“çš„ä¸€åˆ‡ã€‚
- en: So let's startã€‚ And firstï¼Œ let's define a class called K and Nã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_8.png)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è®©æˆ‘ä»¬å¼€å§‹ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªåä¸º K-N çš„ç±»ã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_8.png)
- en: And this hasï¼Œ of courseï¼Œ an innate methodã€‚So in itselfï¼Œ and this will get a
    Kã€‚ So this is the number of nearest neighbors we want to considerã€‚ And this will
    also get a default valueã€‚ So the default is 3ã€‚And in the in itã€‚Ohï¼Œ sorryã€‚We define
    the in itã€‚ So in the inï¼Œ we simply want to store the Kã€‚ So we say self dot K equals
    kã€‚
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ç„¶ï¼Œè¿™æœ‰ä¸€ä¸ªåˆå§‹åŒ–æ–¹æ³•ã€‚æ‰€ä»¥æˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ª Kã€‚è¿™æ˜¯æˆ‘ä»¬æƒ³è¦è€ƒè™‘çš„æœ€è¿‘é‚»çš„æ•°é‡ã€‚å¹¶ä¸”è¿™è¿˜ä¼šæœ‰ä¸€ä¸ªé»˜è®¤å€¼ã€‚æ‰€ä»¥é»˜è®¤æ˜¯ 3ã€‚åœ¨åˆå§‹åŒ–ä¸­ã€‚å“¦ï¼ŒæŠ±æ­‰ã€‚æˆ‘ä»¬å®šä¹‰åˆå§‹åŒ–ã€‚æ‰€ä»¥åœ¨åˆå§‹åŒ–ä¸­ï¼Œæˆ‘ä»¬åªæ˜¯æƒ³å­˜å‚¨
    Kã€‚æ‰€ä»¥æˆ‘ä»¬è¯´ self.dot K ç­‰äº kã€‚
- en: And then what we want to implement hereã€‚ And here we want to follow the conventions
    of other machine learning librariesã€‚ For exampleï¼Œ the psychic Learn libraryã€‚ So
    we have aã€‚å—¯ã€‚Fit methodã€‚So thisã€‚ this will fit the traininging samples and someã€‚Training
    labelsã€‚ And this will usually involve a the training stepã€‚ So we want to implement
    this oneã€‚
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬æƒ³åœ¨è¿™é‡Œå®ç°çš„å°±æ˜¯éµå¾ªå…¶ä»–æœºå™¨å­¦ä¹ åº“çš„çº¦å®šã€‚ä¾‹å¦‚ï¼Œå¿ƒç†å­¦ä¹ åº“ã€‚å› æ­¤æˆ‘ä»¬æœ‰ä¸€ä¸ªã€‚å—¯ã€‚æ‹Ÿåˆæ–¹æ³•ã€‚è¿™å°†æ‹Ÿåˆè®­ç»ƒæ ·æœ¬å’Œä¸€äº›è®­ç»ƒæ ‡ç­¾ã€‚é€šå¸¸è¿™å°†æ¶‰åŠåˆ°è®­ç»ƒæ­¥éª¤ã€‚æ‰€ä»¥æˆ‘ä»¬æƒ³è¦å®ç°è¿™ä¸ªã€‚
- en: And then we also want to implement a predict methodã€‚Sorryï¼Œ this also has selfã€‚And
    the predict methodã€‚ So here we want to predict new samplesã€‚So these are the methods
    we want to implementã€‚And nowï¼Œ before we go onï¼Œ first of allã€‚ let's have a look
    at how our data looksã€‚ So what is this X and this Yï¼Œ And for thisã€‚
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬è¿˜æƒ³å®ç°ä¸€ä¸ªé¢„æµ‹æ–¹æ³•ã€‚æŠ±æ­‰ï¼Œè¿™é‡Œä¹Ÿæœ‰selfã€‚ä»¥åŠé¢„æµ‹æ–¹æ³•ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æƒ³è¦é¢„æµ‹æ–°æ ·æœ¬ã€‚è¿™æ˜¯æˆ‘ä»¬æƒ³è¦å®ç°çš„æ–¹æ³•ã€‚åœ¨ç»§ç»­ä¹‹å‰ï¼Œé¦–å…ˆè®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬çš„æ•°æ®çš„æ ·å­ã€‚è¿™Xå’ŒYæ˜¯ä»€ä¹ˆï¼Ÿ
- en: I wrote some test scriptã€‚ So here I used the famous irris data setsã€‚ So you
    might have heard about this alreadyã€‚ So I can get this from the ps could learn
    moduleã€‚ And then I will generate some training samples and some test samplesã€‚
    and the associated training labels and test labelsã€‚
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å†™äº†ä¸€äº›æµ‹è¯•è„šæœ¬ã€‚åœ¨è¿™é‡Œæˆ‘ä½¿ç”¨äº†è‘—åçš„é¸¢å°¾èŠ±æ•°æ®é›†ã€‚ä½ å¯èƒ½å¬è¯´è¿‡è¿™ä¸ªã€‚æ‰€ä»¥æˆ‘å¯ä»¥ä»å¿ƒç†å­¦ä¹ æ¨¡å—ä¸­è·å–è¿™ä¸ªæ•°æ®ã€‚ç„¶åæˆ‘å°†ç”Ÿæˆä¸€äº›è®­ç»ƒæ ·æœ¬å’Œä¸€äº›æµ‹è¯•æ ·æœ¬ï¼Œä»¥åŠç›¸å…³çš„è®­ç»ƒæ ‡ç­¾å’Œæµ‹è¯•æ ‡ç­¾ã€‚
- en: '![](img/46ae3dd4f47308ef10799ea81647c68c_10.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ae3dd4f47308ef10799ea81647c68c_10.png)'
- en: '![](img/46ae3dd4f47308ef10799ea81647c68c_11.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ae3dd4f47308ef10799ea81647c68c_11.png)'
- en: So let's first have a look at how thisã€‚Training samplesã€‚ lookã€‚ so we want to
    print the shape of this oneã€‚So this is an an nuy N D array of shapeï¼Œ120 by 4ã€‚
    So 120 is the number of samplesã€‚ and four is the number of features for each sampleã€‚
    So for exampleã€‚ let's print the first sampleã€‚So this is four features in itã€‚
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆè®©æˆ‘ä»¬çœ‹çœ‹è¿™äº›è®­ç»ƒæ ·æœ¬çš„æ ·å­ã€‚æˆ‘ä»¬æƒ³æ‰“å°ä¸€ä¸‹å®ƒçš„å½¢çŠ¶ã€‚è¿™æ˜¯ä¸€ä¸ªå½¢çŠ¶ä¸º120 x 4çš„nç»´æ•°ç»„ã€‚æ‰€ä»¥120æ˜¯æ ·æœ¬çš„æ•°é‡ï¼Œè€Œ4æ˜¯æ¯ä¸ªæ ·æœ¬çš„ç‰¹å¾æ•°é‡ã€‚ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬æ‰“å°ç¬¬ä¸€ä¸ªæ ·æœ¬ã€‚å®ƒåŒ…å«å››ä¸ªç‰¹å¾ã€‚
- en: So this is how our training samples lookã€‚ And now let's have a look at our training
    labelsã€‚Soã€‚This is a 1 D row vectorï¼Œ also of size 120ã€‚ So for each of our training
    samplesï¼Œ we have theã€‚The label for itã€‚So if we print thisï¼Œ then we see this will
    be a 1 D vector with only one rowã€‚
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è¿™å°±æ˜¯æˆ‘ä»¬çš„è®­ç»ƒæ ·æœ¬çš„æ ·å­ã€‚ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬çš„è®­ç»ƒæ ‡ç­¾ã€‚è¿™æ˜¯ä¸€ä¸ªä¸€ç»´è¡Œå‘é‡ï¼Œå¤§å°ä¹Ÿæ˜¯120ã€‚å› æ­¤ï¼Œå¯¹äºæ¯ä¸ªè®­ç»ƒæ ·æœ¬ï¼Œæˆ‘ä»¬éƒ½æœ‰å¯¹åº”çš„æ ‡ç­¾ã€‚å¦‚æœæˆ‘ä»¬æ‰“å°å‡ºæ¥ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°è¿™æ˜¯ä¸€ä¸ªåªæœ‰ä¸€è¡Œçš„ä¸€ç»´å‘é‡ã€‚
- en: '![](img/46ae3dd4f47308ef10799ea81647c68c_13.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ae3dd4f47308ef10799ea81647c68c_13.png)'
- en: And now let's what we see here is we have label 0ï¼Œ1 and 2ã€‚ So this is a three
    class problemã€‚ So let's also plot thisã€‚å—¯ã€‚And nowï¼Œ for exampleï¼Œ what I plot here
    is I only plot the first twoã€‚Feature us so that we have a 2D caseã€‚So this is how
    our data looksã€‚ So we have three classesï¼Œ redã€‚ green and blue andã€‚
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬çœ‹åˆ°çš„æ ‡ç­¾æœ‰0ã€1å’Œ2ã€‚è¿™æ˜¯ä¸€ä¸ªä¸‰åˆ†ç±»é—®é¢˜ã€‚æˆ‘ä»¬ä¹Ÿæ¥ç»˜åˆ¶ä¸€ä¸‹ã€‚å—¯ã€‚æ¯”å¦‚è¯´ï¼Œæˆ‘è¿™é‡Œç»˜åˆ¶çš„æ˜¯å‰ä¸¤ä¸ªç‰¹å¾ï¼Œä»¥ä¾¿æˆ‘ä»¬æœ‰ä¸€ä¸ªäºŒç»´çš„æƒ…å†µã€‚è¿™å°±æ˜¯æˆ‘ä»¬çš„æ•°æ®çš„æ ·å­ã€‚æˆ‘ä»¬æœ‰ä¸‰ä¸ªç±»åˆ«ï¼Œçº¢è‰²ã€ç»¿è‰²å’Œè“è‰²ã€‚
- en: '![](img/46ae3dd4f47308ef10799ea81647c68c_15.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ae3dd4f47308ef10799ea81647c68c_15.png)'
- en: '![](img/46ae3dd4f47308ef10799ea81647c68c_16.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ae3dd4f47308ef10799ea81647c68c_16.png)'
- en: Yeahã€‚So this is how our data looksã€‚ And now we can continue by implementing
    thisã€‚ So in our fit methodã€‚So in the K and N algorithmï¼Œ this doesn't involve a
    training stepã€‚ So what we do here is we simply want to store our training samples
    and then we can use them laterã€‚ so we can sayï¼Œ let's store themã€‚ So let's say
    selfã€‚
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æ˜¯çš„ã€‚è¿™å°±æ˜¯æˆ‘ä»¬çš„æ•°æ®çš„æ ·å­ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥é€šè¿‡å®ç°è¿™ä¸€ç‚¹ç»§ç»­ã€‚æ‰€ä»¥åœ¨æˆ‘ä»¬çš„æ‹Ÿåˆæ–¹æ³•ä¸­ã€‚åœ¨Kå’ŒNç®—æ³•ä¸­ï¼Œè¿™å¹¶ä¸æ¶‰åŠè®­ç»ƒæ­¥éª¤ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œæ‰€åšçš„å°±æ˜¯ç®€å•åœ°å­˜å‚¨æˆ‘ä»¬çš„è®­ç»ƒæ ·æœ¬ï¼Œç„¶åæˆ‘ä»¬å¯ä»¥ç¨åä½¿ç”¨å®ƒä»¬ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´ï¼Œå­˜å‚¨å®ƒä»¬ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥è¯´selfã€‚
- en: and then we call this X train equals X and self Y trainã€‚Equals yã€‚So this is
    all for our fit methodã€‚And nowï¼Œ for our predict methodã€‚Soï¼Œ this will getã€‚Can get
    multiple samples hereï¼Œ So weã€‚å—¯ã€‚Can see thisï¼Œ because weï¼Œ we use a capital x for
    thisã€‚So this can have multiple samplesã€‚ so we can write a little helper methodã€‚
    So we want to do this for each of the samplesã€‚
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬å°†X trainè®¾ä¸ºXï¼Œè€Œself Y trainè®¾ä¸ºyã€‚è¿™å°±æ˜¯æˆ‘ä»¬çš„æ‹Ÿåˆæ–¹æ³•çš„å…¨éƒ¨ã€‚ç°åœ¨ï¼Œå¯¹äºæˆ‘ä»¬çš„é¢„æµ‹æ–¹æ³•ï¼Œè¿™å°†è·å–å¤šä¸ªæ ·æœ¬ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨äº†å¤§å†™çš„Xã€‚è¿™æ ·å¯ä»¥æœ‰å¤šä¸ªæ ·æœ¬ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªå°çš„è¾…åŠ©æ–¹æ³•ã€‚æˆ‘ä»¬æƒ³å¯¹æ¯ä¸ªæ ·æœ¬æ‰§è¡Œè¿™ä¸ªã€‚
- en: We want to say we want to get the predictedã€‚Labelsã€‚Equalsï¼Œ and thenã€‚We useã€‚Or
    we write a helper method that we call underscore predictã€‚ And this will only get
    one sampleã€‚So here we use list comprehensionã€‚ So what we want to do then is we
    want to call this selfã€‚Predictã€‚With one sample Xã€‚ And then we want to do this
    for all of our samplesã€‚In ourã€‚Tests samples hereã€‚
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 'æˆ‘ä»¬æƒ³è¯´æˆ‘ä»¬æƒ³è¦è·å–é¢„æµ‹çš„æ ‡ç­¾ã€‚ç­‰äºï¼Œç„¶åã€‚æˆ‘ä»¬ä½¿ç”¨ã€‚æˆ–è€…æˆ‘ä»¬å†™ä¸€ä¸ªå¸®åŠ©æ–¹æ³•ï¼Œç§°ä¹‹ä¸ºä¸‹åˆ’çº¿é¢„æµ‹ã€‚è¿™ä¸ªæ–¹æ³•åªä¼šå¤„ç†ä¸€ä¸ªæ ·æœ¬ã€‚æ‰€ä»¥åœ¨è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨åˆ—è¡¨æ¨å¯¼ã€‚ç„¶åæˆ‘ä»¬æƒ³åšçš„æ˜¯è°ƒç”¨è¿™ä¸ª
    selfã€‚é¢„æµ‹ã€‚ä½¿ç”¨ä¸€ä¸ªæ ·æœ¬ Xã€‚ç„¶åæˆ‘ä»¬æƒ³å¯¹æˆ‘ä»¬æ‰€æœ‰çš„æ ·æœ¬è¿›è¡Œè¿™ä¸ªæ“ä½œã€‚åœ¨æˆ‘ä»¬çš„æµ‹è¯•æ ·æœ¬ä¸­ã€‚ '
- en: So for small x in capital xã€‚And then this will be a listã€‚ So let's convert this
    to a nuy arrayï¼Œ andã€‚Thenã€‚This is our predict methodã€‚ Andï¼Œ of courseï¼Œ we have to
    import Nmpyã€‚ So we say import Ny S and Pã€‚And nowï¼Œ how does our underscore predict
    method look likeï¼Œ So now againã€‚Let's have a lookã€‚
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥å¯¹äºå¤§å†™çš„ x ä¸­çš„å° xã€‚ç„¶åè¿™å°†æ˜¯ä¸€ä¸ªåˆ—è¡¨ã€‚è®©æˆ‘ä»¬æŠŠå®ƒè½¬æ¢ä¸ºä¸€ä¸ª nuy æ•°ç»„ï¼Œç„¶åã€‚è¿™æ˜¯æˆ‘ä»¬çš„é¢„æµ‹æ–¹æ³•ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬éœ€è¦å¯¼å…¥ Nmpyã€‚æ‰€ä»¥æˆ‘ä»¬è¯´å¯¼å…¥
    Ny S å’Œ Pã€‚ç°åœ¨ï¼Œæˆ‘ä»¬çš„ä¸‹åˆ’çº¿é¢„æµ‹æ–¹æ³•çœ‹èµ·æ¥å¦‚ä½•ï¼Ÿå†æ¥çœ‹çœ‹ã€‚
- en: '![](img/46ae3dd4f47308ef10799ea81647c68c_18.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ae3dd4f47308ef10799ea81647c68c_18.png)'
- en: At the figure hereã€‚ So what we do isã€‚We want to calculate all the distancesã€‚And
    then we have a look at the nearest neighbours and the labels of the nearest neighborsã€‚
    And then we do a maturity vote and choose the most common class labelã€‚ So let's
    write some comments hereã€‚ Soï¼Œ first of allï¼Œ we want to compute the distancesã€‚
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œçš„å›¾ä¸­ã€‚æ‰€ä»¥æˆ‘ä»¬è¦åšçš„æ˜¯ã€‚æˆ‘ä»¬æƒ³è®¡ç®—æ‰€æœ‰çš„è·ç¦»ã€‚ç„¶åæŸ¥çœ‹æœ€è¿‘é‚»å±…å’Œæœ€è¿‘é‚»å±…çš„æ ‡ç­¾ã€‚ç„¶åæˆ‘ä»¬è¿›è¡ŒæŠ•ç¥¨ï¼Œé€‰æ‹©æœ€å¸¸è§çš„ç±»æ ‡ç­¾ã€‚è®©æˆ‘ä»¬åœ¨è¿™é‡Œå†™ä¸€äº›æ³¨é‡Šã€‚é¦–å…ˆï¼Œæˆ‘ä»¬æƒ³è®¡ç®—è·ç¦»ã€‚
- en: '![](img/46ae3dd4f47308ef10799ea81647c68c_20.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ae3dd4f47308ef10799ea81647c68c_20.png)'
- en: Thenï¼Œ we want toã€‚Get the can nearest neighborsï¼Œ So get Caã€‚Nearest samplesï¼Œ andã€‚We
    want to get theã€‚Alsoï¼Œ want to get the labelsã€‚ And then we do a maturity modeã€‚So
    we want to get the mostã€‚Come on class labelã€‚Soã€‚Let's do thisã€‚ So let's sayï¼Œ distances
    equalsã€‚And nowï¼Œ as I saidã€‚ we use the Euclidean distance hereã€‚ So let's define
    thisã€‚
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬æƒ³è¦è·å–æœ€è¿‘çš„é‚»å±…ï¼Œæ‰€ä»¥è·å– Caã€‚æœ€è¿‘çš„æ ·æœ¬ï¼Œå¹¶ä¸”ã€‚æˆ‘ä»¬ä¹Ÿæƒ³è¦è·å–æ ‡ç­¾ã€‚ç„¶åæˆ‘ä»¬è¿›è¡ŒæŠ•ç¥¨ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æƒ³è¦å¾—åˆ°æœ€å¤šçš„ã€‚æ¥è‡ªç±»æ ‡ç­¾ã€‚æ‰€ä»¥ã€‚è®©æˆ‘ä»¬è¿™æ ·åšã€‚è®©æˆ‘ä»¬è¯´ï¼Œè·ç¦»ç­‰äºã€‚æ­£å¦‚æˆ‘æ‰€è¯´ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚è®©æˆ‘ä»¬å®šä¹‰ä¸€ä¸‹ã€‚
- en: and we want to define this as a global functionã€‚ So you might want to write
    this in a separate file or call this in some utility classã€‚ So here I will simply
    do it in the same fileã€‚ So I sayã€‚è¦ã€‚Kiyianã€‚This tenseã€‚Of two feature vectorsã€‚ So
    let's say x1 and x 2ã€‚ And now againï¼Œ let's have a look at the formulaã€‚ So this
    is the square rootã€‚ and then the sum over each square distanceã€‚ So we have the
    square rootã€‚
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¸Œæœ›å°†å…¶å®šä¹‰ä¸ºä¸€ä¸ªå…¨å±€å‡½æ•°ã€‚å› æ­¤ï¼Œä½ å¯èƒ½æƒ³æŠŠå®ƒå†™åœ¨ä¸€ä¸ªå•ç‹¬çš„æ–‡ä»¶ä¸­ï¼Œæˆ–è€…åœ¨æŸä¸ªå·¥å…·ç±»ä¸­è°ƒç”¨å®ƒã€‚å› æ­¤åœ¨è¿™é‡Œæˆ‘å°†ç®€å•åœ°åœ¨åŒä¸€ä¸ªæ–‡ä»¶ä¸­åšã€‚æ‰€ä»¥æˆ‘è¯´ã€‚è¦ã€‚Kiyianã€‚è¿™ä¸¤ä¸ªç‰¹å¾å‘é‡çš„è·ç¦»ã€‚æˆ‘ä»¬è¯´
    x1 å’Œ x2ã€‚ç°åœ¨å†æ¥çœ‹çœ‹å…¬å¼ã€‚è¿™æ˜¯å¹³æ–¹æ ¹ã€‚ç„¶åæ˜¯æ¯ä¸ªå¹³æ–¹è·ç¦»çš„æ€»å’Œã€‚æ‰€ä»¥æˆ‘ä»¬å¾—åˆ°å¹³æ–¹æ ¹ã€‚
- en: So we can sayã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_22.png)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´ã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_22.png)
- en: '![](img/46ae3dd4f47308ef10799ea81647c68c_23.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ae3dd4f47308ef10799ea81647c68c_23.png)'
- en: Nampai dot Sï¼Œ Qï¼Œ R Tã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_25.png)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Nampai çš„ dot Sï¼ŒQï¼ŒR Tã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_25.png)
- en: And then we have the sumã€‚ so we can use numpy dot sumã€‚ So this will calculate
    the sum for over eachã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_27.png)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬æœ‰äº†æ€»å’Œã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ numpy çš„ dot sumã€‚è¿™æ ·å°±å¯ä»¥è®¡ç®—æ¯ä¸ªçš„æ€»å’Œã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_27.png)
- en: Feature vector componentã€‚ And here we have theã€‚Squared differenceã€‚ So we can
    say x 1 minus x2 to the power of 2ã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_29.png)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ç‰¹å¾å‘é‡ç»„ä»¶ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬æœ‰å¹³æ–¹å·®ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´ x1 å‡å» x2 çš„å¹³æ–¹ã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_29.png)
- en: So this is all we needã€‚ And we want to return thisï¼Œ of courseã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_31.png)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„å…¨éƒ¨ã€‚æˆ‘ä»¬å½“ç„¶æƒ³è¿”å›è¿™ä¸ªã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_31.png)
- en: And now in our predict methodsã€‚What we want to do isã€‚We want to calculate the
    distances of this one new sample to all the training samplesã€‚ So we also use list
    comprehensions hereï¼Œ and we call this Euclidean distance with our new test sampleã€‚Soï¼Œ
    and then to each of the training samplesã€‚ So we say small x trainã€‚
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨åœ¨æˆ‘ä»¬çš„é¢„æµ‹æ–¹æ³•ä¸­ã€‚æˆ‘ä»¬è¦åšçš„æ˜¯ã€‚æˆ‘ä»¬æƒ³è®¡ç®—è¿™ä¸ªæ–°æ ·æœ¬ä¸æ‰€æœ‰è®­ç»ƒæ ·æœ¬çš„è·ç¦»ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¹Ÿä½¿ç”¨åˆ—è¡¨æ¨å¯¼ï¼Œå¹¶å°†è¿™ä¸ªæ–°çš„æµ‹è¯•æ ·æœ¬ä¸æˆ‘ä»¬è®¡ç®—çš„æ¬§å‡ é‡Œå¾—è·ç¦»ç»“åˆèµ·æ¥ã€‚å› æ­¤ï¼Œç„¶åå¯¹æ¯ä¸ªè®­ç»ƒæ ·æœ¬è¿›è¡Œè®¡ç®—ã€‚æ‰€ä»¥æˆ‘ä»¬è¯´å°
    x trainã€‚
- en: And then we want to calculate this forã€‚Extrain in capitalï¼Œ or in self dotã€‚X
    trainã€‚So now we have all the distancesã€‚And now we want to get the key nearest
    samples and the labelsã€‚So what we do here is we sort our distances andã€‚We can
    do thisã€‚ So let's call this decayã€‚Indicesã€‚And thisã€‚ And here we use nuumpy dotã€‚Ark
    sortã€‚So this will sort the distances andã€‚
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬æƒ³ä¸ºæ­¤è®¡ç®—ã€‚åœ¨ capital ä¸­ï¼Œæˆ–åœ¨ self.dotã€‚X trainã€‚æ‰€ä»¥ç°åœ¨æˆ‘ä»¬æœ‰äº†æ‰€æœ‰çš„è·ç¦»ã€‚ç°åœ¨æˆ‘ä»¬æƒ³è·å–æœ€è¿‘çš„æ ·æœ¬å’Œæ ‡ç­¾ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨è¿™é‡Œåšçš„æ˜¯æ’åºæˆ‘ä»¬çš„è·ç¦»ã€‚æˆ‘ä»¬å¯ä»¥è¿™æ ·åšã€‚æ‰€ä»¥è®©æˆ‘ä»¬ç§°ä¹‹ä¸º
    decayã€‚Indicesã€‚ç„¶åè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ nuumpy.dotã€‚Ark sortã€‚æ‰€ä»¥è¿™å°†æ’åºè·ç¦»ã€‚
- en: Will return the indicesã€‚Of how this is sortedã€‚ So here we callã€‚Distancesã€‚And
    this will be an arrayã€‚ And we also wantï¼Œ we only want to have the K closest samplesã€‚
    So let's use slicing hereã€‚ And let's start at the beginningã€‚ So 0ã€‚ or we can omit
    thisã€‚ And this is goes only until self dot Kã€‚ So this will be theã€‚Indices of the
    K nearest samplesã€‚ And now let's get the labelsã€‚ So we get theã€‚
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿”å›æ’åºçš„ç´¢å¼•ã€‚æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬è°ƒç”¨ã€‚Distancesã€‚è¿™å°†æ˜¯ä¸€ä¸ªæ•°ç»„ã€‚æˆ‘ä»¬åªæƒ³è¦ K ä¸ªæœ€æ¥è¿‘çš„æ ·æœ¬ã€‚æ‰€ä»¥è®©æˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨åˆ‡ç‰‡ã€‚å¹¶ä»å¼€å§‹å¤„å¼€å§‹ã€‚æ‰€ä»¥
    0ã€‚æˆ–è€…æˆ‘ä»¬å¯ä»¥çœç•¥è¿™ä¸ªã€‚è¿™ä»…é€‚ç”¨äº self.dot Kã€‚æ‰€ä»¥è¿™å°†æ˜¯ K æœ€è¿‘æ ·æœ¬çš„ç´¢å¼•ã€‚ç°åœ¨è®©æˆ‘ä»¬è·å–æ ‡ç­¾ã€‚æ‰€ä»¥æˆ‘ä»¬å¾—åˆ°ã€‚
- en: Kayã€‚Nearestã€‚Labels equalsã€‚ And here we canã€‚ we also use list comprehensionsã€‚
    and then we get the label of each training and labelsã€‚With this in the indexï¼Œ
    So the index Iã€‚ and then for I in K indcsã€‚So now we have the labels of our nearest
    neighborsã€‚ and then we use a maturity vote and get the most common class labelã€‚
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Kã€‚æœ€è¿‘ã€‚æ ‡ç­¾ç­‰äºã€‚åœ¨è¿™é‡Œæˆ‘ä»¬å¯ä»¥ã€‚æˆ‘ä»¬ä¹Ÿä½¿ç”¨åˆ—è¡¨æ¨å¯¼å¼ã€‚ç„¶åæˆ‘ä»¬è·å–æ¯ä¸ªè®­ç»ƒæ ‡ç­¾çš„æ ‡ç­¾ã€‚ç”¨è¿™ä¸ªç´¢å¼•ã€‚æ‰€ä»¥ç´¢å¼• Iã€‚ç„¶åå¯¹äº I åœ¨ K indcs ä¸­ã€‚æ‰€ä»¥ç°åœ¨æˆ‘ä»¬æœ‰äº†æœ€è¿‘é‚»çš„æ ‡ç­¾ã€‚ç„¶åæˆ‘ä»¬ä½¿ç”¨æŠ•ç¥¨æœºåˆ¶ï¼Œå¾—åˆ°æœ€å¸¸è§çš„ç±»åˆ«æ ‡ç­¾ã€‚
- en: So let's call this most common equalsã€‚ And for thisï¼Œ we use another Python moduleã€‚
    So we use the counter moduleã€‚ So we say from collections importã€‚Counterã€‚And thenã€‚Weiiã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_33.png)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è®©æˆ‘ä»¬ç§°ä¹‹ä¸ºæœ€å¸¸è§çš„ç­‰äºã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨å¦ä¸€ä¸ª Python æ¨¡å—ã€‚æ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨ counter æ¨¡å—ã€‚æ‰€ä»¥æˆ‘ä»¬è¯´ä» collections å¯¼å…¥ã€‚Counterã€‚ç„¶åã€‚æˆ‘ä»¬iiã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_33.png)
- en: Get thereã€‚Or we get a counter of theï¼Œ nearest labelsã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_35.png)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°è¾¾é‚£é‡Œã€‚æˆ–è€…æˆ‘ä»¬è·å¾—æœ€è¿‘æ ‡ç­¾çš„è®¡æ•°å™¨ã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_35.png)
- en: And then this is a method called most commonã€‚ And we only want to have the first
    or the very most commonã€‚å—¯ã€‚And now let's have a look how this looksï¼Œ soã€‚If I comment
    this out and let's write a short example what the collections or the counter module
    will doã€‚
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åè¿™æ˜¯ä¸€ä¸ªå«åšæœ€å¸¸è§çš„çš„æ–¹æ³•ã€‚æˆ‘ä»¬åªæƒ³è¦ç¬¬ä¸€ä¸ªæˆ–æœ€å¸¸è§çš„é¡¹ç›®ã€‚å—¯ã€‚ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹è¿™æ˜¯ä»€ä¹ˆæ ·å­ï¼Œæ‰€ä»¥ã€‚å¦‚æœæˆ‘æ³¨é‡Šæ‰è¿™ä¸ªï¼Œè®©æˆ‘ä»¬å†™ä¸€ä¸ªçŸ­ç¤ºä¾‹ï¼Œcollections
    æˆ– counter æ¨¡å—å°†ä¼šåšä»€ä¹ˆã€‚
- en: So let's say we have a list A equalsï¼Œ and this is some values in itã€‚ So 1ï¼Œ1ï¼Œ1ï¼Œ2ï¼Œ2ã€‚
    and then some errorã€‚Labelsï¼Œ as though also from collections importã€‚Counterã€‚And
    now we get the most common equalsï¼Œ soã€‚We create a counter of this listï¼Œ and then
    one most commonã€‚
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªåˆ—è¡¨ Aï¼Œå®ƒç­‰äºä¸€äº›å€¼ã€‚æ‰€ä»¥ 1ï¼Œ1ï¼Œ1ï¼Œ2ï¼Œ2ã€‚ç„¶åæœ‰ä¸€äº›é”™è¯¯ã€‚æ ‡ç­¾ï¼Œå°±å¥½åƒä¹Ÿä» collections å¯¼å…¥äº†ã€‚Counterã€‚ç°åœ¨æˆ‘ä»¬å¾—åˆ°æœ€å¸¸è§çš„å…ƒç´ ã€‚æ‰€ä»¥æˆ‘ä»¬åˆ›å»ºè¿™ä¸ªåˆ—è¡¨çš„è®¡æ•°å™¨ï¼Œç„¶åå–å‡ºä¸€ä¸ªæœ€å¸¸è§çš„å…ƒç´ ã€‚
- en: '![](img/46ae3dd4f47308ef10799ea81647c68c_37.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ae3dd4f47308ef10799ea81647c68c_37.png)'
- en: Soã€‚Let's print thisã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_39.png)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ã€‚è®©æˆ‘ä»¬æ‰“å°è¿™ä¸ªã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_39.png)
- en: Soã€‚I have toã€‚Close this firstã€‚ So let's run this againã€‚å—¯ã€‚So this will be a listã€‚
    and then we have a tuple of the most common itemã€‚ Soï¼Œ for exampleï¼Œ if weï¼Œ in this
    caseã€‚ we only haveï¼Œ we want to have oneï¼Œ the one most common itemã€‚ and this is
    a tupleã€‚ and the first item here is the most common itemã€‚ So this is oneã€‚ and
    the second item is theã€‚
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ã€‚æˆ‘å¿…é¡»ã€‚å…ˆå…³é—­è¿™ä¸ªã€‚æ‰€ä»¥è®©æˆ‘ä»¬å†æ¬¡è¿è¡Œè¿™ä¸ªã€‚å—¯ã€‚æ‰€ä»¥è¿™å°†æ˜¯ä¸€ä¸ªåˆ—è¡¨ã€‚ç„¶åæˆ‘ä»¬æœ‰ä¸€ä¸ªæœ€å¸¸è§é¡¹ç›®çš„å…ƒç»„ã€‚æ‰€ä»¥ï¼Œä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬åœ¨è¿™ç§æƒ…å†µä¸‹ã€‚æˆ‘ä»¬åªæƒ³è¦ä¸€ä¸ªï¼Œæœ€å¸¸è§çš„é¡¹ç›®ã€‚è¿™ä¸ªæ˜¯ä¸€ä¸ªå…ƒç»„ã€‚è¿™é‡Œçš„ç¬¬ä¸€ä¸ªé¡¹ç›®æ˜¯æœ€å¸¸è§çš„é¡¹ç›®ã€‚æ‰€ä»¥è¿™æ˜¯
    1ã€‚ç¬¬äºŒä¸ªé¡¹ç›®æ˜¯ã€‚
- en: Number of timesï¼Œ this is in our listã€‚ So it three times  oneã€‚ Soï¼Œ for exampleï¼Œ
    if you use twoã€‚ then it will also put in the second most common itemsã€‚ In this
    caseï¼Œ it is2ã€‚ and we have two times 2ã€‚ So we only wantã€‚One most commonã€‚So as I
    saidï¼Œ this is a listã€‚ So in order to get the first itemï¼Œ we use the index 0ã€‚
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå…ƒç´ åœ¨æˆ‘ä»¬çš„åˆ—è¡¨ä¸­å‡ºç°çš„æ¬¡æ•°ã€‚æ‰€ä»¥å®ƒå‡ºç°äº†ä¸‰æ¬¡ 1ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ ä½¿ç”¨ 2ã€‚é‚£ä¹ˆå®ƒä¹Ÿä¼šæ”¾å…¥ç¬¬äºŒä¸ªæœ€å¸¸è§çš„é¡¹ç›®ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ˜¯ 2ã€‚æˆ‘ä»¬æœ‰ä¸¤ä¸ª 2ã€‚æ‰€ä»¥æˆ‘ä»¬åªæƒ³è¦ä¸€ä¸ªæœ€å¸¸è§çš„ã€‚æ‰€ä»¥æ­£å¦‚æˆ‘æ‰€è¯´ï¼Œè¿™æ˜¯ä¸€ä¸ªåˆ—è¡¨ã€‚ä¸ºäº†è·å¾—ç¬¬ä¸€ä¸ªé¡¹ç›®ï¼Œæˆ‘ä»¬ä½¿ç”¨ç´¢å¼•
    0ã€‚
- en: So now we have the tuple and now to get the actual items againï¼Œ we use the first
    indexã€‚ and then we have oneã€‚So here we have to do the same thingï¼Œ and we want
    to return thisã€‚ So let's return most common of index 0 of index 0ã€‚And this is
    all our implementation of the K and N algorithmã€‚Soï¼Œ let's try this outï¼Œ soã€‚Let'sã€‚
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†å…ƒç»„ï¼Œæ¥ä¸‹æ¥è¦å†æ¬¡è·å–å®é™…çš„é¡¹ç›®ï¼Œæˆ‘ä»¬ä½¿ç”¨ç¬¬ä¸€ä¸ªç´¢å¼•ã€‚ç„¶åæˆ‘ä»¬æœ‰ 1ã€‚æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬ä¹Ÿè¦åšåŒæ ·çš„äº‹æƒ…ï¼Œæˆ‘ä»¬æƒ³è¿”å›è¿™ä¸ªã€‚æ‰€ä»¥è®©æˆ‘ä»¬è¿”å›ç´¢å¼• 0
    çš„æœ€å¸¸è§çš„ç´¢å¼• 0ã€‚è¿™å°±æ˜¯æˆ‘ä»¬ K å’Œ N ç®—æ³•çš„å®ç°ã€‚è®©æˆ‘ä»¬è¯•ä¸€ä¸‹è¿™ä¸ªï¼Œæ‰€ä»¥ã€‚è®©æˆ‘ä»¬ã€‚
- en: in our test exampleï¼Œ we already have our test fileã€‚ We already have our training
    and test samplesã€‚ So let's use ourã€‚Ourã€‚K and N classï¼Œ So we can say from K And
    N importã€‚K and Nã€‚ and then create a classifierã€‚ So Cï¼Œ F equalsã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_41.png)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„æµ‹è¯•ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å·²ç»æœ‰äº†æµ‹è¯•æ–‡ä»¶ã€‚æˆ‘ä»¬å·²ç»æœ‰äº†è®­ç»ƒå’Œæµ‹è¯•æ ·æœ¬ã€‚æ‰€ä»¥è®©æˆ‘ä»¬ä½¿ç”¨æˆ‘ä»¬çš„ã€‚Kå’ŒNç±»ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´ä»Kå’ŒNå¯¼å…¥ã€‚Kå’ŒNã€‚ç„¶ååˆ›å»ºä¸€ä¸ªåˆ†ç±»å™¨ã€‚æ‰€ä»¥Cï¼ŒFç­‰äºã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_41.png)
- en: K and Nã€‚And soï¼Œ let's useã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_43.png)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Kå’ŒNã€‚æ‰€ä»¥ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨ã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_43.png)
- en: K equals 3ã€‚And then we want to call the fit method firstã€‚ So we want to fit
    our X trainã€‚And theã€‚Why trainã€‚And then we get the predictionsã€‚ And this isã€‚By
    we do this by calling CF dot predictã€‚ And then we want to predictã€‚Ourã€‚Test sample
    samplesã€‚ So x testã€‚And now let's calculate the accuracyã€‚ So accuracyã€‚ So this
    is defined by how many of our predictionsã€‚Are correctly classifiedã€‚
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Kç­‰äº3ã€‚ç„¶åæˆ‘ä»¬æƒ³å…ˆè°ƒç”¨fitæ–¹æ³•ã€‚æ‰€ä»¥æˆ‘ä»¬æƒ³æ‹Ÿåˆæˆ‘ä»¬çš„Xè®­ç»ƒã€‚å’Œã€‚ä¸ºä»€ä¹ˆè®­ç»ƒã€‚ç„¶åæˆ‘ä»¬å¾—åˆ°é¢„æµ‹ã€‚è¿™æ˜¯ã€‚é€šè¿‡è°ƒç”¨CF.dot.predictæ¥å®ç°ã€‚ç„¶åæˆ‘ä»¬æƒ³é¢„æµ‹ã€‚æˆ‘ä»¬çš„ã€‚æµ‹è¯•æ ·æœ¬ã€‚æ‰€ä»¥x
    testã€‚ç°åœ¨è®©æˆ‘ä»¬è®¡ç®—å‡†ç¡®ç‡ã€‚æ‰€ä»¥å‡†ç¡®ç‡ã€‚è¿™æ˜¯ç”±æˆ‘ä»¬æœ‰å¤šå°‘é¢„æµ‹ã€‚è¢«æ­£ç¡®åˆ†ç±»æ¥å®šä¹‰çš„ã€‚
- en: So this is theã€‚ So here we use the sumã€‚å—¯ã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_45.png)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è¿™æ˜¯ã€‚è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨æ€»å’Œã€‚å—¯ã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_45.png)
- en: The sumã€‚And hereï¼Œ we writeã€‚Predictions equalsï¼Œ equalsã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_47.png)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»å’Œã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å†™ã€‚é¢„æµ‹ç­‰äºï¼Œç­‰äºã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_47.png)
- en: Why testã€‚So for each predictionï¼Œ that isã€‚The rightã€‚Or the same as the correct
    labelï¼Œ itã€‚Es1ã€‚And then we divide this by the number of test samplesã€‚ So we divide
    this by Lngï¼Œ yã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_49.png)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæµ‹è¯•ã€‚æ‰€ä»¥æ¯ä¸ªé¢„æµ‹ï¼Œå°±æ˜¯ã€‚æ­£ç¡®çš„ã€‚æˆ–è€…å’Œæ­£ç¡®æ ‡ç­¾ç›¸åŒï¼Œå®ƒã€‚Es1ã€‚ç„¶åæˆ‘ä»¬å°†å…¶é™¤ä»¥æµ‹è¯•æ ·æœ¬çš„æ•°é‡ã€‚æ‰€ä»¥æˆ‘ä»¬å°†å…¶é™¤ä»¥Lngï¼Œyã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_49.png)
- en: Testã€‚And let's print our accuracyã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_51.png)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: æµ‹è¯•ã€‚è®©æˆ‘ä»¬æ‰“å°æˆ‘ä»¬çš„å‡†ç¡®ç‡ã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_51.png)
- en: And see if this worksã€‚Soï¼Œ yeahï¼Œ in this caseï¼Œ it's 1ã€‚0ã€‚ So all of our predictions
    areã€‚Correctã€‚ so let's use anotherã€‚Number of neighborsã€‚ So K equals 5ã€‚ So usually
    you want you want to use an odd number hereã€‚ So let's run thisã€‚Ohï¼Œ sorryã€‚ So in
    this caseï¼Œ it's 096ï¼Œ soã€‚Not as good as with three neighboursï¼Œ but also very goodã€‚
    And yeahã€‚
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹è¿™ä¸ªæ˜¯å¦æœ‰æ•ˆã€‚æ‰€ä»¥ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒæ˜¯1ã€‚0ã€‚æ‰€ä»¥æˆ‘ä»¬æ‰€æœ‰çš„é¢„æµ‹éƒ½æ˜¯ã€‚æ­£ç¡®çš„ã€‚æ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨å¦ä¸€ä¸ªã€‚é‚»å±…æ•°é‡ã€‚æ‰€ä»¥Kç­‰äº5ã€‚é€šå¸¸ä½ ä¼šæƒ³åœ¨è¿™é‡Œä½¿ç”¨ä¸€ä¸ªå¥‡æ•°ã€‚æ‰€ä»¥è®©æˆ‘ä»¬è¿è¡Œè¿™ä¸ªã€‚å“¦ï¼ŒæŠ±æ­‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒæ˜¯096ï¼Œæ‰€ä»¥ã€‚æ²¡æœ‰ä¸‰ä¸ªé‚»å±…é‚£ä¹ˆå¥½ï¼Œä½†ä¹Ÿéå¸¸ä¸é”™ã€‚å—¯ã€‚
- en: we see that this is workingã€‚ And this is our whole implementation of the K And
    Mã€‚ And yeahã€‚ I hope you enjoyed this tutorial and see you in the next tutorialï¼Œ
    byeã€‚ğŸ˜Šã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_53.png)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çœ‹åˆ°è¿™åœ¨å·¥ä½œã€‚è¿™æ˜¯æˆ‘ä»¬æ•´ä¸ªKå’ŒMçš„å®ç°ã€‚å—¯ã€‚æˆ‘å¸Œæœ›ä½ å–œæ¬¢è¿™ä¸ªæ•™ç¨‹ï¼Œä¸‹ä¸ªæ•™ç¨‹è§ï¼Œæ‹œæ‹œã€‚ğŸ˜Šã€‚![](img/46ae3dd4f47308ef10799ea81647c68c_53.png)
