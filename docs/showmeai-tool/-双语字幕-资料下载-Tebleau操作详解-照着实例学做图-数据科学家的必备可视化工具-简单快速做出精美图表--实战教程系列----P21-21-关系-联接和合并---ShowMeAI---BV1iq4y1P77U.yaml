- en: „ÄêÂèåËØ≠Â≠óÂπï+ËµÑÊñô‰∏ãËΩΩ„ÄëTebleauÊìç‰ΩúËØ¶Ëß£ÔºåÁÖßÁùÄÂÆû‰æãÂ≠¶ÂÅöÂõæÔºÅÊï∞ÊçÆÁßëÂ≠¶ÂÆ∂ÁöÑÂøÖÂ§áÂèØËßÜÂåñÂ∑•ÂÖ∑ÔºåÁÆÄÂçïÂø´ÈÄüÂÅöÂá∫Á≤æÁæéÂõæË°®ÔºÅÔºúÂÆûÊàòÊïôÁ®ãÁ≥ªÂàóÔºû - P21Ôºö21ÔºâÂÖ≥Á≥ª„ÄÅËÅîÊé•ÂíåÂêàÂπ∂
    - ShowMeAI - BV1iq4y1P77U
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hi folksÔºå welcomelcom to another episode of Tableau in two minutes„ÄÇ I know it's
    been a long time since we last posted oneÔºå but I've found a better time„ÄÇ and hopefully
    we can do a few videos over the next over the next few weeks and few months„ÄÇ The
    first thing that I want to coverÔºå though is something that is a new feature introduced
    in tableableau 2020 do2„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: And that is changes to the data model where you can now create relationships
    instead of just having to join and union your data like you were writing a SQL
    script„ÄÇ The relationships make things super flexible„ÄÇ So sort of sort of excited
    to„ÄÇüòäÔºåTo get into them„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So why don't we talk from about why you might want to use them and why they
    are a little bit easier than the old way„ÄÇSo these joins are don't require any
    knowledge of SQL to work well„ÄÇ you know„ÄÇ you can set up a relationship without
    having to know whether it's a left join or a right join or whatever„ÄÇ So instead
    of spending all the time preparing your dataÔºå you're going to spend more time
    exploring„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: visualizingÔºå sharing and all that sort of thing„ÄÇOurRe are also going to help
    sidestep some of the issues with granularity where Tableau is going to be less
    sensitive to where you put which table and the order in which the relationship
    is defined right so if you didn't have your most granular table as the one that
    everything else was being joined to sometimes you ended up duplicating rows or
    making other mistakes or if you had two tables that had different levels of aggregation
    when you joined them together sometimes you could end up creating sort of weird
    dupplications of data and you had to be very careful and spend a lot of time cleaning
    up the data before you ever brought it into tableableau in order to try and avoid
    those sort of issues„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: I don't know about you but I have spent a lot of time cleaning up my data and
    aligning it so that the aggregations are all correct when it gets pulled into
    tableableau„ÄÇTableaus also introduced this concept called smart aggregation that
    means you have less risk of accidentally duplicating the data or accidentally
    getting the answers wrong or something like that if you're using data from multiple
    sources„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So what tableau is going to do in the background is instead of having everything
    like prepackaged into tables„ÄÇ it's going to aggregate the data at a different
    level for each visualization depending on what pieces you bring into the view„ÄÇ
    So we're going to take a look at that in a second„ÄÇBut first of all„ÄÇ we're going
    to take a look at relationships right„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So because you don't have to make such a strict choice early about how you're
    going join your data that allows„ÄÇ that's what allows this level of flexibility„ÄÇ
    So we're going to see what that looks like as you're building the data„ÄÇ So the
    first thing that I'm going to do is I'm going to join to this bookshop data set„ÄÇ
    that tableableau's example of how and why you might want to use the relationships
    instead of traditional joins and things like that„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: And this is a great data set to try with because there's a whole bunch of stuff
    that we can pull together„ÄÇ So the first thing we're going to pull in is this book
    table„ÄÇüòä„ÄÇThis is like the base table of the data„ÄÇAnd with this base table„ÄÇ we're
    going to sort of build the relationships from this table right so the concept
    is that we have some data about books„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: books can have a book is obviously a bookÔºå but a book can have multiple editions
    so it might have a hardcover version„ÄÇ a softcover versionÔºå in addition to that
    we have information about the author who the publisher is„ÄÇ whether there's any
    ratings or awardsÔºå and we have some sales data about these these books as well„ÄÇSo
    we've added our first tableÔºå we've added the book table here and the first„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: the other table I'm going to just add is the awards table„ÄÇüò°ÔºåRightÔºå so when we
    add the award table„ÄÇ you see we get this edit relationship dialo box„ÄÇ We can choose
    the field from the book table and the field from the award table that should match
    in order to„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: Define the relationship between these two„ÄÇ we can alsoÔºå if we want to„ÄÇ we can
    add more fields so we couldÔºå if we needed to join on more than one criteria„ÄÇ we
    could add that as well„ÄÇAnd we also have these performance options„ÄÇ Now„ÄÇ performance
    options are similar„ÄÇTo what you might find or what you might think about when
    you do a join„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: But they are a little different„ÄÇSo firstÔºå we can adjust this cardinality of
    the join„ÄÇ I think the thing to remember about both of these options is if you're
    not sure whether you should change it„ÄÇ you should probably leave it with a default„ÄÇ
    The default's going to do a good job in most situations„ÄÇ you might get some small
    performance benefit„ÄÇ if you change some of these options with the right data set„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: But the risk is that if you do it with the wrong data set„ÄÇ It's going to„ÄÇGoing
    to give you the wrongÔºå the wrong informationÔºå so„ÄÇThe default is many to many„ÄÇ
    but if one of your data sources had one line for every valueÔºå rightÔºå you could
    set this as one„ÄÇAnd when you do thatÔºå tableau pre aggregategregates the data rate„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: so it pulls the data together before it pulls it into the visualization„ÄÇ and
    that has some performance enhancementsÔºå rightÔºå It makes things perform a little
    bit better„ÄÇ particularly if you have a big data set„ÄÇ But if you have if you think
    you have one row„ÄÇ but you actually have more than one row that will duplicate
    items in this data set and that will cause you issues„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: rightÔºå you'll get the wrong answers to some of your calculations and things
    like that„ÄÇ So bottom line is if you're not absolutely certain that you only have
    a unique row for for each value in this key„ÄÇ you should leave this as many to
    many„ÄÇNowÔºå for referential integrityÔºå again„ÄÇ default values are probably the bestÔºå
    but you have two options„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: you can select either some records match or all records match„ÄÇüòäÔºåIf you select
    some records match„ÄÇ then Tableau is going to look to see which ones it doesÔºå rightÔºå
    and's as it builds its query„ÄÇ it's going to look to see which relation which records
    match and which records don't match„ÄÇIf by selecting all records matchÔºå you can
    tell Tableau that we know already that all records match and that helps behind
    the scenes right that's going to help make the join a bit simpler and it's going
    to potentially speed up or make your visualization more responsive„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: üò°ÔºåFor a small data setÔºå it's going to make not that much differenceÔºå but for
    a big data set„ÄÇ it can be quite helpfulÔºå but againÔºå if you're not sure it's best
    to leave it as a default because if you don't leave it as the default or you put
    it as all records match„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: But all records don't match„ÄÇ You're gonna end up missingÔºå missing data„ÄÇSo here's
    what we're going to do„ÄÇ We're going add we've sort of walked through this dialog
    box„ÄÇ Let's go ahead and add the author's table as well„ÄÇ You'll see that the award
    that was joined on the title„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: Now we have something that's joining on the author I and we have all the same
    options right So we're going leave it as default many to many summer records match
    and summer records match„ÄÇüòäÔºåNowÔºå why don't we go for one that's a little bit more
    challenging For this one„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: I'm gonna to add the info table„ÄÇ NowÔºå up until nowÔºå when we added the author
    in the award table„ÄÇ the fields that we were joining on had the same name in both
    tables„ÄÇ But when we add the author tableÔºå there aren't fields with the same name
    in both tables in both both tables„ÄÇ So it's not sure what to join on„ÄÇ So we get
    this red exclamation point in the triangle and it says we have to select the matching
    fields in order to create this relationship„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: NowÔºå one of the great things about this new version of tableau is that we can
    create what's called a relationship calculation„ÄÇ Now that means that we can sort
    of combine these two fields like in the edit relationship dial box instead of
    having to do it either in the data source or to come up with some other way of
    doing it Tableau wasn't super flexible if you didn't have two matching fields„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: even though you may have the same information in both of them„ÄÇ Now„ÄÇ I know from
    looking at the data and I'll post a link to the data in„ÄÇüòäÔºåThe video description„ÄÇBut
    I know that this book I field is the combination of book I 1 and book I 2„ÄÇ So
    we're going to concatenate book I 1 and book I 2„ÄÇ And to do that„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: we're going to create our relationship calculation„ÄÇ There's just a regular calculation
    dialog box„ÄÇ See we can pop out all of our functions on the side hereÔºå and we're
    going to say book I 1 plus„ÄÇBook ID 2„ÄÇApply that„ÄÇAnd we've created our join„ÄÇ and
    you can see when you look at it right„ÄÇ if we look at the data hereÔºå the book I
    1 is two letters and then book I2 is three numbers„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: and if we click on bookÔºåAnd we look at the book table„ÄÇ You can see that that'sÔºå
    again„ÄÇ it's those two letters plus the three numbers„ÄÇSo that is now„ÄÇSuccessfully
    joined now„ÄÇMuch more flexible„ÄÇT SQLÔºå a lot easier to use than SQel 2Ôºå to be honest„ÄÇ
    Alright„ÄÇ So we're gonna add a couple more tables hereÔºå And I'm gonna show you
    something else„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: First thing we're gonna do is just add the edition table„ÄÇ note that where you
    drag itÔºå right„ÄÇ differentÔºå It's trying to join to different tables„ÄÇ We want to
    join to the book table„ÄÇ So we want to make sure this little orange squiggly line
    when we drop it„ÄÇüòä„ÄÇWith the orange squiggly line points to the book tableÔºå not
    one of the other tables„ÄÇ Again„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: we want that to join on book I D„ÄÇ So that is fine„ÄÇ NowÔºå we have our addition
    table„ÄÇ We're join the sales table to it„ÄÇ We're gonna take the sales table„ÄÇüòäÔºåOut
    over here„ÄÇ the sales table joins to the addition table„ÄÇOhÔºå hang on a second„ÄÇ I've
    joined it to the wrong table„ÄÇ It's not gone well„ÄÇ There we go„ÄÇThere we go„ÄÇ Allright„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So now we're connected to the edition table on the ISBN number„ÄÇ know anything
    about books„ÄÇ the IBN number is what identifies a particularÔºå a particular edition„ÄÇSo
    now that we've dragged the Q1 table out we have some sales information and this
    is all nicely going to aggregate together„ÄÇ but we have different sales tables
    for each quarterÔºå so we have one for Q1Ôºå one for Q2Ôºå one for Q3„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: and one for Q4„ÄÇüòäÔºåSo what I'm going do is I'm going to we have to union these
    togetherÔºå right„ÄÇ So a union is a sQL concept„ÄÇ and it's still present in tableableau„ÄÇ
    We didn't get completely away from it„ÄÇ And what a union does is it takes two tables
    with identical structures„ÄÇ and it basically stacks them on top of one another
    so that instead of one tableÔºå we get„ÄÇSorry„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: instead of two tablesÔºå you have one table with all the information of both tables
    in it„ÄÇ Now„ÄÇ all the columns need to be the same„ÄÇ and they all need to be the same
    data type„ÄÇ And sos there's some restrictions to it„ÄÇ But fundamentallyÔºå that's
    what we're going to do„ÄÇ And that's what we want to do with these tablesÔºå rightÔºå
    because we have sales data for Q1„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: We have sales data for Q2Ôºå Q3 and Q4Ôºå And we want to put them all together so
    that we have a full year„ÄÇ So what we're going to do is we'll take this Q2 data„ÄÇ
    And to create a union between two tables„ÄÇ So that is to stack one on top of the
    other„ÄÇ We're going to drag it until it sits just under the Q1 data„ÄÇ And we get
    this little orange union dial box pop up„ÄÇWe're going to drop it there„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: And then you'll see that our sales Q1 data now has changed a bit„ÄÇThe Excel Q2
    data has disappeared„ÄÇ but we've got this icon„ÄÇOn the left hand side„ÄÇ And if we
    hover over it„ÄÇ it tells us what's going on inside that data„ÄÇ So sales Q1 is made
    up of two tables„ÄÇ And we can see that from this little piece in here„ÄÇ NowÔºå if
    we wanted to dig further into that„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: as it saysÔºå we can double click on the sales data„ÄÇ And this digs in right deeper
    and then shows us what's happening behind the scenes„ÄÇ So in order to edit the
    unionÔºå we have to go back in here and clickÔºå edit union„ÄÇAnd you can see these
    are our two tables„ÄÇ And if we wanted to add more tables to thisÔºå right„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: we can add the Q3„ÄÇAnd the Q4 sales data„ÄÇClickÔºå O„ÄÇSo we can do it that way„ÄÇ Let's
    remove them from this„ÄÇOkayÔºå so we're going to jump out of there„ÄÇ I'm gonna x out
    of that„ÄÇ But if we could also add them out hereÔºå rightÔºå so we can drag them and
    I can drop it right here„ÄÇAnd thenÔºå I'm going to go„ÄÇBack in hereÔºå right„ÄÇ So now
    I've added Q1Ôºå Q2Ôºå Q 3 and Q4„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: And when I doubled click„ÄÇI go insideÔºå and I go in here to edit the union„ÄÇYou
    can see that I have all my four tables stacked on top of one another„ÄÇ Now I'm
    going to temporarily remove these tables because one of them„ÄÇIs doing something
    funky somewhere else down the line„ÄÇ I was just testing that earlier on„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So we'll get back to that„ÄÇ But that is how you could uni in the four tables
    together„ÄÇ That dial box is also how you could join two fields together„ÄÇ Now„ÄÇ we
    defined the the author relationship„ÄÇAnd by„ÄÇUsing this line right hereÔºå right„ÄÇ
    at by just dragging it out and dropping it in„ÄÇ But let's say that we wanted to„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: Join it directly to the book table„ÄÇ So what I did is I double clicked on the
    book table just the same way we did with the sales table„ÄÇ And this is where your
    traditional sQel joins are hidden„ÄÇ So if I drag out my author table now„ÄÇ you can
    see that I get this little symbol and this little symbol is telling me that instead
    of it being a relationship now we're defining a join„ÄÇ And if you've used tableableau
    before in all the previous versionsÔºå right„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: you'll be pretty familiar with this interface„ÄÇüòäÔºåWe click on the little Venn
    diagram and that allows us to define the type of join that we want to do„ÄÇIt allows
    us to define what the fields areÔºå if there's more than one field„ÄÇ we can add that
    down hereÔºå and so on and so on and so on„ÄÇIf you're not familiar with SQL„ÄÇ you
    might not be familiar with exactly what some of these words mean„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: but it's pretty simple and the Venn diagram really helps you figure it out„ÄÇThe
    four join types that we have hereÔºå you have an inner join in an inner join„ÄÇ we're
    going to take all of the records from the book table„ÄÇAnd all of the records from
    the author table that match„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So a record from the book table must have a match in the author table in order
    to be included in the what what's output from the joint„ÄÇ rightÔºå in order to join
    together and vice versa„ÄÇ So a record from the author table must have a match in
    the book table„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: In order toÔºå to be included in this join„ÄÇIf we were to use a left join„ÄÇüò°„ÄÇThat's
    going to include anything from the left tableÔºå in this case„ÄÇ the left table is
    quite literally the table on the left„ÄÇAnd it's going to include all the records
    from this table and any records from the author table that match„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So anything from the author table that has a match in the book table is going
    to be included„ÄÇ anything from the author table that has no match is going to be
    excluded„ÄÇIf we were to go with the right joinÔºå it's the same thingÔºå but we're
    heading in the other direction„ÄÇ So anything from the rightÔºå we're going to get
    everything„ÄÇ SorryÔºå from the right table„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: from this author tableÔºå but only those books that match„ÄÇThey have a match in
    the author table„ÄÇAnd then our final option„ÄÇThe full outer joinÔºå sometimes called
    a full join„ÄÇ sometimes called outer joinÔºå they're basically all the same thingÔºå
    not basically all the same thing„ÄÇ they are all the same thing„ÄÇ that's going to
    include all of the records from both tables and where possible it's going to match
    them up and where there's no match„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: it's just going to fill in nulls So you're going to get every record from the
    book table and every record from the author table regardless of whether they match
    or not„ÄÇSoÔºå so let's think about thatÔºå rightÔºå Let'sÔºå let's think about doing an
    inner join between these two tables„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So we have one bookÔºå one author„ÄÇ Those joined great„ÄÇ We're only including books
    with authors„ÄÇBecause it has to have a record in both tablesÔºå right for our inner
    joinÔºå but„ÄÇIf we have a book with two authors„ÄÇWhat happens is both those authors
    will get joined to the book„ÄÇ rightÔºå so we'll have one book„ÄÇAnd then„ÄÇWe'll have
    another record for that book with the second author„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So I have one record for that book for the first order„ÄÇ one record for that
    book for the second order author„ÄÇSo that's going to potentially duplicate rows
    in the book data set„ÄÇIf we did this join and anywhere that we use this join table„ÄÇ
    we're going to have to deal with that duplication issue„ÄÇ Now sometimes it's a
    deal breaker„ÄÇ sometimes it's not a deal breakerÔºå depends on exactly what you're
    trying to do„ÄÇBut the bottom line is that duplication is something we don't really
    want„ÄÇ And we can avoid that instead by removing this table from the join inside
    the book data source and leaving it as defined by this relationship up here„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So since relationships are so flexible rightÔºå well why might we want to go back
    to joins why might we want to have something that we do inside one of these like
    data blocks inside one of these tables instead of just defining the relationship
    well„ÄÇRelationships are greatÔºå but„ÄÇThere might be certain things where there's
    something in the data or there's some particularly unique aspect to this relationship
    that requires us to have that very specific level of control and level of granularity
    that we get through the joints„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: We might have something where„ÄÇIf those two tables are not joined together in
    a specific way„ÄÇ one of them does not aggregate correctlyÔºå or one of them doesn't
    count correctly„ÄÇ So„ÄÇ so we want to be aware of that as we walk through it with
    our dataÔºå these are typically„ÄÇ I think if you're working with a lot of dataÔºå you'd
    probably be aware of these types of issues before„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: rightÔºå because this is not the only place where you would have to deal with
    them„ÄÇSo„ÄÇ so it's worth bearing in mind„ÄÇ It's worth knowing how to do it„ÄÇ but relationships
    super flexible and very much a a big step forward in terms of the data model„ÄÇNow„ÄÇ
    for those of you coming from the old Tableau„ÄÇüò°Ôºåsay the old tableau right it's
    only been not around for a few months„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: but from the old data modelÔºå I guess a few things have changed in 2020 dot2
    that we want to take a look at„ÄÇ So the first thing is you'll see over here on
    the left hand side instead of being organized by dimensions and measures and having
    dimensions pan up top and a measures pane down the bottom now we have individual
    tables and the fields that come from each individual tables„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: so we have all of the fields from our author table here„ÄÇ we have the dimensions
    and we have a line and then we have the measures from each table„ÄÇüòäÔºåSo„ÄÇThat changes
    a little bit the way calculations behave„ÄÇSo if we were to create a calculation
    that just used this author tableÔºå right„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: so let's go ahead and create a calculation that is the percentage of time each
    day an author spends writing„ÄÇOkayÔºå so we're going to take the hours writing per
    day„ÄÇ We're not going aggregate it„ÄÇ We're just going divide it by 24„ÄÇNow you see
    that when you do thatÔºå that's a row level calculation„ÄÇ there's no aggregation
    within the calculation itselfÔºå rightÔºå so it's a row level calculation„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: And because it's a row level calculation and it is only using fields from the
    author data source„ÄÇIt sits right here in the author data source„ÄÇ It doesn't go
    anywhere„ÄÇBut„ÄÇIf we were to create a calculation that combined two different fields„ÄÇ
    So say we wanted to get the sales price for a bookÔºå rightÔºå now„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: the sales price consists of two things„ÄÇ It consists of the price„ÄÇ which comes
    from the addition tableÔºå and then it„ÄÇWe subtract the discount„ÄÇ and the discount
    comes from the sales table„ÄÇSo if we were going to do that„ÄÇLet's go ahead and create
    that calculation„ÄÇFky capitalization in there wops„ÄÇ There we go„ÄÇ Alright„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: so it's price minus discount„ÄÇSo when we create that calculation and apply it„ÄÇ
    you'll see that it doesn't pop up in either of the two data sources„ÄÇ It goes all
    the way down here to the bottom„ÄÇ and down at the bottom is where we're going to
    have all of our calculations that„ÄÇCover multiple„ÄÇTables or multiple thingsÔºå rightÔºå
    They're using those relationships in order to create the calculation„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: And one of the things we want to remember is that when those calculations are
    being calculated„ÄÇ when they're being runÔºå when tableau is figuring out what the
    answer is„ÄÇ it's using an inner join between these two tables in order to make
    it work„ÄÇNowÔºå if„ÄÇThe reason that's worth remembering right is because if we're
    doing things that aggregate in certain ways„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: we're not going to get any records that don't match between those two tables„ÄÇ
    any records that don't have a key between those two tables„ÄÇRight„ÄÇ so if we wanted
    to figure out what the sales price was for every single book„ÄÇIn„ÄÇThat had an additionÔºå
    rightÔºü And we summed thisÔºå this sales price„ÄÇU„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: We would only get because it's doing it in a jointÔºå rightÔºå Remember„ÄÇ So we need
    a record in both sales„ÄÇ We would only get additions for which at least one item
    has been sold„ÄÇ If no items have been soldÔºå it still has a sales price because
    it was still on a shelf somewhere for sale„ÄÇ hasnn't been soldÔºå but it was for
    sale„ÄÇBut because we don't have a record in the sales table„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: it doesn't pull in the price for that record in the addition tableÔºå which means
    potentially„ÄÇWe don't get the total sales pricesÔºå rightÔºå for everything„ÄÇso„ÄÇDefinitely
    worth thinking about„ÄÇ particularly if you get unexpected results or anything looks
    odd in the data„ÄÇ something to watch out for„ÄÇ NowÔºå nine times out of ten0 rate„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: these things are not going to come back and bite youÔºå but if you do see something
    odd„ÄÇ it's definitely worth looking at„ÄÇSo a couple of other things that„ÄÇWe want
    to look at„ÄÇ sorry„ÄÇ one other thing that we want to look at„ÄÇIn the old worldÔºå when
    you created a constant„ÄÇSo when I just typed in oneÔºå right up here„ÄÇIt would put
    that one„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: that one by itself as a row level calculationÔºå so it puts it on every single
    row in the data source„ÄÇWhich used to mean that if you summed it up just like this„ÄÇ
    you would get a sum of the number of records in the data source becauseÔºå you know„ÄÇ
    a row level calculationÔºå as we knowÔºå is calculated once for every single row„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: This one is calculated is still being calculated for every single row„ÄÇ But when
    we use the relationship based data model instead of the join based data model„ÄÇ
    we're only pulling in to the visualization the data that is relevant for that
    visualization rate„ÄÇ So when I created this one up hereÔºå there's only one row in
    our data source„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So the sum of all of the rows in our data source is one because the only data
    point that we've brought in is this constant„ÄÇüòäÔºåSo„ÄÇSo what happens thenÔºå rightÔºå
    if we bring inÔºå let's say we bring in author„ÄÇI will bring in the last name of
    the author„ÄÇ There we go„ÄÇNow you see that„ÄÇI've still got one for each„ÄÇEach row
    in my data sourceÔºå right„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: each one of these authors is now a single row in my data source„ÄÇThat's the data
    source that's being used to generate this visualization„ÄÇ So„ÄÇ so each author has
    a value of one or or this constant is showing for each author„ÄÇ And if we summed
    it upÔºå we'd get however many authors there are in this data set„ÄÇ Now„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: remember thatÔºå rightÔºå Every author has a value of one„ÄÇWith this constantÔºå until„ÄÇWe
    bring out the title„ÄÇYeahÔºå the title to it„ÄÇ well now„ÄÇDantic cat„ÄÇI'm„ÄÇBecause they've
    published a number of titles or because this person's published a number of titles„ÄÇ
    rightÔºå you've got 1Ôºå2Ôºå3Ôºå4Ôºå5Ôºå6Ôºå7Ôºå8 titles that they've published„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: There's eight values for this constant„ÄÇIn the data set„ÄÇ So instead of having
    one„ÄÇ So we've gone„ÄÇ we started off with just a single row in our data source„ÄÇAnd
    it was the total was just one„ÄÇ there was only one„ÄÇWhereas then we added in the
    authors and we had a one for each author„ÄÇ And now we've added in the title„ÄÇ and
    now we're getting a one for each title and each author„ÄÇ right„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So we've got two„ÄÇFor this authorÔºå we've got8Ôºå as I saidÔºå for this author and
    so on and so forth„ÄÇ So the bottom line is„ÄÇConstants don't necessarily behave the
    way that you might expect them to behave if you use them in the old world„ÄÇAgainÔºå
    why might you care„ÄÇ The real reason is that as you look at workarounds and as
    you look at tricks and things like that„ÄÇ a lot of them use these constants in
    order to represent certain things„ÄÇ So we want to„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: Just be careful when we do use those workarounds that what we're actually getting
    is the result that we expect from you know„ÄÇ from using that that constant„ÄÇI so„ÄÇüòäÔºåWill
    be helpful if we knew how to troubleshoot these sort of data sources and we'll
    dig into these calculations in a little bit more detail in a future video so expect
    to see a little bit of information about how we can troubleshoot some of our data
    sources both from a relationships perspective and from a join perspective and
    some videos around calculation coming up at some point in the not too distant
    future but for now I really appreciate you watching if you like the content please
    go ahead and hit that subscribe button and you'll get more tableau and data analytics
    content as we go forward there's a link as I said to this data set in the video
    description so if you want to download Tableau public and follow along that's
    great that's exactly what I use totally free very cool and I look forward to seeing
    what you have to say in the comments and speaking to you next time„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: üòä„ÄÇ![](img/771599ba487d4847a03dea1e21567f41_1.png)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/771599ba487d4847a03dea1e21567f41_2.png)'
  prefs: []
  type: TYPE_IMG
