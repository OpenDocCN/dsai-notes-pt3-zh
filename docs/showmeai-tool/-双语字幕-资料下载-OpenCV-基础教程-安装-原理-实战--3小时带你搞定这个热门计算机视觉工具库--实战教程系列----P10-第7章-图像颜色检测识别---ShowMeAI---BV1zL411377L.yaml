- en: „ÄêÂèåËØ≠Â≠óÂπï+ËµÑÊñô‰∏ãËΩΩ„ÄëOpenCV Âü∫Á°ÄÊïôÁ®ãÔºåÂÆâË£Ö„ÄÅÂéüÁêÜ„ÄÅÂÆûÊàòÔºå 3Â∞èÊó∂Â∏¶‰Ω†ÊêûÂÆöËøô‰∏™ÁÉ≠Èó®ËÆ°ÁÆóÊú∫ËßÜËßâÂ∑•ÂÖ∑Â∫ìÔºÅÔºúÂÆûÊàòÊïôÁ®ãÁ≥ªÂàóÔºû - P10ÔºöÁ¨¨7Á´†ÔºöÂõæÂÉèÈ¢úËâ≤Ê£ÄÊµãËØÜÂà´
    - ShowMeAI - BV1zL411377L
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](img/07947795d9caed2cc20e4ef5ab09c052_0.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/07947795d9caed2cc20e4ef5ab09c052_1.png)'
  prefs: []
  type: TYPE_IMG
- en: „ÄÇSo here we are importing our library and we are importing an image in the resources
    folder by the name Labo„ÄÇpG„ÄÇSo we are just displaying it using the IM show function
    and we are adding a delay so that it stop„ÄÇ it does not disappear„ÄÇSo this is our
    imageÔºå so our task will be to detect the orange color in this image„ÄÇSo firstÔºå
    we are going to convert this into HSV spaceÔºå so we will say image„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: HSV is equals to now as you rememberÔºå we have been using the CVT color to convert
    it into grayscale„ÄÇ so we will use the same functionÔºå C2„ÄÇColor to convert it into
    HSV„ÄÇ so we will say that we want to convert our image and we want it to be c2
    dot color„ÄÇColor underscore„ÄÇBGR to HSV„ÄÇSo this will convert the image into HSVÔºå
    we can copy this„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: and then we can check out our new image„ÄÇSo here we have our new imageÔºå which
    is the HSV„ÄÇ and I did not write a new name that's why it's overr HSV„ÄÇSo this is
    the original and this is the HSVÔºå so now we need to define some color values„ÄÇ
    some ranges in which we want our color to be so we will define the hue„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: the saturation and the value limits and within that limit if the image region
    falls within that color range we will grab that so let's do that„ÄÇSoBut one thing
    to note is that we do not actually know what are the minimum and maximum values
    that we need for this particular orange color„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: so what we are going to do we are going to introduce something known as track
    bars that will help us play around with the values in real time so that we can
    find the optimum minimum and maximum values of our color„ÄÇSo to introduce track
    barsÔºå we are going to create„ÄÇLet's create it on the top„ÄÇHere„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: so we are going to create a new window byÔºå let's say by the name track bars„ÄÇ
    so we will say c2 dot named windowÔºå we will call it track„ÄÇMars and„ÄÇThen we are
    going to resize it so that it is not„ÄÇWe're looking and we will write here track„ÄÇBs
    now this name should be the sameÔºå so just keep in mind not to do any spelling
    mistakes here and then we need to define the size„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: let's say 640 by„ÄÇ2Ôºå40„ÄÇThen we are going to create our first track barÔºå CB2 dot„ÄÇCreate
    now we are using the create track bar function„ÄÇ Now keep in mind that the T here
    is capital so first we will define what value are we going to change using this
    track bar so„ÄÇThis is just a name so we can write anything„ÄÇSo the first value we
    will be changing will be the h minimum„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: And next we are going to define which window are we going to put this track
    bar on so we have already named our window as track bars so we are going to use
    that now we have to define the the current value so when the script runs what
    will be the initial value that it will run with so we will put it at0 and what
    will be the maximum value of our h now as you know here has a maximum value of
    360 now but we do not have 360 here in„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: Open CÔºå we have till 1Ôºå79Ôºå which is basically 1Ôºå80 values„ÄÇSo we will put 179
    and at the end we have we have to call a function which will run every time something
    changes in the track bar so every time the user changes the track bar it will
    call this function but we are going to get the values in another way I will show
    how we will use that later on but for now we do have to define this function so
    but we can say this is an empty function and„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: At the topÔºå we can define„ÄÇEmpty„ÄÇAnd we can say that just pass„ÄÇThat's it„ÄÇSo that
    will pretty much do nothingÔºå so that's how you create the track bar so all you
    need to do now is to run and see what happens„ÄÇWhoopps„ÄÇOkayÔºå so once we run itÔºå
    we are getting this error which say c2„ÄÇt resize„ÄÇ it's not actually resizeÔºå it's
    resize window„ÄÇSo we will resize window and let's play that again„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: And we should have a yeahÔºå we have the track bar here so we have the h minimum
    and you can see that the value is basically going okay„ÄÇ we are missing yeah we
    just need to put here something it will take in an argument and that's it„ÄÇWe will
    run that again and if we use the trackbar again„ÄÇ so now you can see that the U
    value is moving around„ÄÇAnd the minimum is zero and the maximum is 179„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So how many values do we needÔºå we need six values because we will have h minimumÔºå
    then h maximum„ÄÇ then saturation minimumÔºå saturation maximum and value minimum
    and value maximum„ÄÇ so we will copy this„ÄÇA couple of times„ÄÇAnd we will just change
    this to Max„ÄÇAnd then we will change this to„ÄÇSauration„ÄÇSauration and againÔºå we
    will change this to max„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: And minimum will stay the same„ÄÇ This will be value„ÄÇ This will be valueÔºå and
    this will be max„ÄÇSo now these values they range from  zero to2Ôºå5Ôºå5„ÄÇSo we will
    write 255 and the initial values„ÄÇ we will keep them the sameÔºå but for the maximums
    we will keep them at maximum„ÄÇ so here we will put 179 here we will put 255 and
    here we will put 255„ÄÇSo if we run that now„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: we will have six track bars that we can move around„ÄÇSo that is good„ÄÇüòîÔºåYeahÔºå
    that's pretty much good„ÄÇ So what we will do next is we are going to read these
    trackbar values so we can apply on our image„ÄÇSo here we are going to get our values
    using the get track bar position function„ÄÇ so we will say our edge minimum basically
    is equals to C2„ÄÇCV2 dots gets„ÄÇTrack bar„ÄÇPosition„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: there you go„ÄÇSo then we will write which which value are we talking about now
    the spelling here have to be exactly the same„ÄÇ so we will write this here and
    then we are going to say to which track bar window does it belongÔºü
  prefs: []
  type: TYPE_NORMAL
- en: So our window name is track bars„ÄÇ So I'm going to copy this„ÄÇAnd I will paste
    this here„ÄÇSo to confirm„ÄÇ we can just print„ÄÇEdge underscore minimum„ÄÇNowÔºå in order
    to get the value„ÄÇWhat we need to do is we need to put it in a loop because we
    have to run it again and again to keep getting that value„ÄÇ So instead of the image
    we will have to change it to a webcam or„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: Just add a loop so we can write here while„ÄÇShiwu„ÄÇWe want this to keep running„ÄÇAnd
    we will put this in as well„ÄÇ so instead of adding complexity„ÄÇ we can just put
    one here and that should do it„ÄÇSo right now we can see the value is0„ÄÇAnd then
    if we change itÔºå you can see the value keeps changing„ÄÇRight„ÄÇSo next„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: we are going to apply this to all of them„ÄÇAnd we will copy this so that we have
    all the values„ÄÇ so we will do it again five times„ÄÇAnd this time aroundÔºå this will
    be max„ÄÇThen minimum and max and then minimum and max„ÄÇThen we will have the saturation„ÄÇOkay„ÄÇ
    then we have the saturationÔºå then the value„ÄÇAnd then the value„ÄÇSo that is about
    that„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: and then we will write here max and here will be saturation„ÄÇSaurationÔºå and then
    max„ÄÇHere will be minimum valueÔºå and then value„ÄÇAnd thenÔºå max„ÄÇSo we can print all
    of them out just to see just to make sure that if it is correct„ÄÇ we will just
    say H minimum„ÄÇThen„ÄÇHdgeÔºå maximum„ÄÇThen we will say S minimum„ÄÇS maximum than value„ÄÇValue„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: minimum and value„ÄÇMaximum„ÄÇSo let's see how that works out„ÄÇüòîÔºåSo there we have
    it 017902550 and 255„ÄÇ so if I change my values you can see the track bar actually
    changes these values in real time„ÄÇSo now that we have these minimum and maximum
    ranges of the hue saturation and value„ÄÇ we will use these values to filter out
    our image so that we get that particular image in that range„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: Particular color in that range„ÄÇ so now we will create a maskÔºå we will say that
    the mask„ÄÇIs equals to Cv2 dot in range„ÄÇSo we are creating a mask that is in the
    range of these colors„ÄÇ So which image are we talking aboutÔºå We are talking about
    the„ÄÇHSV image and then we have to give it the minimum and the maximum range„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: so we will say this is the lower limit and we will say„ÄÇThis is the upper limit„ÄÇNow
    we need to define this lower and upper limitÔºå so we will right hereÔºå let's do
    the lower first„ÄÇ lower is equals2„ÄÇWe will create a Ny arrayÔºå so let me just add
    that here„ÄÇImport nuy„ÄÇAs MP„ÄÇNow down hereÔºå we are going to add a N array so N„ÄÇDot
    array„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: And then we are going to create the minimum arrayÔºå so which is edge minimum„ÄÇAnd
    then we have S minimum„ÄÇAnd then we have the value minimum„ÄÇÂîîÂèë„ÄÇ‰ªñÂ∞±Ê≤°‰∫Ü‰πà„ÄÇThe same way
    we are going to do for the maximumÔºå so we will say upper is equals to nu pi dot
    array and we will add our maximum limits„ÄÇWhich is Em„ÄÇThenÔºå S max„ÄÇAnd thenÔºå vmax„ÄÇOkayÔºå
    so this will give us the mask„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: so basically what it will doÔºå it will filter out and give us the filtered out
    image of that color„ÄÇSo let's see how that looks like„ÄÇOr no need to copy that„ÄÇ
    we can just paste this here and we can say this is the mask and this will be„ÄÇüòîÔºåMask„ÄÇSo
    let's run that and there we have the mask here we have the original image and
    here we have the track bar„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So if I move this aroundÔºå you can see how„ÄÇThe value of how the image changes„ÄÇSo
    we want to keep all the colors that we don't want as black and we want to keep
    the color that we need in white„ÄÇ So if I was to detect the orange„ÄÇI would say
    that is pretty much good„ÄÇSo I recommend keep changing the valuesÔºå try to keep
    it smoother and smoother„ÄÇEventually„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: you will get some good results„ÄÇ So now that we have these„ÄÇThese values„ÄÇ what
    we can do is we can put them as our initial values„ÄÇ so we have 019 110 to 4153
    and 255 so we can go back here„ÄÇWe can still open up our track bar„ÄÇAnd we can go
    up here„ÄÇLet me keep it on the sideÔºå and I can just„ÄÇSee what it is„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: so this is zero and then this is 19Ôºå this is 110„ÄÇAnd this one is 2Ôºå40„ÄÇThen we
    have 153„ÄÇAnd then 255„ÄÇ So now if I run this again by defaultÔºå I will get the mask„ÄÇ![](img/07947795d9caed2cc20e4ef5ab09c052_3.png)
  prefs: []
  type: TYPE_NORMAL
- en: RightÔºå and next what we can do„ÄÇ![](img/07947795d9caed2cc20e4ef5ab09c052_5.png)
  prefs: []
  type: TYPE_NORMAL
- en: Is we can get our resultÔºå which will be our original image„ÄÇ so instead of getting
    this black and white maskÔºå we can get the actual colored parts„ÄÇ the orange color
    over here„ÄÇSo how we can do that is by creating using this mask„ÄÇ we will create
    a new image so we can say image„ÄÇResults„ÄÇIs equals2„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: We are going are going to use the and operationÔºå so we have the bitwise„ÄÇAnd
    Op„ÄÇ which will add two images together to create a new image„ÄÇIt is basically checking
    both the images and wherever the pixels are both present„ÄÇ it will take that as
    a yes or as a one„ÄÇAnd it will store that in the new image„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: So what it does is we are going to say that we have our„ÄÇOriginal image that
    we want to use„ÄÇAnd our new image will be also like our original imageÔºå but with
    a mask applied„ÄÇWhich is our mask„ÄÇ which is„ÄÇThe one we created before„ÄÇSo let's
    look at the image result„ÄÇImage result„ÄÇ and we should change the name here„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07947795d9caed2cc20e4ef5ab09c052_7.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's run that„ÄÇAnd there you go„ÄÇ So now we have the colored imageÔºå So if you
    did not get that„ÄÇ basically we are we are checking these two images„ÄÇ![](img/07947795d9caed2cc20e4ef5ab09c052_9.png)
  prefs: []
  type: TYPE_NORMAL
- en: The mask and the original imageÔºå and we are checking wherever we have these
    white pixels we are getting from this image and creating a completely new image
    from it„ÄÇ![](img/07947795d9caed2cc20e4ef5ab09c052_11.png)
  prefs: []
  type: TYPE_NORMAL
- en: So that is what we are doing„ÄÇSo one thing we can do here is to add our function
    from our previous chapter in which we joined the images so that we don't have
    to play with all these images again and again„ÄÇ so if we go back to„ÄÇOur previous
    chapterÔºå we have the stacking function„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: we can copy that and bring it here„ÄÇYeahÔºå let's bring it here and then now we
    can go down„ÄÇ this is the by the wayÔºå the tracking functionÔºå so sorry the stacking
    function„ÄÇ so it is stack images„ÄÇSo we can go down and instead of showing all these
    images separate„ÄÇ we can just show the stacking image„ÄÇWhat we can say is that„ÄÇSttapped„ÄÇOr
    we can say I M G stock„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: I M D stack is equal still„ÄÇNow we have to write our functionÔºå which is„ÄÇStock
    images„ÄÇWe have to define the scaleÔºå the scale„ÄÇ Let's keep it at 0„ÄÇ6„ÄÇ And then
    we have to define the array of images„ÄÇ So we are going to„ÄÇPut here„ÄÇWe are going
    to put here the images that we needÔºå so we can put„ÄÇTwo images and then two images„ÄÇ
    Okay„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: so we will create IMG and then IM G HSV„ÄÇ And then in the new roleÔºå we can create„ÄÇWe
    can add the mask and then the image„ÄÇResult„ÄÇAnd then we just need to display the
    final image„ÄÇSo we can stay say start„ÄÇImages and we will write here IMD style„ÄÇSo
    let's remove all of these and we can play again„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: And there you go so now so now we have a neat image with all these images stacked
    up and showing us the values altogether„ÄÇ so now we can have the track part on
    one side and we can see the results directly applied in real time„ÄÇSoÔºå let's„ÄÇCheck
    what the results are„ÄÇ and yeah so„ÄÇSo that's how you can detect colors„ÄÇ
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07947795d9caed2cc20e4ef5ab09c052_13.png)'
  prefs: []
  type: TYPE_IMG
