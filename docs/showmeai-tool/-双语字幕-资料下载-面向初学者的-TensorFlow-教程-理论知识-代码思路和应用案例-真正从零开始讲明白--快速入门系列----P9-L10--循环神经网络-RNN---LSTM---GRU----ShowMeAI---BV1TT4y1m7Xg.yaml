- en: ã€åŒè¯­å­—å¹•+èµ„æ–™ä¸‹è½½ã€‘é¢å‘åˆå­¦è€…çš„ TensorFlow æ•™ç¨‹ï¼Œç†è®ºçŸ¥è¯†ã€ä»£ç æ€è·¯å’Œåº”ç”¨æ¡ˆä¾‹ï¼ŒçœŸæ­£ä»é›¶å¼€å§‹è®²æ˜ç™½ï¼ï¼œå¿«é€Ÿå…¥é—¨ç³»åˆ—ï¼ - P9ï¼šL10-
    å¾ªç¯ç¥ç»ç½‘ç»œ(RNN & LSTM & GRU) - ShowMeAI - BV1TT4y1m7Xg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heyï¼Œ guysï¼Œ welcomee to another Tensorflow tutorialã€‚ Todayã€‚ we'll be learning
    about recurrent neural nets or short R and Nsã€‚ Rn Ns are a class of neural networks
    that allow previous outputs to be used as inputs while having hidden statesã€‚ So
    this means that we are working with a sequence hereã€‚ And this is super powerfulã€‚
    And with thisã€‚
  prefs: []
  type: TYPE_NORMAL
- en: we can use R and Ns for many different applications like text generation text
    translationã€‚ sentiment classification and many moreã€‚ So I already have a in depth
    tutorial about Rn Nsã€‚ where I explain these slides here in more detailã€‚ So if
    you want to learn a little bit more about the theoryã€‚ Then check out at least
    the first five minutes of this videoã€‚
  prefs: []
  type: TYPE_NORMAL
- en: because now I want to focus on the implementation with Tensorflowã€‚ So let's
    jump directly to the codeã€‚ğŸ˜Šï¼ŒğŸ¼ã€‚![](img/19e2da4a4c0b9bf65583ec48e044da69_1.png)
  prefs: []
  type: TYPE_NORMAL
- en: So here I already have some codeï¼Œ and this is the exact same code as in tutorial
    number3ã€‚ where used the Ms data setï¼Œ and then we defined a simple neural nets
    and then we defined a loss and a optimizer and compile our model and then we train
    it and evaluate itã€‚
  prefs: []
  type: TYPE_NORMAL
- en: So we did digit classification with this data setã€‚ and now the only thing we
    want to change here is to change the model and now use an R andN modelã€‚ So this
    is not the typical application for an RNã€‚ A lot of times it's used when we deal
    with text classification or text generationã€‚ but this example should demonstrate
    that RnNs can indeed be used for an image classification taskã€‚
  prefs: []
  type: TYPE_NORMAL
- en: and you will see how easily we can create our R andN model with the Kaas APIã€‚
    So as I said when we deal with R andNs then we deal with a sequence hereã€‚And in
    our caseã€‚ we have imagesï¼Œ but we don't have to change our data setã€‚ We simply
    have to treat our images as a sequence nowã€‚
  prefs: []
  type: TYPE_NORMAL
- en: So right now our images have to shape 28 by 28ï¼Œ so 28 times 28 pixelsã€‚ and now
    we treat it as a sequenceã€‚ So this means that we say one times step is one row
    in our imageã€‚ And then we also have 28 columnsã€‚ So this means that our input size
    is 28 and our sequence length is also 28ã€‚So againï¼Œ this means we have 28 time
    stepss in our sequence and in each time stepã€‚
  prefs: []
  type: TYPE_NORMAL
- en: we have 28 featuresã€‚ And now when we treat it like thisã€‚ and we can simply use
    an R and N now So now let's go ahead and define our modelã€‚ So first let's define
    a empty sequence modelã€‚ and the first thing I want to do is to add a inputã€‚ So
    I say model dot at and then careas and then inputã€‚
  prefs: []
  type: TYPE_NORMAL
- en: and then here specify the shape and this is 28 by 28ã€‚ So againã€‚ the first the
    first number here is the sequence length and the second number here is the input
    sizeã€‚ and now we can add the R and N modelã€‚ So there are different ones available
    and we start withã€‚The simple R and N layerã€‚ So later I also show you two other
    famous onesã€‚ So for nowã€‚
  prefs: []
  type: TYPE_NORMAL
- en: let's say model dot atã€‚ And then we can get this in Caras dot layersã€‚ So we
    already imported this here and then we can say layers dotã€‚ and now we want a simple
    R and N modelã€‚ And now the only thing we have to specify is the number of unitsã€‚
    So the number of output unitsã€‚And this is also the size of the hidden cellã€‚So
    there areï¼Œ of courseã€‚
  prefs: []
  type: TYPE_NORMAL
- en: a lot of more parametersã€‚ So I recommend that you check out the documentation
    for yourselvesã€‚ So one thing that you should notice that by defaultã€‚ the activation
    function in an R and N is the ton H functionã€‚ So let's in our caseã€‚ let's try
    out the relu functionã€‚And now this is all that we need for the R and N modelã€‚
  prefs: []
  type: TYPE_NORMAL
- en: So now we have thatã€‚ And nowï¼Œ as we want to do classificationsã€‚ we have 10 different
    classes in the M this data setã€‚ So then we alsoï¼Œ like in the other tutorialã€‚ we
    add a dense layer at the endã€‚ So we say layers dotã€‚Denseï¼Œ and then we want 10
    outputsã€‚ And this is all we needã€‚ So we don't use an activation function here
    at the endã€‚
  prefs: []
  type: TYPE_NORMAL
- en: But then we must be carefulï¼Œ and we must specify from logict equals true in
    our loss functionã€‚And now this is all that we need for nowã€‚ So this is the whole
    sequential model that we need for a simple R and Nã€‚ So firstï¼Œ let's import cis
    and say cis dot exit so that it runs only until hereã€‚ So let's run the code until
    here and print the summaryã€‚
  prefs: []
  type: TYPE_NORMAL
- en: So let's say Python and then the name of this fileã€‚ So this oneã€‚Ohã€‚ and here
    I missed the equal signï¼Œ of courseã€‚ So shape equals 28 by 28ã€‚ So againï¼Œ let's
    writeã€‚ And then here we see our simple R and N has this output shapeã€‚ And I explain
    this in a secondã€‚ And then we have the dense layer with 10 outputsã€‚So let's have
    another look at the R and Nsã€‚
  prefs: []
  type: TYPE_NORMAL
- en: So the output shape is nã€‚ So the number of samples that we haveã€‚ and then 128ã€‚
    like we specified hereã€‚ And what this includes is this is a single vector for
    each sampleã€‚ And the output that we get is the output of the only of theã€‚Last
    cellï¼Œ the last time stepã€‚ But this includes all the information about the previous
    time stepã€‚ So this is all that we needã€‚
  prefs: []
  type: TYPE_NORMAL
- en: So we only need this last cell hereã€‚ So this is why our output is in this shapeã€‚
    But you can also get an output of the shapeï¼Œ the number of batches times the number
    of sequencesã€‚ the number of time steps or the sequence lengthã€‚ And then the number
    of unitsã€‚ And we get this when we specify and there's an additional parameterã€‚
    and this is called returnã€‚
  prefs: []
  type: TYPE_NORMAL
- en: Return sequences equals trueã€‚ So if we use this by defaultï¼Œ it's falseã€‚ And
    if we use thisã€‚ then our output is in this shapeã€‚ And this isï¼Œ for exampleã€‚ useful
    when we want to stack multiple R and Ns togetherã€‚ Soï¼Œ for exampleï¼Œ we can use
    the first oneã€‚ which will return all the time stepsã€‚ And then we use a second
    one where we say this isã€‚Fallsã€‚
  prefs: []
  type: TYPE_NORMAL
- en: And then here we get this output shapeã€‚ So againï¼Œ let's have a look if that's
    correctã€‚ So let's clear this and run this againã€‚And yeahï¼Œ what I told you was
    correctã€‚ So the first R and N has this output shape because we said return sequences
    equals trueã€‚ And the other one has only this output shapeã€‚ And then againï¼Œ we
    have our dense layerã€‚
  prefs: []
  type: TYPE_NORMAL
- en: So this might improve the performance of your modelã€‚ So againã€‚ you can play
    around with stacking of multiple R and Nsã€‚ So let's for nowï¼Œ let's just use oneã€‚
    and then let's remove thisã€‚ and then train it and see if it performs well for
    this classification taskã€‚ So againï¼Œ let's clear this and run thisã€‚Alrightï¼Œ so
    we see that our accuracy at the end is 97%ã€‚
  prefs: []
  type: TYPE_NORMAL
- en: So our RnN indeed works well here for this image classification taskã€‚ And now
    you know how you can set up your R andN with this simple R andN layer and you
    should know how you can treat your input as a sequenceã€‚ And now I also want to
    show you two other famous RnNsã€‚ So this is only the simple RnN layerã€‚ but there's
    alsoï¼Œ for exampleï¼Œ the LSTM or the G R Uã€‚ So both are two popular RnNs as wellã€‚
  prefs: []
  type: TYPE_NORMAL
- en: they both typically perform a little bit better than the simple RnN and I think
    you don't have to change anything elseã€‚ So the parameters are mostly the same
    and also the structure of the outputs is the sameã€‚ So yeah playã€‚Around with this
    as well and try out the GRU or the LSTMã€‚And yeahã€‚ I think that's it for nowã€‚ And
    in the next tutorialã€‚
  prefs: []
  type: TYPE_NORMAL
- en: we learn how we apply this for a text classification taskã€‚ So I hope to see
    you in the next video thenã€‚ And if you enjoyed this tutorialã€‚ please hit the like
    button and consider subscribing to the channel and see you next time byeã€‚ğŸ˜Šã€‚![](img/19e2da4a4c0b9bf65583ec48e044da69_3.png)
  prefs: []
  type: TYPE_NORMAL
