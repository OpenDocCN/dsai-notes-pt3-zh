- en: 【双语字幕+资料下载】面向初学者的 TensorFlow 教程，理论知识、代码思路和应用案例，真正从零开始讲明白！＜快速入门系列＞ - P9：L10-
    循环神经网络(RNN & LSTM & GRU) - ShowMeAI - BV1TT4y1m7Xg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hey， guys， welcomee to another Tensorflow tutorial。 Today。 we'll be learning
    about recurrent neural nets or short R and Ns。 Rn Ns are a class of neural networks
    that allow previous outputs to be used as inputs while having hidden states。 So
    this means that we are working with a sequence here。 And this is super powerful。
    And with this。
  prefs: []
  type: TYPE_NORMAL
- en: we can use R and Ns for many different applications like text generation text
    translation。 sentiment classification and many more。 So I already have a in depth
    tutorial about Rn Ns。 where I explain these slides here in more detail。 So if
    you want to learn a little bit more about the theory。 Then check out at least
    the first five minutes of this video。
  prefs: []
  type: TYPE_NORMAL
- en: because now I want to focus on the implementation with Tensorflow。 So let's
    jump directly to the code。😊，🎼。![](img/19e2da4a4c0b9bf65583ec48e044da69_1.png)
  prefs: []
  type: TYPE_NORMAL
- en: So here I already have some code， and this is the exact same code as in tutorial
    number3。 where used the Ms data set， and then we defined a simple neural nets
    and then we defined a loss and a optimizer and compile our model and then we train
    it and evaluate it。
  prefs: []
  type: TYPE_NORMAL
- en: So we did digit classification with this data set。 and now the only thing we
    want to change here is to change the model and now use an R andN model。 So this
    is not the typical application for an RN。 A lot of times it's used when we deal
    with text classification or text generation。 but this example should demonstrate
    that RnNs can indeed be used for an image classification task。
  prefs: []
  type: TYPE_NORMAL
- en: and you will see how easily we can create our R andN model with the Kaas API。
    So as I said when we deal with R andNs then we deal with a sequence here。And in
    our case。 we have images， but we don't have to change our data set。 We simply
    have to treat our images as a sequence now。
  prefs: []
  type: TYPE_NORMAL
- en: So right now our images have to shape 28 by 28， so 28 times 28 pixels。 and now
    we treat it as a sequence。 So this means that we say one times step is one row
    in our image。 And then we also have 28 columns。 So this means that our input size
    is 28 and our sequence length is also 28。So again， this means we have 28 time
    stepss in our sequence and in each time step。
  prefs: []
  type: TYPE_NORMAL
- en: we have 28 features。 And now when we treat it like this。 and we can simply use
    an R and N now So now let's go ahead and define our model。 So first let's define
    a empty sequence model。 and the first thing I want to do is to add a input。 So
    I say model dot at and then careas and then input。
  prefs: []
  type: TYPE_NORMAL
- en: and then here specify the shape and this is 28 by 28。 So again。 the first the
    first number here is the sequence length and the second number here is the input
    size。 and now we can add the R and N model。 So there are different ones available
    and we start with。The simple R and N layer。 So later I also show you two other
    famous ones。 So for now。
  prefs: []
  type: TYPE_NORMAL
- en: let's say model dot at。 And then we can get this in Caras dot layers。 So we
    already imported this here and then we can say layers dot。 and now we want a simple
    R and N model。 And now the only thing we have to specify is the number of units。
    So the number of output units。And this is also the size of the hidden cell。So
    there are， of course。
  prefs: []
  type: TYPE_NORMAL
- en: a lot of more parameters。 So I recommend that you check out the documentation
    for yourselves。 So one thing that you should notice that by default。 the activation
    function in an R and N is the ton H function。 So let's in our case。 let's try
    out the relu function。And now this is all that we need for the R and N model。
  prefs: []
  type: TYPE_NORMAL
- en: So now we have that。 And now， as we want to do classifications。 we have 10 different
    classes in the M this data set。 So then we also， like in the other tutorial。 we
    add a dense layer at the end。 So we say layers dot。Dense， and then we want 10
    outputs。 And this is all we need。 So we don't use an activation function here
    at the end。
  prefs: []
  type: TYPE_NORMAL
- en: But then we must be careful， and we must specify from logict equals true in
    our loss function。And now this is all that we need for now。 So this is the whole
    sequential model that we need for a simple R and N。 So first， let's import cis
    and say cis dot exit so that it runs only until here。 So let's run the code until
    here and print the summary。
  prefs: []
  type: TYPE_NORMAL
- en: So let's say Python and then the name of this file。 So this one。Oh。 and here
    I missed the equal sign， of course。 So shape equals 28 by 28。 So again， let's
    write。 And then here we see our simple R and N has this output shape。 And I explain
    this in a second。 And then we have the dense layer with 10 outputs。So let's have
    another look at the R and Ns。
  prefs: []
  type: TYPE_NORMAL
- en: So the output shape is n。 So the number of samples that we have。 and then 128。
    like we specified here。 And what this includes is this is a single vector for
    each sample。 And the output that we get is the output of the only of the。Last
    cell， the last time step。 But this includes all the information about the previous
    time step。 So this is all that we need。
  prefs: []
  type: TYPE_NORMAL
- en: So we only need this last cell here。 So this is why our output is in this shape。
    But you can also get an output of the shape， the number of batches times the number
    of sequences。 the number of time steps or the sequence length。 And then the number
    of units。 And we get this when we specify and there's an additional parameter。
    and this is called return。
  prefs: []
  type: TYPE_NORMAL
- en: Return sequences equals true。 So if we use this by default， it's false。 And
    if we use this。 then our output is in this shape。 And this is， for example。 useful
    when we want to stack multiple R and Ns together。 So， for example， we can use
    the first one。 which will return all the time steps。 And then we use a second
    one where we say this is。Falls。
  prefs: []
  type: TYPE_NORMAL
- en: And then here we get this output shape。 So again， let's have a look if that's
    correct。 So let's clear this and run this again。And yeah， what I told you was
    correct。 So the first R and N has this output shape because we said return sequences
    equals true。 And the other one has only this output shape。 And then again， we
    have our dense layer。
  prefs: []
  type: TYPE_NORMAL
- en: So this might improve the performance of your model。 So again。 you can play
    around with stacking of multiple R and Ns。 So let's for now， let's just use one。
    and then let's remove this。 and then train it and see if it performs well for
    this classification task。 So again， let's clear this and run this。Alright， so
    we see that our accuracy at the end is 97%。
  prefs: []
  type: TYPE_NORMAL
- en: So our RnN indeed works well here for this image classification task。 And now
    you know how you can set up your R andN with this simple R andN layer and you
    should know how you can treat your input as a sequence。 And now I also want to
    show you two other famous RnNs。 So this is only the simple RnN layer。 but there's
    also， for example， the LSTM or the G R U。 So both are two popular RnNs as well。
  prefs: []
  type: TYPE_NORMAL
- en: they both typically perform a little bit better than the simple RnN and I think
    you don't have to change anything else。 So the parameters are mostly the same
    and also the structure of the outputs is the same。 So yeah play。Around with this
    as well and try out the GRU or the LSTM。And yeah。 I think that's it for now。 And
    in the next tutorial。
  prefs: []
  type: TYPE_NORMAL
- en: we learn how we apply this for a text classification task。 So I hope to see
    you in the next video then。 And if you enjoyed this tutorial。 please hit the like
    button and consider subscribing to the channel and see you next time bye。😊。![](img/19e2da4a4c0b9bf65583ec48e044da69_3.png)
  prefs: []
  type: TYPE_NORMAL
