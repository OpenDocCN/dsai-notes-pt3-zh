- en: ã€åŒè¯­å­—å¹•+èµ„æ–™ä¸‹è½½ã€‘SQLå¸¸ç”¨çŸ¥è¯†ç‚¹åˆè¾‘â€”â€”é«˜æ•ˆä¼˜é›…çš„å­¦ä¹ æ•™ç¨‹ï¼Œå¤æ‚SQLå‰–æä¸æœ€ä½³å®è·µï¼ï¼œå¿«é€Ÿå…¥é—¨ç³»åˆ—ï¼ - P14ï¼šL14- REGEXP è¿ç®—ç¬¦
    - ShowMeAI - BV1Pu41117ku
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ã€åŒè¯­å­—å¹•+èµ„æ–™ä¸‹è½½ã€‘SQLå¸¸ç”¨çŸ¥è¯†ç‚¹åˆè¾‘â€”â€”é«˜æ•ˆä¼˜é›…çš„å­¦ä¹ æ•™ç¨‹ï¼Œå¤æ‚SQLå‰–æä¸æœ€ä½³å®è·µï¼ï¼œå¿«é€Ÿå…¥é—¨ç³»åˆ—ï¼ - P14ï¼šL14- REGEXP è¿ç®—ç¬¦
    - ShowMeAI - BV1Pu41117ku
- en: In the last tutorial you learn about the like operator in SQLï¼Œ so as another
    exampleã€‚ let's say we want to search for the customers who have the word filled
    in their last nameã€‚ so we type out a where clause like this where last name like
    percentï¼Œ field percentã€‚So the word field can be anywhere in the last nameã€‚ Let's
    execute this queryã€‚
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šä¸€ä¸ªæ•™ç¨‹ä¸­ï¼Œä½ å­¦ä¹ äº† SQL ä¸­çš„ like è¿ç®—ç¬¦ï¼Œå› æ­¤ä½œä¸ºå¦ä¸€ä¸ªä¾‹å­ã€‚å‡è®¾æˆ‘ä»¬æƒ³æœç´¢å§“æ°ä¸­åŒ…å«å•è¯ filled çš„å®¢æˆ·ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è¾“å…¥ä¸€ä¸ªç±»ä¼¼äºè¿™æ ·çš„
    where å­å¥ï¼šwhere last name like percentï¼Œfield percentã€‚è¿™æ ·å•è¯ field å¯ä»¥å‡ºç°åœ¨å§“æ°çš„ä»»ä½•ä½ç½®ã€‚è®©æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ã€‚
- en: We get only one customer beautifulã€‚ Nowï¼Œ we also have another operator in myql
    that is red Xã€‚ğŸ˜Šã€‚Which is short for regular expressionï¼Œ and regular expressions
    are extremely powerful when it comes to searching for stringsã€‚ So they allow us
    to search for more complex patternsã€‚ Here is an exampleã€‚ If I want to rewrite
    this last word clause using a regular expressionï¼Œ it looks like thisã€‚
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åªå¾—åˆ°ä¸€ä¸ªå®¢æˆ·ï¼Œå¾ˆå¥½ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬åœ¨ MySQL ä¸­è¿˜æœ‰å¦ä¸€ä¸ªè¿ç®—ç¬¦ï¼Œå³ red Xã€‚ğŸ˜Šå®ƒæ˜¯æ­£åˆ™è¡¨è¾¾å¼çš„ç¼©å†™ï¼Œæ­£åˆ™è¡¨è¾¾å¼åœ¨æœç´¢å­—ç¬¦ä¸²æ—¶éå¸¸å¼ºå¤§ã€‚å› æ­¤ï¼Œå®ƒä»¬å…è®¸æˆ‘ä»¬æœç´¢æ›´å¤æ‚çš„æ¨¡å¼ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªä¾‹å­ã€‚å¦‚æœæˆ‘æƒ³ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼é‡å†™è¿™ä¸ªæœ€åçš„
    where å­å¥ï¼Œå®ƒçœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ã€‚
- en: where last nameï¼Œ R A Gï¼Œ E X Pã€‚ğŸ˜Šï¼ŒNow here in our string patternã€‚ we don't have
    to type out the person signsï¼Œ we only type out fieldã€‚So what we have on line 4
    is exactly identical to what we have on line 3ã€‚ Let's execute this queryã€‚ğŸ˜Šã€‚We
    get the same result beautifuliã€‚ Now here in regular expressionsã€‚
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: where last nameï¼ŒR A Gï¼ŒE X Pã€‚ğŸ˜Šç°åœ¨åœ¨æˆ‘ä»¬çš„å­—ç¬¦ä¸²æ¨¡å¼ä¸­ï¼Œæˆ‘ä»¬ä¸éœ€è¦è¾“å…¥äººåç¬¦å·ï¼Œæˆ‘ä»¬åªéœ€è¾“å…¥ fieldã€‚æ‰€ä»¥ç¬¬4è¡Œçš„å†…å®¹ä¸ç¬¬3è¡Œå®Œå…¨ç›¸åŒã€‚è®©æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ã€‚ğŸ˜Šæˆ‘ä»¬å¾—åˆ°äº†ç›¸åŒçš„ç»“æœï¼Œå¾ˆå¥½ã€‚ç°åœ¨åœ¨æ­£åˆ™è¡¨è¾¾å¼ä¸­ã€‚
- en: we have additional characters that we don't have when we use the like operatorã€‚
    For exampleã€‚ we can use the carrot sign to indicate the beginning of a stringã€‚
    So if I put a carrot just before the word filledã€‚ğŸ˜Šã€‚That means our last name must
    start with field Obviouslyï¼Œ if we execute this queryã€‚
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰é¢å¤–çš„å­—ç¬¦ï¼Œè€Œåœ¨ä½¿ç”¨ like è¿ç®—ç¬¦æ—¶å¹¶æ²¡æœ‰è¿™äº›å­—ç¬¦ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ’å…¥ç¬¦å·æ¥è¡¨ç¤ºå­—ç¬¦ä¸²çš„å¼€å¤´ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘æŠŠæ’å…¥ç¬¦å·æ”¾åœ¨å•è¯ filled
    å‰é¢ã€‚ğŸ˜Šè¿™æ„å‘³ç€æˆ‘ä»¬çš„å§“å¿…é¡»ä»¥ field å¼€å¤´ã€‚æ˜¾ç„¶ï¼Œå¦‚æœæˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ã€‚
- en: we don't get anyone that matches this criteriaï¼Œ so we use the carrot sign to
    represent the beginning of a stringã€‚ğŸ˜Šï¼ŒWe also have a dollar sign to represent
    the end of a stringã€‚ so this pattern means the last name must end with fieldã€‚
    Let's execute this queryã€‚ We get the same result as beforeã€‚Now we can also search
    for multiple words hereã€‚ For exampleã€‚
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ²¡æœ‰ä»»ä½•åŒ¹é…è¯¥æ¡ä»¶çš„è®°å½•ï¼Œå› æ­¤æˆ‘ä»¬ä½¿ç”¨æ’å…¥ç¬¦å·è¡¨ç¤ºå­—ç¬¦ä¸²çš„å¼€å¤´ã€‚ğŸ˜Šæˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ç¾å…ƒç¬¦å·è¡¨ç¤ºå­—ç¬¦ä¸²çš„ç»“å°¾ã€‚å› æ­¤ï¼Œè¿™ä¸ªæ¨¡å¼æ„å‘³ç€å§“æ°å¿…é¡»ä»¥ field
    ç»“å°¾ã€‚è®©æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ã€‚æˆ‘ä»¬å¾—åˆ°äº†ä¸ä¹‹å‰ç›¸åŒçš„ç»“æœã€‚ç°åœ¨æˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨è¿™é‡Œæœç´¢å¤šä¸ªå•è¯ã€‚ä¾‹å¦‚ã€‚
- en: let's say we want to find the customers who have the words filled or Mac in
    their last nameã€‚ So we use a pipeï¼Œ a vertical bar and type out another patternã€‚ğŸ˜Šï¼ŒLet's
    execute this queryã€‚So here we have two customersï¼Œ one of them has the word Macã€‚
    the other has the word field in their last nameã€‚ğŸ˜Šï¼ŒNow we can take this to the
    next levelã€‚
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æƒ³æ‰¾åˆ°å§“æ°ä¸­åŒ…å«å•è¯ filled æˆ– Mac çš„å®¢æˆ·ã€‚å› æ­¤æˆ‘ä»¬ä½¿ç”¨ç®¡é“ç¬¦å·ï¼Œç«–çº¿å¹¶è¾“å…¥å¦ä¸€ä¸ªæ¨¡å¼ã€‚ğŸ˜Šè®©æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªå®¢æˆ·ï¼Œå…¶ä¸­ä¸€ä¸ªçš„å§“ä¸­æœ‰å•è¯
    Macï¼Œå¦ä¸€ä¸ªçš„å§“ä¸­æœ‰å•è¯ fieldã€‚ğŸ˜Šç°åœ¨æˆ‘ä»¬å¯ä»¥å°†å…¶æå‡åˆ°ä¸‹ä¸€ä¸ªå±‚æ¬¡ã€‚
- en: let's say we want to find the customers who have the words field or Mac or row
    and their last nameã€‚ğŸ˜Šï¼ŒLet's execute the queryã€‚ We get three customersï¼Œ beautifulã€‚
    So we use a pipe or a vertical bar to represent multiple search patternsã€‚ Nowï¼Œ
    as another exampleã€‚ we can change our first search pattern to something like thisã€‚ğŸ˜Šã€‚
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æƒ³æ‰¾åˆ°å§“æ°ä¸­åŒ…å«å•è¯ fieldã€Mac æˆ– row çš„å®¢æˆ·ã€‚ğŸ˜Šè®©æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ã€‚æˆ‘ä»¬å¾—åˆ°äº†ä¸‰ä¸ªå®¢æˆ·ï¼Œå¾ˆå¥½ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨ç®¡é“ç¬¦å·æˆ–ç«–çº¿æ¥è¡¨ç¤ºå¤šä¸ªæœç´¢æ¨¡å¼ã€‚ç°åœ¨ï¼Œä½œä¸ºå¦ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç¬¬ä¸€ä¸ªæœç´¢æ¨¡å¼æ›´æ”¹ä¸ºç±»ä¼¼è¿™æ ·çš„å†…å®¹ã€‚ğŸ˜Š
- en: Now this pattern means the last name should either start with the word field
    or it should have the wordm it or it should have the word rowã€‚ let's execute the
    queryã€‚ğŸ˜Šï¼ŒNow we get only two customers because our customer with the last nameã€‚
    Bru fieldï¼Œ doesn't match this patternã€‚Howeverï¼Œ if we change our first pattern
    to field dollar sign and execute the queryã€‚ we get three people hereï¼Œ three customersã€‚So
    this is how we can combine multiple special characters when building a complex
    patternã€‚
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è¿™ä¸ªæ¨¡å¼æ„å‘³ç€å§“æ°è¦ä¹ˆä»¥ field å¼€å¤´ï¼Œè¦ä¹ˆåŒ…å«å•è¯ fieldï¼Œè¦ä¹ˆåŒ…å«å•è¯ rowã€‚è®©æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ã€‚ğŸ˜Šç°åœ¨æˆ‘ä»¬åªå¾—åˆ°äº†ä¸¤ä¸ªå®¢æˆ·ï¼Œå› ä¸ºæˆ‘ä»¬çš„å®¢æˆ·å§“
    Bru fieldï¼Œä¸ç¬¦åˆè¿™ä¸ªæ¨¡å¼ã€‚ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬å°†ç¬¬ä¸€ä¸ªæ¨¡å¼æ”¹ä¸º field åŠ ä¸Šç¾å…ƒç¬¦å·å¹¶æ‰§è¡ŒæŸ¥è¯¢ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸‰ä¸ªå®¢æˆ·ã€‚æ‰€ä»¥è¿™å°±æ˜¯æˆ‘ä»¬åœ¨æ„å»ºå¤æ‚æ¨¡å¼æ—¶å¦‚ä½•ç»„åˆå¤šä¸ªç‰¹æ®Šå­—ç¬¦ã€‚
- en: Now let's look at another exampleï¼Œ let's say we want to search for customers
    who have an E in their last nameã€‚So these are all the people alright now let's
    say we want to make sure that before the letter E we should either have a G or
    an Iã€‚ so this is where we use square brackets and inside the brackets we add multiple
    characters like G IM and that matches any customers who have G or Ie or ME in
    their last name so any of these characters can come before Eã€‚ğŸ˜Šï¼ŒNow let's execute
    this queryã€‚There you goï¼Œ we only get two customers in the first example before
    E we have Iã€‚
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬æ¥çœ‹å¦ä¸€ä¸ªä¾‹å­ï¼Œå‡è®¾æˆ‘ä»¬æƒ³è¦æœç´¢å§“æ°ä¸­åŒ…å«Eçš„å®¢æˆ·ã€‚è¿™äº›éƒ½æ˜¯ç¬¦åˆæ¡ä»¶çš„äººï¼Œç°åœ¨å‡è®¾æˆ‘ä»¬æƒ³ç¡®ä¿åœ¨å­—æ¯Eä¹‹å‰è¦ä¹ˆæœ‰Gï¼Œè¦ä¹ˆæœ‰Iã€‚æ‰€ä»¥è¿™å°±æ˜¯æˆ‘ä»¬ä½¿ç”¨æ–¹æ‹¬å·çš„åœ°æ–¹ï¼Œæ‹¬å·å†…æ·»åŠ å¤šä¸ªå­—ç¬¦ï¼Œå¦‚Gå’ŒIï¼Œè¿™æ ·å°±èƒ½åŒ¹é…ä»»ä½•å§“æ°ä¸­åœ¨Eä¹‹å‰æœ‰Gæˆ–Iæˆ–Mçš„å®¢æˆ·ï¼Œå› æ­¤è¿™äº›å­—ç¬¦ä¸­çš„ä»»ä½•ä¸€ä¸ªéƒ½å¯ä»¥åœ¨Eä¹‹å‰å‡ºç°ã€‚ğŸ˜Šç°åœ¨è®©æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ã€‚çœ‹å§ï¼Œæˆ‘ä»¬åœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­åªå¾—åˆ°ä¸¤ä¸ªå®¢æˆ·ï¼Œåœ¨Eä¹‹å‰æˆ‘ä»¬æœ‰Iã€‚
- en: which is one of the characters inside the brackets in the second example before
    E we have a G which is also another valid character before Eã€‚Nowï¼Œ once againï¼Œ
    the square brackets don't have to be before Eï¼Œ we could add them after Eã€‚ so any
    customers who have E followed by an F or an M or a Q in their last nameã€‚Can be
    returned with this patternã€‚ Obviouslyï¼Œ we don't have anyone in the database So
    this is how we use square bracketsã€‚
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç¬¬äºŒä¸ªä¾‹å­ä¸­ï¼ŒEä¹‹å‰çš„æ–¹æ‹¬å·å†…åŒ…å«çš„å­—ç¬¦ä¹‹ä¸€æ˜¯Gï¼Œå®ƒä¹Ÿæ˜¯Eä¹‹å‰çš„å¦ä¸€ä¸ªæœ‰æ•ˆå­—ç¬¦ã€‚ç°åœ¨ï¼Œå†ä¸€æ¬¡ï¼Œæ–¹æ‹¬å·ä¸å¿…åœ¨Eä¹‹å‰ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶æ”¾åœ¨Eä¹‹åï¼Œå› æ­¤ä»»ä½•åœ¨å§“æ°ä¸­ä»¥Eåè·ŸFã€Mæˆ–Qçš„å®¢æˆ·éƒ½å¯ä»¥ç”¨è¿™ä¸ªæ¨¡å¼è¿”å›ã€‚æ˜¾ç„¶ï¼Œæˆ‘ä»¬çš„æ•°æ®åº“ä¸­æ²¡æœ‰äººã€‚æ‰€ä»¥è¿™å°±æ˜¯æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨æ–¹æ‹¬å·ã€‚
- en: So we can also supply a range of charactersã€‚ For exampleï¼Œ we can have E and
    just before Eã€‚ we want to have any characters from A to H We don't have to type
    them out explicitly like ABï¼ŒCï¼Œ Dã€‚ Eï¼Œ FGï¼Œ that's very verbos so we can type out
    a to H and now if you execute this queryã€‚ we get these three peopleã€‚ğŸ˜Šï¼ŒSo let's
    quickly recap everything you learn about regular expressions in this tutorialã€‚
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥æˆ‘ä»¬ä¹Ÿå¯ä»¥æä¾›å­—ç¬¦èŒƒå›´ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥æœ‰Eï¼ŒEä¹‹å‰è¦æœ‰ä»»ä½•ä»Aåˆ°Hçš„å­—ç¬¦ã€‚æˆ‘ä»¬ä¸å¿…åƒABã€Cã€Dã€Eã€FGé‚£æ ·é€ä¸€è¾“å…¥ï¼Œè¿™æ ·æ˜¾å¾—å¾ˆå†—é•¿ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¾“å…¥Aåˆ°Hï¼Œç°åœ¨å¦‚æœä½ æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ï¼Œæˆ‘ä»¬å¾—åˆ°è¿™ä¸‰ä¸ªäººã€‚ğŸ˜Šè®©æˆ‘ä»¬å¿«é€Ÿå›é¡¾ä¸€ä¸‹åœ¨æœ¬æ•™ç¨‹ä¸­ä½ å­¦åˆ°çš„å…³äºæ­£åˆ™è¡¨è¾¾å¼çš„æ‰€æœ‰å†…å®¹ã€‚
- en: We use a carrot to represent the beginning of a stringï¼Œ so beginningã€‚ğŸ˜Šã€‚We use
    a dollar sign to represent the end of our stringã€‚We use a vertical bar or a pipe
    to represent a logical orï¼Œ so we can supply multiple search patternsã€‚We use square
    brackets to match any single characters listed in the bracketsã€‚
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨æ’å…¥ç¬¦å·æ¥è¡¨ç¤ºå­—ç¬¦ä¸²çš„å¼€å§‹ï¼Œæ‰€ä»¥æ˜¯å¼€å§‹ã€‚ğŸ˜Šæˆ‘ä»¬ä½¿ç”¨ç¾å…ƒç¬¦å·è¡¨ç¤ºå­—ç¬¦ä¸²çš„ç»“æŸã€‚æˆ‘ä»¬ä½¿ç”¨ç«–çº¿æˆ–ç®¡é“è¡¨ç¤ºé€»è¾‘æˆ–ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æä¾›å¤šä¸ªæœç´¢æ¨¡å¼ã€‚æˆ‘ä»¬ä½¿ç”¨æ–¹æ‹¬å·æ¥åŒ¹é…æ‹¬å·ä¸­åˆ—å‡ºçš„ä»»ä½•å•ä¸ªå­—ç¬¦ã€‚
- en: and finally we use square brackets with a hyphen to represent a rangeï¼Œ so any
    characters from A toã€‚ let's say Fã€‚ğŸ˜Šï¼ŒNow technicallyï¼Œ my school supports more special
    charactersï¼Œ but quite honestlyã€‚ the ones that I have listed in this tutorial are
    the ones that you will be using 90% of the timeã€‚ so just memorize these and you're
    good to goã€‚Qu honestlyã€‚
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åæˆ‘ä»¬ä½¿ç”¨æ–¹æ‹¬å·å’Œä¸€ä¸ªè¿å­—ç¬¦æ¥è¡¨ç¤ºä¸€ä¸ªèŒƒå›´ï¼Œæ‰€ä»¥ä»»ä½•ä»Aåˆ°Fçš„å­—ç¬¦ã€‚ğŸ˜Šä»æŠ€æœ¯ä¸Šè®²ï¼Œæˆ‘çš„å­¦æ ¡æ”¯æŒæ›´å¤šç‰¹æ®Šå­—ç¬¦ï¼Œä½†è€å®è¯´ï¼Œæˆ‘åœ¨æœ¬æ•™ç¨‹ä¸­åˆ—å‡ºçš„é‚£äº›æ˜¯ä½ åœ¨90%çš„æƒ…å†µä¸‹ä¼šç”¨åˆ°çš„ï¼Œæ‰€ä»¥è®°ä½è¿™äº›å°±å¯ä»¥äº†ã€‚è¯´å®è¯ã€‚
- en: a lot of beginners find the syntax for regular expressions confusingã€‚ So in
    this videoã€‚ I'm going to give you four exercises that I have carefully designed
    to help you quickly learn about this syntaxã€‚ Here's the first exerciseã€‚ Get the
    customers whose first names are Elca or Amberã€‚ and note that this is Amber with
    youã€‚ğŸ˜Šï¼ŒNow for the second exerciseã€‚
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ˆå¤šåˆå­¦è€…å‘ç°æ­£åˆ™è¡¨è¾¾å¼çš„è¯­æ³•ä»¤äººå›°æƒ‘ã€‚å› æ­¤ï¼Œåœ¨è¿™ä¸ªè§†é¢‘ä¸­ï¼Œæˆ‘å°†ç»™ä½ å››ä¸ªç»ƒä¹ ï¼Œæˆ‘ç²¾å¿ƒè®¾è®¡äº†è¿™äº›ç»ƒä¹ ï¼Œä»¥å¸®åŠ©ä½ å¿«é€Ÿäº†è§£è¿™å¥—è¯­æ³•ã€‚è¿™æ˜¯ç¬¬ä¸€ä¸ªç»ƒä¹ ã€‚è·å–åå­—æ˜¯Elcaæˆ–Amberçš„å®¢æˆ·ã€‚æ³¨æ„è¿™ä¸ªæ˜¯Amberçš„æ‹¼å†™ã€‚ğŸ˜Šç°åœ¨æ˜¯ç¬¬äºŒä¸ªç»ƒä¹ ã€‚
- en: return the customers whose last names and with EY or ONã€‚Here's the third exerciseã€‚
    get the customers whose last namesï¼Œ start with myï¼Œ or it contains SEã€‚ and finally
    as the last exercise return the customers whose last names contain B followed
    by R or U so go ahead and spend two to three minutes on this exercise when you
    are done come back continue watchingã€‚
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: è¿”å›å§“æ°ä»¥EYæˆ–ONç»“å°¾çš„å®¢æˆ·ã€‚è¿™æ˜¯ç¬¬ä¸‰ä¸ªç»ƒä¹ ã€‚è·å–å§“æ°ä»¥myå¼€å¤´æˆ–åŒ…å«SEçš„å®¢æˆ·ã€‚æœ€åä½œä¸ºæœ€åä¸€ä¸ªç»ƒä¹ ï¼Œè¿”å›å§“æ°ä¸­åŒ…å«Båè·ŸRæˆ–Uçš„å®¢æˆ·ã€‚è¯·èŠ±ä¸¤åˆ°ä¸‰åˆ†é’Ÿå®Œæˆè¿™ä¸ªç»ƒä¹ ï¼Œå®Œæˆåè¯·å›æ¥ç»§ç»­è§‚çœ‹ã€‚
- en: '![](img/8d0f5cdee26cc78209f65c1aaae9a244_1.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d0f5cdee26cc78209f65c1aaae9a244_1.png)'
- en: '![](img/8d0f5cdee26cc78209f65c1aaae9a244_2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d0f5cdee26cc78209f65c1aaae9a244_2.png)'
- en: Alrightï¼Œ let's knock out the first exerciseã€‚ So we want to get allã€‚ğŸ˜Šï¼ŒOopsï¼Œ there's
    a C hereã€‚ select store from customers where first nameï¼Œ regular expressionã€‚ğŸ˜Šï¼ŒAnd
    here's our patternã€‚ we want to search for two wordssï¼Œ either Elca or Amberï¼Œ as
    simple as thatï¼Œ let's execute this queryã€‚We should get two customersã€‚ There you
    go Amber and Elcaã€‚ Allrightã€‚
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½çš„ï¼Œè®©æˆ‘ä»¬å®Œæˆç¬¬ä¸€ä¸ªç»ƒä¹ ã€‚æ‰€ä»¥æˆ‘ä»¬æƒ³è¦è·å–æ‰€æœ‰ã€‚ğŸ˜Šï¼Œå“å‘€ï¼Œè¿™é‡Œæœ‰ä¸ªCã€‚é€‰æ‹©å•†åº—ä»å®¢æˆ·ä¸­ï¼Œæ­£åˆ™è¡¨è¾¾å¼ã€‚ğŸ˜Šï¼Œè¿™æ˜¯æˆ‘ä»¬çš„æ¨¡å¼ã€‚æˆ‘ä»¬æƒ³æœç´¢ä¸¤ä¸ªè¯ï¼ŒElcaæˆ–Amberï¼Œç®€å•å°±æ˜¯è¿™æ ·ï¼Œè®©æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ã€‚æˆ‘ä»¬åº”è¯¥å¾—åˆ°ä¸¤ä¸ªå®¢æˆ·ã€‚çœ‹ï¼ŒAmberå’ŒElcaã€‚å¥½çš„ã€‚
- en: now let's knock out the second an exerciseï¼Œ so I'm going to delete thisã€‚ We
    don't need it anymoreã€‚ğŸ˜Šã€‚So we want to get the customersï¼Œ select start fromCustomã€‚Where
    last nameï¼Ÿ
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬å®Œæˆç¬¬äºŒä¸ªç»ƒä¹ ï¼Œæˆ‘è¦åˆ é™¤è¿™ä¸ªã€‚æˆ‘ä»¬ä¸å†éœ€è¦å®ƒã€‚ğŸ˜Šã€‚æ‰€ä»¥æˆ‘ä»¬æƒ³è¦è·å–å®¢æˆ·ï¼Œé€‰æ‹©ä»Customå¼€å§‹ã€‚å“ªé‡Œå§“æ°ï¼Ÿ
- en: Should end with either EY or ONã€‚So in the search patternã€‚ we type out EY followed
    by a dollar sign to indicate the end of a stringã€‚ then we add a vertical bar to
    supply the second search patternï¼Œ So O and once againï¼Œ a dollar signã€‚Let's execute
    this queryï¼Œ oopsï¼Œ actually I forgot to type out regular expressionï¼Œ there you
    goã€‚ğŸ˜Šã€‚
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: åº”è¯¥ä»¥EYæˆ–ONç»“å°¾ã€‚æ‰€ä»¥åœ¨æœç´¢æ¨¡å¼ä¸­ã€‚æˆ‘ä»¬è¾“å…¥EYåé¢è·Ÿä¸€ä¸ªç¾å…ƒç¬¦å·æ¥è¡¨ç¤ºå­—ç¬¦ä¸²çš„ç»“æŸã€‚ç„¶åæˆ‘ä»¬æ·»åŠ ä¸€ä¸ªç«–çº¿æ¥æä¾›ç¬¬äºŒä¸ªæœç´¢æ¨¡å¼ï¼ŒOï¼Œå†ä¸€æ¬¡ï¼Œç¾å…ƒç¬¦å·ã€‚è®©æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ï¼Œå“å‘€ï¼Œå®é™…ä¸Šæˆ‘å¿˜è®°è¾“å…¥æ­£åˆ™è¡¨è¾¾å¼äº†ï¼Œä½ çœ‹ã€‚ğŸ˜Šã€‚
- en: So let's execute this queryã€‚And we should getã€‚These four customers with IDs
    1ï¼Œ3ï¼Œ5 and 7ã€‚ the first threeï¼Œ their last names end with E Y and the last customerã€‚
    his or her last name ends with ON All rightã€‚Nowï¼Œ let's work on the third exerciseã€‚
    So I'm just going to change the regular expression hereã€‚
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è®©æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ªæŸ¥è¯¢ã€‚æˆ‘ä»¬åº”è¯¥å¾—åˆ°è¿™å››ä½å®¢æˆ·ï¼ŒIDä¸º1ã€3ã€5å’Œ7ã€‚å‰é¢çš„ä¸‰ä½ï¼Œä»–ä»¬çš„å§“æ°ä»¥Eã€Yç»“å°¾ï¼Œæœ€åä¸€ä½å®¢æˆ·ï¼Œä»–æˆ–å¥¹çš„å§“æ°ä»¥ONç»“å°¾ã€‚å¥½çš„ï¼Œç°åœ¨ï¼Œè®©æˆ‘ä»¬è¿›è¡Œç¬¬ä¸‰ä¸ªç»ƒä¹ ã€‚æˆ‘å°†æ›´æ”¹è¿™é‡Œçš„æ­£åˆ™è¡¨è¾¾å¼ã€‚
- en: We want to get the customers whose last name starts with my or contains Sã€‚ So
    we use a character to indicate the beginning of a stringã€‚ğŸ˜Šï¼ŒSo it should start
    with myã€‚ or it should contain S again very easyï¼Œ lets execute the queryã€‚ğŸ˜Šï¼ŒAnd
    we get the customers with ID 4ã€‚8 and 10ï¼Œ and finally we want to get the customers
    whose last names contained Bã€‚
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æƒ³è¦è·å–å§“æ°ä»¥myå¼€å¤´æˆ–åŒ…å«Sçš„å®¢æˆ·ã€‚æ‰€ä»¥æˆ‘ä»¬ç”¨ä¸€ä¸ªå­—ç¬¦æ¥è¡¨ç¤ºå­—ç¬¦ä¸²çš„å¼€å§‹ã€‚ğŸ˜Šï¼Œæ‰€ä»¥å®ƒåº”è¯¥ä»¥myå¼€å¤´ã€‚æˆ–è€…å®ƒåº”è¯¥å†æ¬¡åŒ…å«Sï¼Œå¾ˆç®€å•ï¼Œè®©æˆ‘ä»¬æ‰§è¡ŒæŸ¥è¯¢ã€‚ğŸ˜Šï¼Œæˆ‘ä»¬å¾—åˆ°äº†IDä¸º4ã€8å’Œ10çš„å®¢æˆ·ï¼Œæœ€åæˆ‘ä»¬æƒ³è·å–å§“æ°ä¸­åŒ…å«Bçš„å®¢æˆ·ã€‚
- en: so let's change the search patternï¼Œ we should have a B followed by R or Uã€‚Nowã€‚
    there are two ways to write this regular expressionã€‚ We can use square bracketã€‚
    So we have B followed by R or Uã€‚ That's one wayã€‚ The other way is to use a vertical
    barï¼Œ soã€‚BR or BUï¼Œ these are both valid solutionsã€‚So I hope you knocked out these
    exercises in the next tutorial I'm going to show you how to get the records with
    missing valuesã€‚
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è®©æˆ‘ä»¬æ›´æ”¹æœç´¢æ¨¡å¼ï¼Œæˆ‘ä»¬åº”è¯¥æœ‰Båé¢è·ŸRæˆ–Uã€‚ç°åœ¨ï¼Œæœ‰ä¸¤ç§æ–¹å¼æ¥å†™è¿™ä¸ªæ­£åˆ™è¡¨è¾¾å¼ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ–¹æ‹¬å·ã€‚æ‰€ä»¥æˆ‘ä»¬æœ‰Båé¢è·ŸRæˆ–Uã€‚è¿™æ˜¯ä¸€ç§æ–¹æ³•ã€‚å¦ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ç«–çº¿ï¼Œæ‰€ä»¥ã€‚BRæˆ–BUï¼Œè¿™ä¸¤è€…éƒ½æ˜¯æœ‰æ•ˆçš„è§£å†³æ–¹æ¡ˆã€‚å¸Œæœ›ä½ åœ¨ä¸‹ä¸€ä¸ªæ•™ç¨‹ä¸­å®Œæˆè¿™äº›ç»ƒä¹ ï¼Œæˆ‘å°†å‘ä½ å±•ç¤ºå¦‚ä½•è·å–ç¼ºå¤±å€¼çš„è®°å½•ã€‚
- en: ğŸ˜Šã€‚![](img/8d0f5cdee26cc78209f65c1aaae9a244_4.png)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ˜Šã€‚![](img/8d0f5cdee26cc78209f65c1aaae9a244_4.png)
- en: Ohã€‚
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: å“¦ã€‚
