# PyTorch 极简实战教程！P22：L22- PyTorch Lightning：专门为机器学习研究者开发的PyTorch轻量包装器 

嘿，大家，欢迎来到你们的新Pytor教程。今天，我们将讨论Pytor Lightning。Pytorch Lightning是一个轻量级的Pytor包装器。它旨在减少样板代码，以便实现算法和改进模型。因此，调整和优化可以更快。你不需要记住Pytor框架的所有细节，因为Lightning会处理这些。😊，另一个很棒的特点是它会打印警告，并给你有用的机器学习提示或建议。

如果你犯错误。我们稍后会看到这一切。通常，当涉及到抽象很多内容的包装框架时，我持怀疑态度。但这次，我真的可以推荐它。我仍然建议你首先学习基础知识。如果你还没有学习过，可以在YouTube上查看我的免费Pytorch课程。

链接在描述中。但如果你已经熟悉Pytorch，那么你可以查看Pytorch Lightning，看看你是否喜欢它。因此今天，我将把我的Pytor课程中的一段代码转换为Pytorch Lightning。这样你就能感受到这个框架的工作原理以及如何使用它。好的，让我们开始吧。

首先，Pytorch Lightning是开源的。你可以在Github上找到它。他们还有一个网站，提供良好的文档，帮助你入门。我会放上。😊！[](img/8f1dbba751e44013b8cee2c7d55082c5_1.png)

描述中的链接也是如此。而现在，这里有一些关于Pytorch Lightning的细节，你不再需要担心的。因此，你不再需要担心何时将模型设置为训练或评估模式，你也不必担心使用设备进行GPU支持，然后将模型和所有张量推送到设备上。你可以轻松关闭GPU或甚至不使用GPU支持，使用Lightning可以轻松扩展。此外，你也不再需要关心零梯度或调用反向传播和优化步骤，你也不需要担心使用torch.no_grad或detach，作为额外奖励，你还有张量或支持集成。

它还会打印提示或提示，我们稍后会看到。让我们跳到代码。这次示例中，我们将从我的Pytorch教程中提取一段代码。你可以在Github上找到它，然后在这种情况下，我们取教程编号13。这是一个简单的前馈神经网络，应用于MNIST数据集进行数字分类。

现在，让我们抓取一些代码，并用Pytorch Lightning编写新代码。首先，我来删除这个，现在我们从一个新的Python脚本开始。顺便说一下，当你想安装Pytorch Lightning时，有两个常见的选择。第一个是使用Pip。所以你只需说Pip install Pytorch Lightning。或者如果你在Conda中使用。

然后你可以抓取这个命令。![](img/8f1dbba751e44013b8cee2c7d55082c5_3.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_4.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_5.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_6.png)

我已经在我的终端中完成了这个操作。所以Pytorch lightning已经在这里导入了。现在让我们回到代码中，复制粘贴一些内容。我们希望有所有相同的导入语句。![](img/8f1dbba751e44013b8cee2c7d55082c5_8.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_9.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_10.png)

作为补充，我们现在还导入了Pytorch lightning。所以我们说导入带下划线的Pytorch lightning。![](img/8f1dbba751e44013b8cee2c7d55082c5_12.png)

现在我们想将我们的模型、神经网络转换为一个lightning模型。所以我们抓取这段代码，然后把它复制粘贴到这里。现在我们不再从N和dot模块派生，而是从P dot lightning模块派生。这将给我们原始模型的相同功能，但还会提供一些更多的功能，我们稍后将看到。

现在in it函数仍然是相同的，forward函数也仍然是相同的。所以我们需要所有的超参数。让我们抓取这些超参数并粘贴到这里。😊。![](img/8f1dbba751e44013b8cee2c7d55082c5_14.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_15.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_16.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_17.png)

现在我们需要实现一些更多的函数。所以让我们快速访问一下官方网站。在这里，你会看到一步一步的指南，顺便提一下，你还有一个很好的比较，Pytorch代码与Pytorch lightning的区别，以及它抽象了什么。因此，如你所见，我们还需要定义一个训练步骤。

一个配置优化器函数和一个训练数据加载器。所以让我们把这些全部复制到这里。![](img/8f1dbba751e44013b8cee2c7d55082c5_19.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_20.png)

现在，对于最简单的配置优化器，你只需放入你创建的优化器。所以在我们原始脚本中，我们在这里设置了优化器。这是原子优化器。然后返回它。所以我们可以在一行中返回这个。这将是我们的优化器。

我们的原子优化器与超参数中的学习率。![](img/8f1dbba751e44013b8cee2c7d55082c5_22.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_23.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_24.png)

然后我们想要实现训练步骤。![](img/8f1dbba751e44013b8cee2c7d55082c5_26.png)

对于训练步骤，我们正在做的正是我们在训练循环中所做的。现在我们不再需要担心关于解包图像和标签的循环，以及优化器如何进行反向传播和步骤。

所以我们简单地抓取这一部分。![](img/8f1dbba751e44013b8cee2c7d55082c5_28.png)

并粘贴到这里。如你所见，在训练步骤函数中，我们获得一个批次和一个批次索引。因此我们将批次解包为x和y。让我复制代码。因此。这就是我们的图像和标签。然后我们需要重新调整图像的形状。并且我们不再需要将其推送到设备。因此我们移除所有这些内容。

然后我们进行前向传递。在这里我们实际上可以使用self，因为我们在模型类内部。![](img/8f1dbba751e44013b8cee2c7d55082c5_30.png)

然后我们应用标准。 在我们原来的代码中，我们将标准设置为N和dot交叉熵。但如果使用功能模块，我们也可以用它。因此，我们说。![](img/8f1dbba751e44013b8cee2c7d55082c5_32.png)

导入torch的N，N，dot funk。Channel S F。然后在这里，我们说我们的损失等于。现在我们可以调用F dot交叉熵与我们的输出和标签。这些都是我们所需的。而现在，我们只想返回一个包含这个损失的字典。因此PyTorch Lightning需要这个字典，以便在训练过程中显示损失。

这就是我们训练步骤中所需的一切。然后我们还必须实现训练数据加载器函数。我们想在这里做的就是回到开始时设置训练数据集和训练数据加载器。

所以我们复制这个并粘贴到这个函数里。因此首先是我们的训练数据集。这就是这个。然后是训练数据加载器。这一个。![](img/8f1dbba751e44013b8cee2c7d55082c5_34.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_35.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_36.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_37.png)

然后我们想要返回训练数据加载器或训练加载器。现在这就是我们开始训练所需的一切。接下来我们要做的是，如果`__name__`等于`__main__`，那么我们需要设置一个Lightning训练器。因此，我们导入一个训练器。我们说从Pytorch Lightning导入训练器。

然后我们想设置一个训练器。因此在这里我们说我们的训练器等于我们的Lightning训练器。现在，我可以给你展示一个在开发过程中非常有用的技巧。因此你说`fast_dev_run`等于`True`。这将通过训练和验证运行一个批次。如果我们有验证步骤。通过这个。

你可以测试你的模型是否有效。因此现在我们还必须设置我们的模型。我们说模型等于。让我们称其为lit模型，以清楚地表明这是一个Lightning模型。因此lit。😊。uralNe。这里我们说让神经网络具有超参数。因此它需要输入大小。它需要隐藏大小，并且需要类别数。

我们在这里都有超参数。然后我们必须将其适配到我们的训练器。所以我们说trainer.dot fit我们的模型。现在我们可以直接运行它并看看这是否有效。所以现在，让我们去控制台。现在让我们运行这个文件。所以我们说Python lightning.dot pi。这里我们得到一个错误。所以，当然，我重命名了lital net。所以我也必须说明。

将神经网络命名为这里。现在再次运行它。现在我们看到它开始了。我们看到没有GPU支持。我们还得到了不同层和参数的概述。然后因为我是第一次运行，所以它正在下载数据集。然后这里是训练。所以它成功了。因为我们设置fast defffron等于true，所以只处理了一批。

所以让我们清除它并再测试一次。所以现在它不应该再下载了。这快得多了。现在这里，例如，我们得到一个警告，所以它说。数据加载器训练数据加载器没有很多工作进程，这可能是一个瓶颈。考虑增加nu workers参数的值。试试4。

所以这实际上是第一个可以帮助我们加速代码的提示。在我们的训练加载器中，我们可以给它的参数设置为nu workers等于4。现在我们清除这个并再次运行，现在我们的警告消失了。这里我们看到了概览。我们现在只使用了一个epoch，这里有损失值。

所以现在如果你想进行完整的训练，我们也可以给我们的训练器参数max epoch等于定义的epoch数量。所以这是超参数之一。现在让我们再次将其设置为false。这应该进行完整的训练。现在，让我们看看这是否有效。

现在这应该需要。Max epos，抱歉。现在这应该稍微长一点。是的，我们看到。所以我们得到了一个不错的进度条，我们看到训练正常运行，损失值应该慢慢减少。所以这有效。😊，所以现在让我暂时停止这个。接下来我们想要做的是进行评估或测试。

所以类似于训练步骤和训练数据加载器。我们现在也想添加一个验证步骤和验证数据加载器。所以让我复制这个。并在这里粘贴。它必须被称为验证步骤。实际上我们在这里做同样的事情。所以在测试训练步骤中也是如此。

所以我们重新调整了图像，然后进行前向传播并计算损失。这次我们使用关键损失或验证损失。现在我们再次将fast defron设置为true。让我再运行一次。所以现在如果我们运行它，我们应该得到一个错误。是的，这里我们得到了异常，你已定义验证步骤。

但尚未传入验证数据加载器。所以现在我们知道该怎么做。我们还必须使用验证数据加载器。所以让我复制并粘贴这个。并且这必须被称为well data loaddown。如果你不确定，可以去官方文档。

![](img/8f1dbba751e44013b8cee2c7d55082c5_39.png)

文档，然后滚动到验证循环。在那里。你会看到。![](img/8f1dbba751e44013b8cee2c7d55082c5_41.png)

你需要的三个函数，所以。现在，首先，我们有我们的。验证数据集。因此在这里我们想说，或者我们想抓取。![](img/8f1dbba751e44013b8cee2c7d55082c5_43.png)

下一个或测试数据集。在这种情况下，我称之为测试数据集。但实际上。你需要将数据划分为训练数据集、验证数据集和测试数据集。验证数据集用于在调整超参数时对模型性能进行无偏评估。而测试数据集则是在最后提供对模型从未见过的数据的无偏评估。

在这个示例中，我们假设只有两个数据集的划分。现在。我们只使用前两个步骤进行训练和验证。所以让我复制这个并粘贴到这里。然后让我们将其重命名为验证数据集。接着我们获取验证数据加载器。

![](img/8f1dbba751e44013b8cee2c7d55082c5_45.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_46.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_47.png)

并将其重命名为验证加载器，然后返回v加载器。现在让我们再运行一次。假设Python lightning dot pi。我们得到了一个错误。因此数据集等于好的数据集。 当然。让我们清除这个并再次运行，然后它应该通过训练和验证进行一次传递。我们看到它成功了。现在我们再次得到了相同的警告。

在这里我们使用nu workers等于4。因此让我们清除并再次尝试。因此，你会看到，当我们犯错误时，它已经开始给我们提示。现在我们看到它成功了。现在它也建议定义一个验证周期和方法来累积统计数据。所以让我们去文档中获取这个函数，看看它的样子。

![](img/8f1dbba751e44013b8cee2c7d55082c5_49.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_50.png)

我们复制并粘贴这个。因此这是在每个验证周期后执行的函数。在这里我们想计算平均损失。实际上，在我们的示例中。我们想做的正是这个。所以我们想调用。通过说这是torch stack来计算平均损失。然后因为我们。

被称为关键验证损失。我们可以在这里访问它，然后计算所有损失的均值，现在，暂时先不担心这个。然后我们将平均损失作为字典返回。这样我们就完成了。所以现在，如果我们清除它。那么，我们应该得到一个。1次通过，现在没有更多的警告。现在我们有了我们所需的一切来处理我们的代码。

所以这就是我们在PyTorch Lightning中所需的全部。现在，让我给你展示一个提示。我们可以获得的内容。例如，在我们的验证加载器中。如果我们不小心将shuffle设置为true并尝试运行它。我们应该得到一个警告或提示。所以是的，这里我们看到了用户警告。

你的数据加载器有`shuffle equals true`。在验证和测试数据加载时，最佳做法是将其关闭。所以你看，我们实际上可以用这个框架改进我们的代码。现在，让我们把它和我们的原始代码进行比较。如果我们在Github上查看这段代码。

![](img/8f1dbba751e44013b8cee2c7d55082c5_52.png)

然后我们不再需要这个设备功能。我们也不再需要手动遍历所有的轮次和所有的批次。我们不再需要关心这两个设备调用。我们也不再需要关心优化器和反向传播，并且我们可以省略整个验证循环，因为我们可以通过这个验证步骤来计算，现在，例如，如果你还想要一个训练步骤，我们可以以同样的方式轻松编辑，就像我们用这个函数和这个函数一样，现在。

例如，如果你想使用GPU，我们可以通过给我们的训练器传递参数`GPus equals`，例如`one`来轻松实现，当你想扩大规模并且有更多GPU可用时，你也可以使用。![](img/8f1dbba751e44013b8cee2c7d55082c5_54.png)

2，或者我们说4，或者你甚至可以使用T支持。所以从CPU切换到GPU，然后扩展规模真的很简单。你还可以拥有一个分布式后端。所以DP，例如。你也可以轻松切换到16位精度。你可以锁定GPU内存。因此，你现在可以非常轻松地测试很多功能，这个框架非常适合。

你只需使用所有不同的训练器参数。比如说，还有一个很有用的功能你可以尝试，就是`auto L R`。`Find equals true`。这将运行一个算法来寻找最佳学习率。所以你可以尝试这个。你也可以设置，例如，`deterministic equals true`。这样可以使你的结果可重现。

或者你可以通过简单地传入参数`Claient gripve equals`和一个介于0到1之间的值来轻松应用梯度裁剪，我想，这样的话，你仍然需要查看官方文档。![](img/8f1dbba751e44013b8cee2c7d55082c5_56.png)

在那里你可以找到所有不同的功能和用例。现在让我给你展示完整的训练和验证。所以让我们去掉这个。现在让我们将参数`fast defffron`重新设置为`false`。所以再次强调，我没有设置很多的轮次，所以只有两个，因为在没有GPU的情况下，这里会花费很长时间。

但我们还是运行一下。![](img/8f1dbba751e44013b8cee2c7d55082c5_58.png)

所以我们再次看到这里第一轮的进展，以及我们的损失是如何降低的。当这一切完成时，我们应该在验证循环中看到一个更快的进度条。现在小心。现在我们看到验证循环。现在我们的第二个训练轮开始了。所以，没错，这在工作。现在第二次验证，也完成了。

我们可以查看并检查最终的损失。因此这有效。现在最后一件事，让我给你展示集成的天线板支持。正如你所看到的，已经有一个名为 lightning lock 的文件夹，所以它已经自动保存了一些检查点。😊，所以现在。

如果我们想检查天线板中的不同损失，那么我们需要做的是。例如，如果你想检查训练。那么在我们的训练步骤中，我们创建另一个字典。我们称之为天线板锁，等于。再一次，这是一个字典，这里我们把训练损失作为键，值是相同的损失。

然后我们还将天线板损失附加到我们的字典中。我们必须给它钥匙锁，然后是锁。这是我们的天线板锁。现在在我们的验证周期结束时也是如此。所以在这里我们创建天线板锁。我们称之为平均验证损失。这是平均的，平均损失。

然后在这里，我们使用了钥匙锁和天线板锁。现在我们再运行一次以保存所有内容。因此，我们需要等到这个完成。现在我们的训练和验证都完成了。所以现在应该保存所有这些到锁目录。

现在我们可以通过输入 tensor board minus minus lock 来启动天线板。D 等于，然后是 lightning locks。顺便说一下，我也有一个完整的教程，讲述如何使用 Tensor board。我会在描述中放上链接。使用 lightning，你不必手动安装，因为它包含在 lightning 的要求中。

所以这现在应该自动工作。现在如果我们点击运行，抱歉，这里没有下划线。inus minus loar 等于 lightning locks。现在它可以工作。现在我们的天线板在这里运行。如果我们打开这个。![](img/8f1dbba751e44013b8cee2c7d55082c5_60.png)

然后我们应该检查周期。然后我们有平均验证损失。由于我们只使用了两个周期，我们在这里看不到太大的差异，所以只有一行。但对于训练损失，这是我们在每个训练步骤后查看的。因此这里我们看到一个很好的图表，显示我们的训练损失是如何减少的。所以，是的，你看到了。

我们有自动的天线板集成，使用这个工具非常简单。因此，是的，这些是我想展示的大部分功能。如果你喜欢这个框架，请在评论中告诉我。如果你也认为它可以简化你的开发过程。如果你喜欢这个视频。

请点击喜欢按钮，并考虑订阅频道。这对我帮助很大，下次再见！![](img/8f1dbba751e44013b8cee2c7d55082c5_62.png)

![](img/8f1dbba751e44013b8cee2c7d55082c5_63.png)
