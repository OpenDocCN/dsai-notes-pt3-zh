# 【双语字幕+资料下载】Python 3全系列基础教程，全程代码演示&讲解！10小时视频42节，保证你能掌握Python！快来一起跟着视频敲代码~＜快速入门系列＞ - P37：37）异常处理 - ShowMeAI - BV1yg411c7Nw

![](img/3f2152552115a6afb263c5924c9c35c1_0.png)

欢迎回来，大家好。这是布莱恩。我们将继续深入Python 3中的异常处理。所以，基本上，坏事会发生，我们需要知道如何处理它们。我们在这些视频中已经看到了这一点，我相信你在使用计算机时也见过无数次，系统提示错误或未知错误，或者其他一些疯狂的事情。但我们需要理解这里的细微差别。

错误大多发生在运行时。它属于一种未检查的类型。这是一些像你的硬件故障或网络连接中断之类的事情，完全是意外的事情，我们真的无能为力。另一方面，异常发生在运行时和编译时，主要由开发人员编写的代码引起。

意味着我们现在正在创造自己的问题。所以，是的，我们可以编写代码来防御错误。但我们永远无法真正做到100%防御错误。就像你怎么防止你的CPU爆炸，你就是无法做到，你的代码将停止工作。另一方面，异常就像除以零、错误的数据类型等等。

所以这就是我们将在这个视频中深入探讨的内容。此外，在开始之前，我会放一个简单的装饰器，我们在之前的视频中讨论过这个，但为了防止这看起来像古埃及代数，我再做一个快速回顾。装饰器是一个函数调用，被另一个函数调用用来装饰它，基本上就是这样。

我们有一个内部函数，它将返回一个接受任意数量的参数或关键字参数的函数。我们将简单地打印出来。当我说打印出来时，你会看到在调用该函数前后有一堆破折号。为了增加一些风味，我加入了函数名，我们将在每一个函数中使用它。

![](img/3f2152552115a6afb263c5924c9c35c1_2.png)

![](img/3f2152552115a6afb263c5924c9c35c1_3.png)

首先，我们将查看try、except和finally。现在，这在一开始可能会有点难以理解，但我们真正要做的是创建一些特殊的作用域，而这些作用域存在是有特殊原因的。所以，首先的事情就是这样。

我将创建一个名为test 1的函数，给它的参数是x和y。我会立即调用pass。我们将再次使用我们的装饰器。如果你对装饰器没有任何概念，或者觉得这个看起来很糟糕，或者不理解这个内容，请观看我之前关于装饰器的视频。但基本上，当我们调用这个时。

这将会打印。首先调用函数，然后再打印。这就是我们所做的，尽管看起来有点混乱。好了，现在我们来深入了解一下。我们将使用 usery。你会注意到，在我们的 IDE 中有一些选项，你的可能看起来大相径庭。这些看起来令人困惑。试试，trycept 其他的，最后，如此等等。

我们将逐一讲解这些。但我首先要做的就是尝试。必须以 Col 结束。我将继续暂时跳过，并且我们将要。捕获。我们将再次跳过。只是想把这个完善，然后最后。我想逐一讨论这些。如果你来自另一种语言。

这基本上就是一个 try catch finally。try 意味着我们将尝试一些代码。它可能会工作，也可能不会。所以，例如，我们可以说 z 等于 X 除以 y。然后我们只会打印出来。哎呀，我们要打印出来，看看我的意思。我在这里制造自己的错误。结果。这段代码看起来真的很无聊。

这只是基本的除法。但我们在这里可能会做得非常、非常错误。我们可能会做类似于除以 0 的操作。而且由于 Python 不是严格类型的，我们可以发送非数值的值到这里，并崩溃整个东西。我们之前见过这个。在这个系列中我之前做过。所以我们必须对此进行防御。

我们想要做的是 except，这是其他语言中 catch 的基本版本。我实际上会把它作为注释放在这里，catch。所以如果你来自另一种语言，这就是 catch。用其他语言更容易解释，就像接球。

你在捕获异常，或者有人掉了婴儿，你在它掉到地板之前捕获它。在这个类比中，程序当然就是你的婴儿。所以我们要在程序失败之前保持我们的程序或捕获我们的程序。现在我们将执行某种逻辑。发生了一些事情。

现在这个问题是我们并不真正确定发生了什么。我们只知道发生了一些糟糕的事情。我们将在视频的后面看看如何确定发生了什么，并根据此采取具体的行动。好了，但现在我们真的处于初学者阶段，我们只想知道发生了一些糟糕的事情。现在，finally。无论如何，finally 都会被调用。所以 try 是一个尝试。Zempt 是捕获它。

如果它失败，你知道，就会发生一些糟糕的事情。我们必须在它遇到可怕的、意外的死亡之前捕获它。继续进行是我称之为 finally 的部分。无论上面发生了什么，finally 都会被调用。我们来看看。所以我将简单地打印出来。完整的，顺便问一下我的手动输入。是的。

大多数编程错误都是拼写错误、输入错误之类的，或者只是数据类型不匹配，类似的情况。让我们来看一下这个实际操作。我们要说的是Test1。让我们用5和0来测试一下。显而易见的是，零，这个非常糟糕，让我们检查一下。哎呀。函数test1，发生了些坏事，所以马上。

与其让我们的程序因除以零错误崩溃，我们能够捕获它，并采取一些措施。现在，让我们给它另一次不幸的结局，进行子测试1。假设我们用5和猫。你如何用猫来除以5，我对此非常感兴趣。但是我们再试一次。果然，发生了坏事，5和猫的操作出错了。

所以我们知道这不是可行的。让我们先这样做。让我们来除法。复制粘贴让我失望了。好了，让我们用2除以5，看看我们得到什么。所以结果是2.5。我们现在知道我们的函数可以正常工作，并且可以防范异常。这个视频片段中最重要的收获是，你需要一个try。

在一个尝试异常的情况下，会有catch和finally。这无论发生什么情况都会被调用。你可以在每一个示例中看到，无论是发生了坏事还是成功运行，finally都会被调用。那就是你的清理代码。所以我们将其更改为清理。所以要考虑到这一点，就像IO一样。

你将要写入一个文件，你将尝试打开该文件并写入。如果发生了什么坏事，那么你将无论如何都要关闭文件。![](img/3f2152552115a6afb263c5924c9c35c1_5.png)

![](img/3f2152552115a6afb263c5924c9c35c1_6.png)

有很多内置异常，我们正在查看官方Python文档。我将向下滚动。我们不会逐一浏览这些，因为我们会在这里呆上一整天。但有一些通用的高级异常，然后它进入非常具体的内容，比如算术、缓冲区、断言。现在我们将谈论断言，但我想让你了解正在发生的事情。

断言并不是一个真正的错误。这是我们实际上创建的东西。所以我们将断言一个条件为真。如果是真的，那么就没有任何事情发生。如果是假的，那么会抛出错误。当断言语句失败时，会引发错误，我们现在要做这个。同时要理解，你可以有很多这样的断言，甚至可以定义你自己的。

![](img/3f2152552115a6afb263c5924c9c35c1_8.png)

哇，吸收了很多信息，但我将留一个链接。把它放在那里。我们将从最后一个复制一点。然后进行一些修改。所有这些测试，二。好的，所以我们有我们的尝试、捕获和finally，让我们稍微改动一下。

我想做的第一件事是添加一个N else。因此现在把这个想象成一个巨大的if语句。我们说如果。然后如果，然后else。因此，当我们到达else时。我们信任这段代码，这段代码应该运行，我不喜欢这样做。因为如果发生了什么事情，那你最终会在这里做另一个尝试豁免块。

我不喜欢一遍又一遍地在线做这件事。这会变得非常麻烦，所以。我们将把它移到这里。我将称之为可信代码，个人上我不信任代码。我通常在这里做，但你会在外面看到人们会说。否则就这样做。当到达这里时，你会毫无保留地信任这个。它不会出错。

因此尝试现在是我们必须进行一些测试的事情，所以我们将进行断言。现在。如果你是家长，你知道断言到底是什么，因为你走到孩子面前说。你现在要清理你的房间。如果他们不遵守，如果你得到一个假的返回，那么。坏事就发生了。他们会被禁足。因此我们将说x大于0。

Sert将进入并评估这个条件，如果它是真的，没什么坏事发生，然而。如果是假的，坏事会很快发生，这意味着。它会说失败，并且会抛出一个断言错误。我们将在这里的其他捕获条件中称之为豁免。因此，让我们抓住。

之前。我们有的测试。让我们重新命名这些，得看看，复制粘贴，让生活简单些。好吧，我们将进行5除以0，5猫，5，2。让我们继续测试一下。把这个往上移动。好吧，现在我们可以看到。我们的断言正在工作。因此函数是测试2。发生了一些坏事。因此它立即表示，Serert失败，然后打印出这个。

Asert是一个强大的工具，但它并不完美。我们想知道到底发生了什么，并希望能够根据具体情况处理事情。因此通常。我会把这个改成。异常作为E或错误或你想放入这里的任何东西。然后我会实际添加问题。然后E，当然。

如果你想深入了解，具有其他属性。但我们将把它保持简单，只在这里打印E，并让我们清空这个。然后重新运行，看看发生了什么。好吧，发生了一些坏事。问题在于它在字符串和int的实例之间不支持。

现在我们有某种类型问题。但请注意，除以0从未被捕获。因此我们有几个选择，我们可以将其留在捕获所有中，或者可以做一个除以0的错误，或者我们可以制作一个自定义错误。然而，我们希望这样做。如果我们想捕获一个特定条件。我们将说。除了。断言错误。那么，我会说。阻止F。并未能断言X。以及原因。

当你现在查看这个时，我们处理了两个异常。我们有断言错误和一个通用的捕获所有。所以我将在这里指定。你可以将这些链接到无穷大。你可以基本上处理每一个错误。但我将做的是处理我预期会出现的事情，比如如果我失败了一个断言。

我想知道用户给我们的只是垃圾数据，还是发生了更高层次的问题。我希望能够捕获到这一点。但我想能够在应用程序中区分这两者之间的差异。所以如果我们失败了一个断言。这将在其他事情发生时被调用，明白吗？

让我们试一下。好吧，发生了不好的事情。好的，然后断言失败。所以你可以看到这里触发了两个不同的。断言失败，意味着我们测试失败了。断言y大于零，让我看看我能不能腾出一些空间。这失败了，触发了这个。但然后你会注意到，如果这是猫大于零。

Python如何开始评估这个问题，它不能，所以它跳过并说发生了坏事。我们无法比较这两个，所以它跳到这里的异常代码。因此，对于我们的断言逻辑，它将为其他事情执行这个。我们的捕获所有将被触发。这实际上非常强大。但有一件事。

我真的要提醒你不要过于夸张。所以，例如，如果你尝试做一个……豁免。嗯，我在找什么类型？空气。然后我们可以说错误类型。让我们清除并重新运行。你会看到现在它说错误类型X，猫不能进行比较。

但我在这里所做的事情是我的代码越来越长且越来越复杂。所以我会说，寻找你绝对必须处理的特定错误，让其他所有错误都落入一个捕获所有的情况。至少，你应该有一个捕获所有，这仍然是可以接受的，但你希望能够捕获问题。我很少使用else，因为现在我完全信任所有这些代码能够顺利运行，没有任何问题。

如果我们这样做，会发生什么？我只是按了空格。这里就有一个空白。去吧，清除它，然后让我们运行。注意我们的程序，即使我们已经将所有安全性考虑在内，现在也崩溃了，而我的IDE没有告诉我，嘿，这里有个问题。这就是我倾向于不使用else的原因。

让我先去修复这个问题，然后再继续，确保一切正常。如你所见，这可能变得非常复杂。我是说，我们的小函数现在比屏幕还大。我得要么缩小视图，这会让代码变小且难以阅读，要么我得……嗯，想出别的办法。所以我们将在这里增加另一个复杂性。

我们将创建一个用户定义的异常并将其引发。这意味着我们将创建自己的错误，然后捕获它并展示你为什么想要这样做。所以这在文件 I/O 中是相当典型的。但首先。让我们创建一个类，称之为猫错误。

因为每只猫都有某种错误。为什么不呢？所以猫错误将继承运行时错误。我们将使用内置类运行时错误来继承它。现在我们有了所有这些功能，让我们继续说 De。我们将以。和作为。然后我只是想说 self 的。Args。我总是喜欢那个词。

听起来像个海盗。无论如何，我们可以说这就是艺术，所以。非常，非常简单的课程。你可以随意把它复杂化，但只需知道。这个错误类的生命周期是非常短暂的。这些的生命周期基本上是从事情发生到被捕获的时间。

你不想让这些东西徘徊。它们的唯一目的是传递关于发生了什么的信息。好吧。所以我将说 at。Outline，因为我们将再次使用我们的装饰器。我要定义。我们称之为，测试猫。我们将测试猫的数量。然后我要做一个 try。现在你开始理解一开始所有这些无聊的智能弹出的原因了。

我们可以做一个 try exempt。我们可以做一个 try exempt else finally，等等，任何其他组合，我只是选择 try except finally，它将为我们执行代码。现在，我并不需要所有这些东西。所以我将稍微改变一下。以适应我的需要，Intelence 很棒，但并不总是要按他们想要的方式来。

所以现在我有一个 try、except 和 finally。我们在这里要做的是我将说。在我们的 try 中。如果不是。他的实例。那么我们将测试确保 Q T Y 实际上是一个整数。因为你可以知道，传入一个字符串，我们不想对字符串进行某种数学运算。现在，如果不是。一个整数，我们想引发。现在引发基本上就像扔球一样。

我们在说，你知道吗，这是一个错误，你去修复它，我们在扔。一个石头或球向窗户，说，来，抓住它。如果你抓不住。你的程序将会崩溃，就像窗户一样。也许我刚刚开了个关于微软 Windows 的玩笑。我不知道。无论如何，随你怎么解读。

所以我们将引发某种类型的错误。当我说错误类型时，我并不是指。这个。类类型错误。我是说，这可以是一个断言错误。或者任何基本上继承错误或运行时错误的东西。但在这个案例中。我们将做一个类型错误，因为我们知道存在一个特定的问题。然后从这里开始。

我们要说。必须是一个提示。所以当你引发错误时，你要非常小心，以确保引发正确的类型。这是 Python 非常非常非常关心类型的少数几次之一。如果你试图引发像字符串这样的东西，你会得到一些奇怪的结果。虽然我怀疑你可能确实可以做到。好吧。现在我们要。检查数量。

所以我们要回到这里，说如果。数量，如果我们到了这一点，我们知道。因为这个没有被引发。我们知道这是一个整数。我们可以在数学上处理它。所以现在我可以说数量小于 9，那么。好吧，谁会理智地拥有少于9只猫。所以我要引发我们的猫错误，并说，必须。

哦，嗯。超过 9 只猫。因为我不知道什么疯子会理智地拥有少于九只猫。这就是猫类错误的存在原因。但现在我真正想展示的是，只要我们继承运行时错误，我们就可以创建自己的自定义类，并且可以抛出或引发。

就像任何其他设置类型一样。非常，非常酷。好吧，所以。既然我们有了这个。我就要说打印。我们将进行格式化。我只想说“哎呀”。这是我们的捕捉点。我们要说像“哎呀，未知错误。对不起，我错了。”然后我们要说 E 进行。现在，最后，我要说。认。完成。

注意，这比上面的这个大而笨重的东西简化了很多，很多，很多。这就是我所说的。空气处理可以非常复杂，并且发展得很快。因此，一般的经验法则是尽量保持简短、简单并切中要点。好吧。我们来测试一下我们的 CAs 类。我要说测试猫。我们希望。

有些疯狂的人只有三只猫。有些疯狂的人有12只。三只猫。我不知道你怎么会有三只猫。这有点可怕。然后我们要。测试11只猫。如果我们想的话，甚至可以让这个事情转个弯，直接说 ABC。让我们清空结果并发出指令。好吧，所以。我们看到，必须是一个整数。

必须拥有超过9只猫。必须是一个整数。我是说，现在这运行得如预期一样。所以这必须是一个整数。必须拥有超过9只猫。必须是一个整数。然后 Ta。最后，我们有一些理智的人，他们确实遵循了指示。为了清晰起见，我要说，你拥有 X 只猫。把这最后一次清楚地说出来。你拥有 11 只猫。

你可以看到你拥有 11 只或者你拥有的任何不在其中的数量，因为我们抛出了并捕获了异常。所以每当你看到尝试，就想象这像是在打棒球或某种运动，他们拿着球。如果发生他们不喜欢的事情，他们会把球扔出去。然后由其他东西来接住它。不论发生什么。

运动解说员将会，说就像这个赛季一样，说，安，我们完了，大家。![](img/3f2152552115a6afb263c5924c9c35c1_10.png)
