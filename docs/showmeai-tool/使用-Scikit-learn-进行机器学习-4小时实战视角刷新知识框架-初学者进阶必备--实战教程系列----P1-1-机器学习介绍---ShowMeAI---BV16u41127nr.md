# 使用 Scikit-learn 进行机器学习，4小时实战视角刷新知识框架，初学者进阶必备！＜实战教程系列＞ - P1：1）机器学习介绍 - ShowMeAI - BV16u41127nr

![](img/cca75afc4da139e8d5dce602f436c338_0.png)

![](img/cca75afc4da139e8d5dce602f436c338_1.png)

在这部分课程中，我们将进入一个新的部分，即机器学习。我们将涵盖大量材料，但与此同时，这只是你在这个领域可以做的材料的冰山一角。

让我试着从我们熟悉的事物开始，然后连接到我们将要做的新事物，即构建模型。你们已经运行函数很长时间了，对吧？所以，也许我会写这段代码，然后我们的函数接收输入，可能以参数的形式，然后它们有一些输出，也许它们在打印某些内容，或者我可能会返回一个值。

例如，我可以想象一个函数可以做一些预测。也许我的输入是我有一些待售房屋的详细信息。然后我可能会预测它可能卖多少钱，所以当我有这样的函数时。这就是一个模型的例子。我可以想象同时输入一堆值并做出很多预测。

所以机器学习的想法是，电脑不再由人类编写这些函数，而是由电脑自动生成这些函数。它们的做法是通过实例学习。

因此，我们将输入一堆训练数据，其中有许多房屋以不同的价格出售，并且有不同的卧室和浴室。我们试图推断一些事情，比如卧室值多少钱，浴室值多少钱。

拥有一座新房子有多有用？然后基于那个函数。我们将能够生成那个函数，然后用它来对其他数据做出预测。你可以想象这对许多事情可能是有用的。也许你在进行物业评估，或者你是房地产经纪人，正在努力确定如何正确定价房子。

我在这里给出的例子是回归模型的例子，回归模型试图更广泛地说是一种监督式机器学习，它是机器学习的三大主要类别之一。所以我现在要开始广泛地讨论这三个领域，然后我们将更详细地谈论回归，我实际上会解释它是什么。

机器学习的三个主要领域是强化学习，这基本上是一种需要做一系列决策的情况。你试图优化某种奖励，所以你可以想象某种机器人在世界中移动并拾取硬币，或者类似的事情，但我们在这门课中不会做那种工作，而是会专注于两个领域：监督机器学习和无监督机器学习。在这两种情况下，我们都有所有的数据，而我们试图从中获取信息。有些人会说有一个第四类机器学习，称为超监督学习，但我们在这里不会讨论那个。

在监督机器学习中，我们这学期要学习两种不同的内容。一种是回归，在回归中我们试图预测一个数量，然后通过分类我们将尝试预测一个类别，因此在我们试图预测的任何情况下，这被称为监督问题，工作原理是我们拥有的数据上有一些标签，通常有一个特殊的列告诉我们，例如房子的价格或某种类别，然后我们可以尝试预测这个标签，而在标签未知的情况下，无监督学习没有我们试图预测的特殊标签列，我们只是在寻找数据中的一般模式，所以我们可能会做几件事，我们可能会尝试对数据进行聚类，将行替换到不同的组中。

或者我们可能会尝试对我们的行进行分解，我们可能会注意到我可能有这些每行有F5个数字的行。但也许每一行是两种组件行的组合。所以尽管我们的数据可能有很多列，但里面仍然有一些简单性。因此，我将讨论这学期我们要学习的这四种类型的内容，并尝试让它们更具体，所以这里我有一个表格，这只是一个常规的数据框，这里是我的索引，这里是我的列名，现在我有一个Y列，它是我的标签，这通常就是我试图预测的内容。

然后我这里有一些不同的问题，我想我只是在画 x0 到 x4。但通常这些会有一些实际的名称，比如在我看到的之前，我们有房子里的床位数。因此，我们试图预测的这个标签是我们要寻找与其他列之间关系的内容，我们将其称为特征。😊 总的来说，发生的事情是我们有一些示例。

一些行中我们有两个方面的例子，然后可能还有一些其他数据，其中我们只有特征，但没有y标签，因此我们想尝试预测这里应该是什么样的。你可以想象为什么会这样，也许这些都是不同的房子，其中一些已经出售，所以我们知道它们的售价，而这些还没有上市。

所以我们在尝试预测如果它们上市的话会不会出售。这里回归问题我想再次强调的是，我们想预测一个量，这里的y列是基于特征的，而这个量我指的是一个数字。

所以我们将如何做到这一点呢？我们可能会首先将其分解为三个部分，首先选择一部分我们知道答案的数据，然后将其他一些我们也知道答案的数据放在一边，我们要做的是运行一个能够推断这些特征与这些标签之间关系的算法。

一旦我做完这些，我可能会在其他我也知道答案的案例上运行我的模型。当然，我已经知道真实的答案，除非我的模型是完美的，否则它可能会给出一些不同的答案，所以我为什么要这样做呢？

如果我已经知道答案，为什么还要做预测？原因是我可以这样来评估我的模型，或者我可能会说测试我的模型。例如，如果我的模型说这个房子的价格是70，而实际上是72，那就是一个错误，这里也是同样的道理。

60与59，这就是一个错误，我可以尝试量化所有这些错误，然后给我的模型打分，这就是测试阶段吗？

所以在那之后，在我学会了我的模型并对一些已知案例进行了评估后，我可能会把它投入生产。生产意味着我在用它做实际的事情。我在尝试预测世界上实际的未知量，比如说，如果我在市场上增加一套新房，它可能会卖多少钱。

我可以把这些不同的值放在那里。我们可能做的另一件事，甚至超越预测，是我可以查看那个模型并尝试学习一些关于世界的事情。所以我一直回到卖房子的例子。我认为了解每增加一套房子或每增加一个卧室或浴室，房子的价值会增加多少是很有趣的，我可以利用这些来做出不同的决策，比如说也许我想进行房屋改造，我是通过增加一个浴室还是一个卧室来获得更多的收益呢？所以我们可以以这种方式学习一些关于世界的事情并做出决策。

好的，所以所有这些都是回归，这是我们本学期要学习的第一种监督学习。当我们进行这些回归时，关键在于我们试图预测某个数量，而我们的Y标签现在完全可能是特征的数量和类别的混合，对吧？像绿色、红色、蓝色这样的就是一个类别。

形状也是一个类别，很多东西都是字符串或类别。没问题，对吧。回归的显著特征是标签列是定量的。如果我在处理一个Y是分类的情况，那么这就不再是回归了。这是一个分类问题，但否则我谈论的所有其他内容，包括训练和测试，然后投入生产。

所有这一切都是相同的，我们只是在处理类别而不是数量。好的。那么继续，我们看到了两种监督学习，分别是回归和分类。那么无监督学习呢？这里的主要内容是。

主要的要点是没有标签列，对吧？我只有一堆特征。然后我仍然可以尝试学习一些关于这个的模式。即使我并不是在试图预测任何东西。所以我可能想要学习的其中一件事是，这些行是否有任何自然的分组，因此有算法可以将所有这些行分成三个组，并可能给它们分配数字，比如零。

一和二，对吧？然后仅仅是为了画出那样的样子，虽然所有这些行都在一起。现在我真的想强调的是，没有数据告诉我正确的分组是什么，或者甚至有多少组，所以在我做这个的时候。

并不是说只有一个正确答案，但这并不意味着所有的分组或分类都是相等的。如果我有某种度量标准，我可以衡量组内那些行之间的相似性，因此我的目标是拥有一种尽量最大化每个组内相似性的分组，可能会有不同的分组同样有效，对吧？但只要我在组内保持高相似性，那么我依然能学到一些有意义的东西，你可以想象我可能出于很多不同的原因这样做，或许每个这些。

这些事物代表了我网页应用程序中的不同用户，然后如果我可以说，嘿。虽然我的应用程序有这10种不同类型的网络用户。我可能可以为每个不同的群体开展不同的营销活动。好的。所以聚类再次是无监督的，之所以是无监督的，因为虽然没有标签列，但我在尝试预测。

当我谈论本学期的最后一种机器学习问题时，可能是最复杂的，称为分解，而分解也是无监督的。对吧，这里没有我试图预测的列。分解的思想是我会查看所有这些行，看看是否有任何模式。是否有几种原型行可以真正混合在一起以创建其他东西。

所以也许我看到的是，带有一些小错误的大多数行只是这三行的组合，我会称这些为我的组成行。所以你会注意到我的原始数据和我的组成行之间的列是相同的。

然后为了得到这一行，比如负11，负7，3，2020。我会将这一行乘以负V 11，然后加上21乘以这一行，再加上负8乘以这一行。也就是说，我在对这三行进行加权平均，以产生这一行。如果你实际计算这些数字，你会看到我得到的结果与这个类似。

但会有一些错误，对吧？这不是一个完美的匹配，这没关系，我的组成部分越少，我就会有一个更简单的模型，但可能会有更多的错误。所以我在这里有这些数字，当我试图混合这些组件以创建一行时，我通常会把这些数字放在下面的另一个表中。

所以这将是我所有权重的表，或者说我的主成分得分，因此我会在这里写上负11，在这里写上21，然后在这里写上负8，然后对于下面的这一行，我会做同样的事情，我会在这里写上负43，在这里写上12，然后在这里写上负6。所以由于我在这样做，我在这里为每一行放入这些混合。这意味着如果这里有n行。

然后如果这里有N行，那里有M列。那么那边也会有M列。因此，基本上我可以将这个大表格减少到一些组件，我可以在这里有一些权重，这对许多事情都有用，其中之一就是如果我想在我的存储系统上节省空间，我可以让这些东西变得更小，但如果我试图进行机器学习的其他阶段，比如分类或回归，如果我只有三个特征列而不是原来的五个，那在许多情况下对我有所帮助。

好的，这就是对这四首诗的快速概述，其中我解决了回归、分类，这两者都是监督学习，因为它们是有标签的，而聚类和分解则是无监督的，因为没有要预测的无标签列。对于这四个主题，其实有很多不同的算法，而在这个学期我们只会学习每个主题的一个算法，所以如果我访问下面这个网站，这是我们将要学习的PsyH Learn模块的网站。

😊，可能有接近数百种不同的算法或不同的类别。我在这里列出了一个小子集，因此我可以看到，关于聚类的所有不同内容，我们将只学习其中一个，那就是K均值聚类。

在分解方面，我能做的所有不同的事情，我们将只学习其中一个，那就是PCA。事实证明，对于很多算法，分类和回归是常见的配对，例如，这里我有一个决策树分类器，这里我有一个决策树回归器。

这里我有一个K邻居分类器，这里我有一个K邻居回归器，因此我没有把这些分开，而是将它们放在这两个类别下，所以我们将在这里学习两个内容，我们将学习逻辑回归和线性回归，这有点令人困惑，因为。

这部分很明显，线性回归在这里就是回归。这是一个人们容易混淆的地方，因为尽管它的名称中有回归，但实际上它并不是回归，而是分类。因此，这就是我们这个学期将要学习的四个内容，而逻辑回归总是让人困惑，因为它实际上并不是回归。我认为一旦我们学习了所有这些，使用其他算法的接口就会相对简单。

例如，一旦你知道如何使用线性回归，你可以很容易地将“线性回归”替换为“岭回归”，你仍然能够正确地进行所有机器学习的工作。在你这样做之前，最好了解岭回归的工作原理，然后思考哪个模型最适合你。

至少在代码方面，切换不同模型是非常简单的，而不需要考虑这四个类别。我想多谈谈，这些都是比较高层次的内容，我想谈谈基础知识，我需要学习的机器学习，包括代码和数学方面。我学习了几个不同的模块，主要的是`scikit-learn`。

我将给你展示一些来自 PsyKt Learn 的文档。我们还将学习 nuy，它可以让我们处理矩阵。事实证明，nuy，Numpy 实际上是 pandas 的基础，没错，所有的 pandas 数据实际上存储在 Numpy 中，现在是我们实际看到这一点的好时机。然后当我学习了这个叫 Pytorch 的东西时，Pytorch 可以为我们做几件事情。

一个是它可以为我们进行微积分，这非常酷。另一个它可以让我们做的事情是它实际上可以让我们在 GPU 上运行代码，这些是图形处理单元，我们这一学期到目前为止所有的运行都是在 CPU 上进行的，没错，就是你的中央处理单元。结果发现，原本为图形构建的 GPU 在机器学习方面也表现得非常好，因此，如果你处理大量数据或复杂模型时，它们会非常有用。

使用 GPU 会更好。我要学习一点数学。我并不假设你有任何数学背景，除了你可能在高中学到的内容，但让我给你一个例子，说明数学在这里如何应用于回归问题。因此我们再次以所有房屋及其特征的例子为基础，然后我们有一个预测价格的函数。我们如何用矩阵来做到这一点呢？我可能会将数据框中的所有这些数字放入这个矩阵中。

然后对于我的函数，我可能只是有一个使用矩阵的代数表达式。因此，我这里的 x 是这个矩阵，C 是一个向量，B 只是一个数字。当我运行这个时，我将得到另一个向量，实际上包含所有的价格。因此，为了理解这里发生了什么，我们必须学习一点线性代数。

这不是常规的乘法，它实际上是被称为点积的东西，看起来是这样的，我可以将这个 X 矩阵与这个向量进行点积，然后加上一个数字，然后这就是我将如何在右侧获得我的结果，进行一次预测，令人惊讶的是，如果我可以将一行与这个向量相乘，我就得到了一个房屋的价值，并且这会在没有循环的情况下进行，线性代数和通过点积相乘矩阵的美妙之处在于，这可以一步完成，我实际上会得到所有这些数字。代码非常简单，如果我说数据框的值，那么 x 实际上将是一个 nuy 数组，如果我想的话，我可以说我想要这两个东西的点积，并且我想要加上 B，这样就能正常工作。因此在学期结束前的某个时候，我们会对此进行更多详细的讨论。

我想注意的一点是，如果你在阅读其他文档，很多资源会使用A而不是Xs，我觉得这很让人困惑。如果你正在研究这些syKt学习模块，这样并不直观，因为这些通常会使用x表示数据，而更奇怪的是，在PsyKt学习中，我们通常会有一个C，但他们会把它称为小x，所以在我们学习线性代数的过程中要保持清醒。

我想提前说清楚，我会再说一遍，要注意变量名称有点奇怪。那么线性代数的范围是什么，我们试图解决哪些问题呢？我们不会解决类似于y等于x平方的东西，那不是线性的，任何二次或三次方的东西都不是线性的，实际上我们能做的就是将变量乘以数字，然后再加起来，对吧？所以这是一个线性方程的例子，我有一些不同的变量。

然后我将它们乘以不同的数字，我注意到我们在这门课中进行线性代数的方式是我们实际上有非常大的矩阵，很多变量和很多方程，对吧？所以你可以看到这里我实际上有50个变量，所以关键要点是，更多的变量意味着更多的数据，但方程更简单。

关于微积分，这里我再次遇到房子的情况，我有一些训练数据。所以我有我的特征和标签，它会引入一个算法，该算法基本上会为我输出这个公式，我可以用来预测房价。

对。现在，事实证明，当我进行训练时，我有原始价格，而新价格可能有一点不同，对吧？这是140。这是190、240、254，对吧，它们都稍微有些不同。因此，对于这个给定的方程，我最终会有某种函数。

总损失函数比较正确答案与我模型的答案，对吧？所以我比较这两个，得到一个数值出来，这就像是我的误差或它有多糟糕。当然，它的糟糕程度实际上取决于这个方程下面的数字。所以这个训练算法的整个想法是，我想找出，嗯。

我能做什么才能让我的误差或损失尽可能小，所以我们试图最小化某种东西，我不指望你们都能做微积分。但我知道你们中的许多人都学过，而在微积分中我们通常试图最小化或最大化某些东西？

这就是它试图在这里发挥作用的原因。好消息是我们不需要理解微积分，会有一些模块可以处理，例如这个pitorrch的东西，我会学习pi torch。它也将帮助我们能够在GPU上运行我们的代码。我们将能够做一些像处理两个矩阵的事情。

将它们移到 GPU 上，然后相乘，这几乎感觉就像是它比在 CPU 上运行时神奇地快得多，而且移动这些代码并不需要很多。因此，Pytorch 在微积分和使用 GPU 方面将非常强大。

在结束这个视频时，我想谈谈开发者和用户之间的区别，以及我们是谁。嗯。当我看到这里的这张图片时，我正在将所有这些训练数据输入到一个机器学习算法中。然后这给了我们一个可以用来进行预测的函数。这里有一些类别，我想人们通常会开发新的算法，或者编写代码并优化现有算法的代码。

我们会做一点点这方面的工作，但这不是我们的重点，我们不是在进行机器学习研究或尝试提出新想法。我们不是开发者，而是机器学习算法的用户，这让我能学习到一些内容。因此，接下来我们在这门课中会感兴趣的一些问题是，我们应该使用哪个算法？在 SK learn 中我们应该如何选择？我想我们应该如何配置它？很多这些算法在数据方面有不同的参数，我们如何清理数据，以使其与我们选择的机器学习算法良好配合，最后当我们实际使用这个东西时。

我们将获得所有这些预测，可以与原始数据进行比较，我们希望如何评分呢？并没有一种绝对正确的方法来评估它的好坏，因此我们也希望获得一些经验，这也是课程内容的一个小预告，希望这与我们之前所做的相比是一次有趣的变化。

![](img/cca75afc4da139e8d5dce602f436c338_3.png)
