- en: ã€åŒè¯­å­—å¹•+èµ„æ–™ä¸‹è½½ã€‘PyTorch æç®€å®æˆ˜æ•™ç¨‹ï¼å…¨ç¨‹ä»£ç è®²è§£ï¼Œåœ¨å®è·µä¸­æŒæ¡æ·±åº¦å­¦ä¹ &æ­å»ºå…¨pipelineï¼ï¼œå®æˆ˜æ•™ç¨‹ç³»åˆ—ï¼ - P9ï¼šL9- æ•°æ®é›†å’Œæ•°æ®åŠ è½½å™¨
    - æ‰¹é‡è®­ç»ƒ - ShowMeAI - BV12m4y1S7ix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ã€åŒè¯­å­—å¹•+èµ„æ–™ä¸‹è½½ã€‘PyTorch æç®€å®æˆ˜æ•™ç¨‹ï¼å…¨ç¨‹ä»£ç è®²è§£ï¼Œåœ¨å®è·µä¸­æŒæ¡æ·±åº¦å­¦ä¹ &æ­å»ºå…¨pipelineï¼ï¼œå®æˆ˜æ•™ç¨‹ç³»åˆ—ï¼ - P9ï¼šL9- æ•°æ®é›†å’Œæ•°æ®åŠ è½½å™¨
    - æ‰¹é‡è®­ç»ƒ - ShowMeAI - BV12m4y1S7ix
- en: Hiï¼Œ everybodyã€‚ Welcome back to a new Pytorch tutorial Todayã€‚ I want to show
    you the Pytorch data and data loader classesã€‚ So farã€‚ our code looked something
    like thisï¼Œ so we had a data set that we loaded somehowã€‚ For exampleã€‚ from a CV
    fileã€‚ and then we had our training loop that looped over the number of epochs
    and then we optimized our model based on the whole data setã€‚
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§å®¶å¥½ï¼Œæ¬¢è¿å›åˆ°æ–°çš„Pytorchæ•™ç¨‹ã€‚ä»Šå¤©ï¼Œæˆ‘æƒ³å‘ä½ å±•ç¤ºPytorchçš„æ•°æ®å’Œæ•°æ®åŠ è½½å™¨ç±»ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬çš„ä»£ç çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªä»¥æŸç§æ–¹å¼åŠ è½½çš„æ•°æ®é›†ã€‚ä¾‹å¦‚ï¼Œä»ä¸€ä¸ªCSVæ–‡ä»¶ã€‚ç„¶åæˆ‘ä»¬æœ‰ä¸€ä¸ªè®­ç»ƒå¾ªç¯ï¼Œå¾ªç¯éå†æ—¶ä»£çš„æ•°é‡ï¼Œç„¶åæˆ‘ä»¬åŸºäºæ•´ä¸ªæ•°æ®é›†ä¼˜åŒ–æˆ‘ä»¬çš„æ¨¡å‹ã€‚
- en: So this might be very time consuming if we did gradient calculations on the
    whole training dataã€‚ So a better way for large data sets is to divide the samples
    into so-called smaller batchesã€‚ and then our training loop looks something like
    thisã€‚ğŸ˜Šï¼ŒSo we loop over the epochs againã€‚ and then we do another loop and loop
    over all the batchesã€‚
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ï¼Œå¦‚æœæˆ‘ä»¬åœ¨æ•´ä¸ªè®­ç»ƒæ•°æ®ä¸Šè¿›è¡Œæ¢¯åº¦è®¡ç®—ï¼Œè¿™å¯èƒ½éå¸¸è€—æ—¶ã€‚å› æ­¤ï¼Œå¯¹äºå¤§æ•°æ®é›†ï¼Œä¸€ä¸ªæ›´å¥½çš„æ–¹æ³•æ˜¯å°†æ ·æœ¬åˆ’åˆ†ä¸ºæ‰€è°“çš„å°æ‰¹é‡ã€‚ç„¶åæˆ‘ä»¬çš„è®­ç»ƒå¾ªç¯çœ‹èµ·æ¥å¤§è‡´æ˜¯è¿™æ ·çš„ğŸ˜Šï¼Œæˆ‘ä»¬å†æ¬¡å¾ªç¯éå†æ—¶ä»£ï¼Œç„¶åå†è¿›è¡Œå¦ä¸€ä¸ªå¾ªç¯ï¼Œéå†æ‰€æœ‰æ‰¹é‡ã€‚
- en: and then we get the x and y batch samples and do the optimization based only
    on those batchesã€‚So now if we use the build in data set and data loader classes
    from Pytorchã€‚ then Pytorch can do the batch calculations and iterations for usã€‚
    so it's very easy to useã€‚And now I want to show you how we can use these classesã€‚
    but before we jump to the codeã€‚
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬è·å–xå’Œyæ‰¹é‡æ ·æœ¬ï¼Œå¹¶ä»…åŸºäºè¿™äº›æ‰¹é‡è¿›è¡Œä¼˜åŒ–ã€‚æ‰€ä»¥ç°åœ¨å¦‚æœæˆ‘ä»¬ä½¿ç”¨Pytorchå†…ç½®çš„æ•°æ®é›†å’Œæ•°æ®åŠ è½½å™¨ç±»ï¼Œé‚£ä¹ˆPytorchå¯ä»¥ä¸ºæˆ‘ä»¬è¿›è¡Œæ‰¹é‡è®¡ç®—å’Œè¿­ä»£ï¼Œå› æ­¤ä½¿ç”¨èµ·æ¥éå¸¸ç®€å•ã€‚ç°åœ¨æˆ‘æƒ³å‘ä½ å±•ç¤ºæˆ‘ä»¬å¦‚ä½•ä½¿ç”¨è¿™äº›ç±»ï¼Œä½†åœ¨è·³åˆ°ä»£ç ä¹‹å‰ã€‚
- en: let's quickly talk about some terms when we talk about batch trainingã€‚So firstã€‚
    one epoch means one complete forward and backward pass of all the training samplesã€‚And
    oneã€‚ the batch size is the number of training samples in one forward and one backward
    passã€‚And the number of iterations is the number of passes where each pass uses
    the batch size number of samplesã€‚
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å¿«é€Ÿè°ˆè°ˆä¸€äº›æ‰¹é‡è®­ç»ƒæ—¶çš„æœ¯è¯­ã€‚æ‰€ä»¥é¦–å…ˆï¼Œä¸€ä¸ªæ—¶ä»£æ„å‘³ç€å¯¹æ‰€æœ‰è®­ç»ƒæ ·æœ¬è¿›è¡Œä¸€æ¬¡å®Œæ•´çš„å‰å‘å’Œåå‘ä¼ é€’ã€‚è€Œä¸€ä¸ªæ‰¹é‡å¤§å°æ˜¯æŒ‡åœ¨ä¸€æ¬¡å‰å‘å’Œä¸€æ¬¡åå‘ä¼ é€’ä¸­çš„è®­ç»ƒæ ·æœ¬æ•°é‡ã€‚è¿­ä»£æ¬¡æ•°æ˜¯æŒ‡æ¯æ¬¡ä½¿ç”¨æ‰¹é‡å¤§å°æ ·æœ¬çš„ä¼ é€’æ¬¡æ•°ã€‚
- en: So here we have an exampleã€‚ If we have 100 samples and our batch size is 20ã€‚
    then we have5 iterations for one epochï¼Œ because 100 divided by 20 is 5ã€‚So yeahã€‚
    that's what we should knowã€‚ And now let's jump to the codeã€‚ So firstã€‚ I already
    implemented some modules that we needã€‚ So torchï¼Œ of courseï¼Œ then also torch visionã€‚
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬æœ‰ä¸€ä¸ªä¾‹å­ã€‚å¦‚æœæˆ‘ä»¬æœ‰100ä¸ªæ ·æœ¬ï¼Œè€Œæˆ‘ä»¬çš„æ‰¹é‡å¤§å°æ˜¯20ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯¹äºä¸€ä¸ªæ—¶ä»£æœ‰5æ¬¡è¿­ä»£ï¼Œå› ä¸º100é™¤ä»¥20ç­‰äº5ã€‚æ‰€ä»¥æ˜¯çš„ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬åº”è¯¥çŸ¥é“çš„ã€‚ç°åœ¨è®©æˆ‘ä»¬è·³åˆ°ä»£ç ã€‚æ‰€ä»¥é¦–å…ˆï¼Œæˆ‘å·²ç»å®ç°äº†ä¸€äº›æˆ‘ä»¬éœ€è¦çš„æ¨¡å—ã€‚æ‰€ä»¥torchï¼Œå½“ç„¶ï¼Œè¿˜æœ‰torch
    visionã€‚
- en: And then from torch dot u the dataã€‚ We import data set and data loaderã€‚ So the
    classes I just talked aboutã€‚ Then let's also import Ny and mathã€‚ And now we can
    start implementing our own custom data setã€‚ So let's call this wine data setã€‚![](img/c1a2854fc440d590a0a01b0cce4cb953_1.png)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åä»torch dot uå¯¼å…¥æ•°æ®ã€‚æˆ‘ä»¬å¯¼å…¥æ•°æ®é›†å’Œæ•°æ®åŠ è½½å™¨ã€‚æ‰€ä»¥æˆ‘åˆšåˆšæåˆ°çš„ç±»ã€‚ç„¶åè®©æˆ‘ä»¬ä¹Ÿå¯¼å…¥Nyå’Œmathã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥å¼€å§‹å®ç°æˆ‘ä»¬è‡ªå·±çš„è‡ªå®šä¹‰æ•°æ®é›†ã€‚æˆ‘ä»¬ç§°è¿™ä¸ªä¸ºé…’æ•°æ®é›†ã€‚![](img/c1a2854fc440d590a0a01b0cce4cb953_1.png)
- en: '![](img/c1a2854fc440d590a0a01b0cce4cb953_2.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a2854fc440d590a0a01b0cce4cb953_2.png)'
- en: And this must inherit data setã€‚ And then we have to implement three thingsã€‚
    So we have to implement the in itã€‚AndWith selfã€‚ So here we do some data loadingï¼Œ
    for exampleã€‚And then we also must implement the double underscore get item methodï¼Œ
    which gets self and an indexã€‚ So this will allow for indexing laterã€‚ so we can
    call data set with an index0ï¼Œ for exampleã€‚
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¿…é¡»ç»§æ‰¿æ•°æ®é›†ã€‚ç„¶åæˆ‘ä»¬éœ€è¦å®ç°ä¸‰ä»¶äº‹æƒ…ã€‚æˆ‘ä»¬éœ€è¦å®ç°åˆå§‹åŒ–æ–¹æ³•ã€‚å¹¶ä¸”ä½¿ç”¨selfã€‚åœ¨è¿™é‡Œæˆ‘ä»¬è¿›è¡Œä¸€äº›æ•°æ®åŠ è½½ï¼Œä¾‹å¦‚ã€‚ç„¶åæˆ‘ä»¬è¿˜å¿…é¡»å®ç°åŒä¸‹åˆ’çº¿get
    itemæ–¹æ³•ï¼Œå®ƒæ¥æ”¶selfå’Œä¸€ä¸ªç´¢å¼•ã€‚è¿™å°†å…è®¸ä»¥åè¿›è¡Œç´¢å¼•ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨ç´¢å¼•0è°ƒç”¨æ•°æ®é›†ï¼Œä¾‹å¦‚ã€‚
- en: And then we also must implement the lengthng methodï¼Œ which only has selfã€‚And
    then this will allow that we can call length of our data setã€‚So now let's startã€‚
    So in our caseã€‚ we want to look at the wine data setã€‚ So I have the Cs we file
    hereã€‚ and I also put this in my Github repository so you can check it out hereã€‚
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬è¿˜å¿…é¡»å®ç°é•¿åº¦æ–¹æ³•ï¼Œå®ƒåªæœ‰selfã€‚è¿™å°†å…è®¸æˆ‘ä»¬è°ƒç”¨æ•°æ®é›†çš„é•¿åº¦ã€‚é‚£ä¹ˆç°åœ¨è®©æˆ‘ä»¬å¼€å§‹ã€‚åœ¨æˆ‘ä»¬çš„æ¡ˆä¾‹ä¸­ï¼Œæˆ‘ä»¬æƒ³æŸ¥çœ‹é…’æ•°æ®é›†ã€‚æ‰€ä»¥æˆ‘è¿™é‡Œæœ‰CSVæ–‡ä»¶ï¼Œæˆ‘ä¹ŸæŠŠå®ƒæ”¾åœ¨æˆ‘çš„Githubä»“åº“ä¸­ï¼Œä½ å¯ä»¥åœ¨è¿™é‡ŒæŸ¥çœ‹ã€‚
- en: '![](img/c1a2854fc440d590a0a01b0cce4cb953_4.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a2854fc440d590a0a01b0cce4cb953_4.png)'
- en: And so the data set looks like thisã€‚ So the first row is the headerã€‚And here
    we want to calculate or to predict the wine categoriesã€‚ So we have three different
    wine categoriesï¼Œ1ï¼Œ2ï¼Œ and 3ã€‚And the class label is in the very first columnã€‚ And
    then all the other columns are the featuresã€‚
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°æ®é›†çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ã€‚æ‰€ä»¥ç¬¬ä¸€è¡Œæ˜¯æ ‡é¢˜ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬å¸Œæœ›è®¡ç®—æˆ–é¢„æµ‹è‘¡è„é…’ç±»åˆ«ã€‚æˆ‘ä»¬æœ‰ä¸‰ç§ä¸åŒçš„è‘¡è„é…’ç±»åˆ«ï¼Œ1ï¼Œ2å’Œ3ã€‚ç±»åˆ«æ ‡ç­¾åœ¨ç¬¬ä¸€åˆ—ã€‚ç„¶åæ‰€æœ‰å…¶ä»–åˆ—éƒ½æ˜¯ç‰¹å¾ã€‚
- en: So let's load this and split our columns into X and Yã€‚ So here we can say Xï¼Œ
    Y equals Ny dot load Tã€‚ Xï¼Œ Tã€‚![](img/c1a2854fc440d590a0a01b0cce4cb953_6.png)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è®©æˆ‘ä»¬åŠ è½½è¿™ä¸ªå¹¶å°†æˆ‘ä»¬çš„åˆ—æ‹†åˆ†ä¸ºXå’ŒYã€‚å› æ­¤åœ¨è¿™é‡Œæˆ‘ä»¬å¯ä»¥è¯´Xï¼ŒYç­‰äºNy dot load Tã€‚Xï¼ŒTã€‚![](img/c1a2854fc440d590a0a01b0cce4cb953_6.png)
- en: And here I must specify the file nameã€‚ So this is in the data folderï¼Œ and then
    I have a wine folderã€‚ And then it's called wine dot csvã€‚ Then let's also give
    a de limititer equals a comma here because this is a comma separated fileã€‚ Then
    let's also give it a data typeã€‚ So let's say data type equals nuy dot float through
    the2ã€‚ And let's also say skip rows equals oneã€‚ So we want to skip the first rowã€‚
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œæˆ‘å¿…é¡»æŒ‡å®šæ–‡ä»¶åã€‚æ‰€ä»¥è¿™æ˜¯åœ¨æ•°æ®æ–‡ä»¶å¤¹ä¸­ï¼Œç„¶åæˆ‘æœ‰ä¸€ä¸ªè‘¡è„é…’æ–‡ä»¶å¤¹ã€‚ç„¶åå®ƒå«åšwine dot csvã€‚æ¥ä¸‹æ¥è®©æˆ‘ä»¬ç»™å®šä¸€ä¸ªåˆ†éš”ç¬¦ï¼Œç­‰äºé€—å·ï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ªé€—å·åˆ†éš”æ–‡ä»¶ã€‚æ¥ä¸‹æ¥è®©æˆ‘ä»¬ä¹Ÿç»™å®ƒä¸€ä¸ªæ•°æ®ç±»å‹ã€‚å› æ­¤æˆ‘ä»¬å‡è®¾æ•°æ®ç±»å‹ç­‰äºnuy
    dot float64ã€‚ç„¶åè®©æˆ‘ä»¬è¯´è·³è¿‡è¡Œç­‰äºä¸€ã€‚å› æ­¤æˆ‘ä»¬å¸Œæœ›è·³è¿‡ç¬¬ä¸€è¡Œã€‚
- en: because this is our headerã€‚And now let's split our whole data set into x and
    yã€‚ So we say self dot x equalsã€‚ And here we can use slicingã€‚ So Xï¼Œ Yã€‚ And we want
    to have all the samplesã€‚ And then we don't want the very first columnã€‚ So we want
    to start at at the column number oneï¼Œ and then go all the way to the endã€‚
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: å› ä¸ºè¿™æ˜¯æˆ‘ä»¬çš„å¤´éƒ¨ã€‚ç°åœ¨è®©æˆ‘ä»¬å°†æ•´ä¸ªæ•°æ®é›†æ‹†åˆ†ä¸ºxå’Œyã€‚æ‰€ä»¥æˆ‘ä»¬è¯´self dot xç­‰äºã€‚åœ¨è¿™é‡Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨åˆ‡ç‰‡ã€‚æ‰€ä»¥Xï¼ŒYã€‚æˆ‘ä»¬å¸Œæœ›è·å–æ‰€æœ‰æ ·æœ¬ã€‚ç„¶åæˆ‘ä»¬ä¸æƒ³è¦ç¬¬ä¸€åˆ—ã€‚æ‰€ä»¥æˆ‘ä»¬å¸Œæœ›ä»åˆ—å·ä¸€å¼€å§‹ï¼Œä¸€ç›´åˆ°æœ€åã€‚
- en: So this will give us the Xã€‚ and then self dot y equals Xï¼Œ Y ofã€‚And here againã€‚
    we want all the samplesï¼Œ but only the very first columnã€‚ And we put this in another
    array here so that we have the size number of samples by oneã€‚ So this will make
    it easier later for some calculationsã€‚å—¯ã€‚Soï¼Œ yeahã€‚
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°†ç»™æˆ‘ä»¬Xã€‚ç„¶åself dot yç­‰äºXï¼ŒYçš„ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬å†æ¬¡å¸Œæœ›è·å–æ‰€æœ‰æ ·æœ¬ï¼Œä½†åªè·å–ç¬¬ä¸€åˆ—ã€‚æˆ‘ä»¬å°†å…¶æ”¾å…¥å¦ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œä»¥ä¾¿æˆ‘ä»¬æœ‰æ ·æœ¬æ•°é‡ä¹˜ä»¥ä¸€ã€‚è¿™å°†ä½¿åé¢çš„æŸäº›è®¡ç®—æ›´å®¹æ˜“ã€‚å—¯ã€‚æ‰€ä»¥ï¼Œæ˜¯çš„ã€‚
- en: and that's also convert this to a tenzoã€‚ So we can say torch dot from Numpy
    and then give this to our our to the function hereã€‚ So torch dot from Nyã€‚Soï¼Œ we
    don'tã€‚We do not need thisï¼Œ but we can do itã€‚ We can also convert it laterï¼Œ but
    we can do it right hereã€‚ So let's do thisã€‚ And let's also get the number of samplesã€‚
    So let's say self dot number of samples equals Xã€‚
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¶ä¸”è¿™ä¹Ÿå°†å…¶è½¬æ¢ä¸ºä¸€ä¸ªåç»„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è¯´ä½¿ç”¨Numpyçš„torch dotï¼Œç„¶åå°†å…¶ä¼ é€’ç»™æˆ‘ä»¬è¿™é‡Œçš„å‡½æ•°ã€‚æ‰€ä»¥torch dotæ¥è‡ªNumpyã€‚æˆ‘ä»¬ä¸éœ€è¦è¿™ä¸ªï¼Œä½†æˆ‘ä»¬å¯ä»¥åšåˆ°ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥ç¨åè½¬æ¢ï¼Œä½†æˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œç›´æ¥åšã€‚é‚£ä¹ˆæˆ‘ä»¬æ¥åšè¿™ä¸ªå§ã€‚å¹¶ä¸”è®©æˆ‘ä»¬ä¹Ÿè·å–æ ·æœ¬æ•°é‡ã€‚æ‰€ä»¥æˆ‘ä»¬å‡è®¾self
    dotæ ·æœ¬æ•°é‡ç­‰äºXã€‚
- en: Y dot shapeã€‚And then 0ã€‚ So the first dimension is the number of samplesã€‚And
    then we can return this right hereã€‚ And this is our whole length functionã€‚ So
    return self dot number of samplesã€‚ And here we can also implement this in one
    lineã€‚ So we can say return self dot X of this index and then self dot Y of this
    indexã€‚
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Y dot shapeã€‚ç„¶åæ˜¯0ã€‚å› æ­¤ç¬¬ä¸€ç»´æ˜¯æ ·æœ¬æ•°é‡ã€‚ç„¶åæˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œè¿”å›ã€‚è¿™æ˜¯æˆ‘ä»¬çš„æ•´ä¸ªé•¿åº¦å‡½æ•°ã€‚æ‰€ä»¥è¿”å›self dotæ ·æœ¬æ•°é‡ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°†å…¶å®ç°ä¸ºä¸€è¡Œã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥è¯´è¿”å›self
    dot Xçš„è¿™ä¸ªç´¢å¼•ï¼Œç„¶åself dot Yçš„è¿™ä¸ªç´¢å¼•ã€‚
- en: So this will return a tupleã€‚And yeahï¼Œ now we are doneã€‚ So this is our data set
    that we just implementedã€‚ And now let's create this data setã€‚ So let's say data
    set equals wine data setã€‚And now let's have a look at this data setã€‚ So now we
    can say first dataã€‚Equals data setã€‚ And now we can use indexingã€‚
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥è¿™å°†è¿”å›ä¸€ä¸ªå…ƒç»„ã€‚æ˜¯çš„ï¼Œç°åœ¨æˆ‘ä»¬å®Œæˆäº†ã€‚è¿™æ˜¯æˆ‘ä»¬åˆšåˆšå®ç°çš„æ•°æ®é›†ã€‚ç°åœ¨è®©æˆ‘ä»¬åˆ›å»ºè¿™ä¸ªæ•°æ®é›†ã€‚æ‰€ä»¥æˆ‘ä»¬å‡è®¾æ•°æ®é›†ç­‰äºwineæ•°æ®é›†ã€‚ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹è¿™ä¸ªæ•°æ®é›†ã€‚å› æ­¤ç°åœ¨æˆ‘ä»¬å¯ä»¥è¯´first
    dataç­‰äºæ•°æ®é›†ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç´¢å¼•ã€‚
- en: So let's have a look at the very first sampleã€‚ And now let's unpack this into
    features and labels like thisã€‚ So this is first dataã€‚ And now let's print the
    features and also print the labelsã€‚To see if this is workingã€‚ And yeahï¼Œ so we
    have one feature column or only one rowã€‚ So this is one row vectorã€‚ and then the
    labelã€‚ So the label  one in this caseã€‚And yeahã€‚
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹ç¬¬ä¸€ä¸ªæ ·æœ¬ã€‚ç°åœ¨è®©æˆ‘ä»¬å°†å…¶æ‹†åˆ†ä¸ºç‰¹å¾å’Œæ ‡ç­¾ã€‚è¿™ä¸ªæ˜¯ç¬¬ä¸€æ•°æ®ã€‚ç°åœ¨è®©æˆ‘ä»¬æ‰“å°ç‰¹å¾å¹¶æ‰“å°æ ‡ç­¾ï¼Œä»¥æŸ¥çœ‹æ˜¯å¦æœ‰æ•ˆã€‚æ˜¯çš„ï¼Œæˆ‘ä»¬æœ‰ä¸€åˆ—ç‰¹å¾æˆ–ä»…ä¸€è¡Œã€‚å› æ­¤è¿™æ˜¯ä¸€ä¸ªè¡Œå‘é‡ã€‚ç„¶åæ˜¯æ ‡ç­¾ã€‚å› æ­¤åœ¨è¿™ç§æƒ…å†µä¸‹æ ‡ç­¾æ˜¯1ã€‚æ˜¯çš„ã€‚
- en: so this is how we get the data setsã€‚ And now let's see how we use a data loader
    so we can say data loader equals the build in data loader class and then we passã€‚
    we say data set equals this data setã€‚ and then we can also give this a batch sizeã€‚
    So batch size equalsï¼Œ let's say4 in this caseã€‚ Then let's say shuffle equals trueã€‚
    which is very useful for trainingã€‚so this will shuffle the dataã€‚
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯æˆ‘ä»¬è·å–æ•°æ®é›†çš„æ–¹å¼ã€‚ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•ä½¿ç”¨æ•°æ®åŠ è½½å™¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´`data loader`ç­‰äºå†…ç½®çš„æ•°æ®åŠ è½½å™¨ç±»ï¼Œç„¶åä¼ é€’ã€‚æˆ‘ä»¬è¯´æ•°æ®é›†ç­‰äºè¿™ä¸ªæ•°æ®é›†ã€‚ç„¶åæˆ‘ä»¬ä¹Ÿå¯ä»¥ç»™å®šæ‰¹æ¬¡å¤§å°ã€‚æ‰€ä»¥æ‰¹æ¬¡å¤§å°ç­‰äºï¼Œå‡è®¾åœ¨è¿™ç§æƒ…å†µä¸‹ä¸º4ã€‚ç„¶åå‡è®¾`shuffle`ç­‰äº`true`ï¼Œè¿™å¯¹è®­ç»ƒéå¸¸æœ‰ç”¨ã€‚è¿™å°†å¯¹æ•°æ®è¿›è¡Œæ´—ç‰Œã€‚
- en: And then we also say nu workers equals 2ã€‚ So you don't need to do thisï¼Œ but
    this mightã€‚Make loading faster because it's using multiple sub processessses nowã€‚Andã€‚Yeahã€‚
    so now let's see how we can use this data loader objectã€‚ So now we can convert
    this to a iterate iteratorã€‚ So let's say data iter equalsã€‚Iter data loaderã€‚
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬è¿˜è¯´`nu workers`ç­‰äº2ã€‚æ‰€ä»¥ä½ ä¸éœ€è¦è¿™æ ·åšï¼Œä½†è¿™å¯èƒ½ä¼šä½¿åŠ è½½æ›´å¿«ï¼Œå› ä¸ºç°åœ¨ä½¿ç”¨äº†å¤šä¸ªå­è¿›ç¨‹ã€‚å¥½çš„ã€‚ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•ä½¿ç”¨è¿™ä¸ªæ•°æ®åŠ è½½å™¨å¯¹è±¡ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥å°†å…¶è½¬æ¢ä¸ºè¿­ä»£å™¨ã€‚æ‰€ä»¥å‡è®¾`data
    iter`ç­‰äº`Iter data loader`ã€‚
- en: And then we can call the next function so we can say data equals data iterã€‚Dot
    nextã€‚And then we can all againï¼Œ unpack this by saying features and labels equals
    dataã€‚ And now let's print the features and the labelsã€‚ if to see if this is workingã€‚And
    yeahã€‚ so here we have itã€‚ And here in this caseï¼Œ I specify specified the batch
    size to 4ã€‚
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬å¯ä»¥è°ƒç”¨`next`å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´`data`ç­‰äº`data iter`ã€‚`Dot next`ã€‚ç„¶åæˆ‘ä»¬å†æ¬¡è§£åŒ…ï¼Œç§°ä¸º`features`å’Œ`labels`ç­‰äº`data`ã€‚ç°åœ¨è®©æˆ‘ä»¬æ‰“å°ç‰¹å¾å’Œæ ‡ç­¾ï¼Œçœ‹çœ‹æ˜¯å¦æœ‰æ•ˆã€‚å¥½çš„ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘æŒ‡å®šäº†æ‰¹æ¬¡å¤§å°ä¸º4ã€‚
- en: This is why we see four different feature vectors hereã€‚ And then also for each
    feature vector the classã€‚ So four class labels in our labels vector or labels
    tenorã€‚And now we also can iterate over the whole data loaderã€‚ So and not only
    get the next itemã€‚ So now let's do a dummy training loopã€‚So let's specify some
    hyperparmeterã€‚ So let's sayï¼Œ nu epochsã€‚
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯æˆ‘ä»¬çœ‹åˆ°å››ä¸ªä¸åŒç‰¹å¾å‘é‡çš„åŸå› ã€‚ç„¶åå¯¹äºæ¯ä¸ªç‰¹å¾å‘é‡ï¼Œç±»æ ‡ç­¾ã€‚æ‰€ä»¥åœ¨æˆ‘ä»¬çš„æ ‡ç­¾å‘é‡æˆ–æ ‡ç­¾å¼ é‡ä¸­æœ‰å››ä¸ªç±»æ ‡ç­¾ã€‚ç°åœ¨æˆ‘ä»¬ä¹Ÿå¯ä»¥éå†æ•´ä¸ªæ•°æ®åŠ è½½å™¨ï¼Œè€Œä¸ä»…ä»…æ˜¯è·å–ä¸‹ä¸€ä¸ªé¡¹ç›®ã€‚ç°åœ¨è®©æˆ‘ä»¬è¿›è¡Œä¸€ä¸ªè™šæ‹Ÿè®­ç»ƒå¾ªç¯ã€‚å‡è®¾ä¸€äº›è¶…å‚æ•°ã€‚å‡è®¾`nu
    epochs`ã€‚
- en: Equal epoch equals 2ã€‚ And then let's get the total number of samplesã€‚ So total
    samples equals Lã€‚Of our data setã€‚And now let's get the number of iterations in
    one epochã€‚ So this isã€‚The total number of samples divided by the batch sizeï¼Œ So
    divided by 4ã€‚ And then we also have toã€‚ to seal thisã€‚ So math sealã€‚å—¯ã€‚Thisï¼Œ and
    now let's print our total samples and the number of iterationsã€‚
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾`epoch`ç­‰äº2ã€‚ç„¶åæˆ‘ä»¬è·å–æ€»æ ·æœ¬æ•°é‡ã€‚æ€»æ ·æœ¬ç­‰äºæˆ‘ä»¬çš„æ•°æ®é›†çš„Lã€‚ç°åœ¨è®©æˆ‘ä»¬è·å–ä¸€ä¸ª`epoch`ä¸­çš„è¿­ä»£æ¬¡æ•°ã€‚è¿™æ˜¯æ€»æ ·æœ¬æ•°é™¤ä»¥æ‰¹æ¬¡å¤§å°ï¼Œé™¤ä»¥4ã€‚ç„¶åæˆ‘ä»¬è¿˜éœ€è¦è¿›è¡Œå–æ•´ã€‚æ‰€ä»¥ç”¨`math
    seal`ã€‚å—¯ã€‚ç°åœ¨è®©æˆ‘ä»¬æ‰“å°æ€»æ ·æœ¬å’Œè¿­ä»£æ¬¡æ•°ã€‚
- en: And then we see we have 178 samples and 45 iterationsã€‚ So now let's do our loopã€‚
    So let's say for epoch in range number of epochsã€‚ And now we do the second loop
    and loop over the train loaderã€‚ So let's say for Iã€‚ And here we can already unpack
    this by saying inputs and labels in enumerateã€‚ And here we only put an the how
    did we call itã€‚
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬çœ‹åˆ°æœ‰178ä¸ªæ ·æœ¬å’Œ45æ¬¡è¿­ä»£ã€‚æ‰€ä»¥ç°åœ¨è®©æˆ‘ä»¬å¼€å§‹å¾ªç¯ã€‚å‡è®¾å¯¹äº`epoch`åœ¨èŒƒå›´å†…çš„epochæ•°é‡ã€‚ç°åœ¨æˆ‘ä»¬è¿›è¡Œç¬¬äºŒä¸ªå¾ªç¯ï¼Œéå†è®­ç»ƒåŠ è½½å™¨ã€‚å‡è®¾å¯¹äº`I`ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¯´`inputs`å’Œ`labels`åœ¨`enumerate`ä¸­è§£åŒ…ã€‚
- en: '![](img/c1a2854fc440d590a0a01b0cce4cb953_8.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a2854fc440d590a0a01b0cce4cb953_8.png)'
- en: Data loaderã€‚So this is all we have to doï¼Œ andã€‚Nowï¼Œ this enumerate function will
    give us the index and then alsoã€‚The inputs and the labels hereï¼Œ which is already
    unpackedã€‚And nowã€‚ what we should do typically in our training is to do our forward
    and then our backward pass and then update our weightsã€‚ So this is just a dummy
    exampleã€‚ So in this caseï¼Œ I only want to print some information about our batch
    that we have hereã€‚
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°æ®åŠ è½½å™¨ã€‚è¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦åšçš„æ‰€æœ‰äº‹æƒ…ã€‚ç°åœ¨ï¼Œè¿™ä¸ª`enumerate`å‡½æ•°å°†ç»™æˆ‘ä»¬ç´¢å¼•ï¼Œç„¶åæ˜¯`inputs`å’Œå·²ç»è§£åŒ…çš„`labels`ã€‚åœ¨è®­ç»ƒä¸­ï¼Œæˆ‘ä»¬é€šå¸¸åº”è¯¥è¿›è¡Œå‰å‘å’Œåå‘ä¼ æ’­ï¼Œç„¶åæ›´æ–°æƒé‡ã€‚è¿™åªæ˜¯ä¸€ä¸ªè™šæ‹Ÿç¤ºä¾‹ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘åªæƒ³æ‰“å°ä¸€äº›å…³äºæˆ‘ä»¬è¿™é‡Œçš„æ‰¹æ¬¡çš„ä¿¡æ¯ã€‚
- en: So let's say ifã€‚I plus 1 modo 5 equals equals0ã€‚ So every fifth stepã€‚ we want
    to print some informationã€‚ So let's print epochã€‚ And hereï¼Œ let's print the current
    epochã€‚And then all epochsã€‚ So hereï¼Œ let's say nu epochsã€‚ And then let's also print
    the current stepã€‚ So stepã€‚And this is I plus 1ã€‚And then the total stepsã€‚ So this
    isã€‚And iterations hereã€‚
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾å¦‚æœ`I + 1`æ¨¡5ç­‰äº0ã€‚é‚£ä¹ˆæ¯ç¬¬äº”æ­¥ï¼Œæˆ‘ä»¬æƒ³æ‰“å°ä¸€äº›ä¿¡æ¯ã€‚æ‰“å°`epoch`ã€‚åœ¨è¿™é‡Œï¼Œè®©æˆ‘ä»¬æ‰“å°å½“å‰çš„`epoch`ã€‚ç„¶åæ‰€æœ‰çš„`epoch`ï¼Œå‡è®¾`nu
    epochs`ã€‚ç„¶åæˆ‘ä»¬ä¹Ÿæ‰“å°å½“å‰æ­¥éª¤ã€‚æ­¥éª¤ä¸º`I + 1`ã€‚ç„¶åæ˜¯æ€»æ­¥éª¤ï¼Œè¿™å°±æ˜¯è¿­ä»£æ¬¡æ•°ã€‚
- en: And then let's also print some information about our inputã€‚ So inputsã€‚ And let's
    say here we want to print input dot shape onlyã€‚And yeahã€‚ now let's run this to
    see if this is workingã€‚And yeahï¼Œ so here we see our print statementsã€‚ So we see
    that we have two epochs and in every epochï¼Œ we have 45 steps and every fifth stepã€‚
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬ä¹Ÿæ‰“å°ä¸€äº›å…³äºè¾“å…¥çš„ä¿¡æ¯ã€‚æ‰€ä»¥è¾“å…¥ã€‚å‡è®¾æˆ‘ä»¬æƒ³åªæ‰“å° `input.shape`ã€‚å¥½çš„ï¼Œç°åœ¨è®©æˆ‘ä»¬è¿è¡Œä¸€ä¸‹ï¼Œçœ‹çœ‹å®ƒæ˜¯å¦æ­£å¸¸å·¥ä½œã€‚æ˜¯çš„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œçœ‹åˆ°äº†æ‰“å°è¯­å¥ã€‚æˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬æœ‰ä¸¤ä¸ªè½®æ¬¡ï¼Œæ¯ä¸ªè½®æ¬¡æœ‰
    45 æ­¥ï¼Œæ¯ç¬¬äº”æ­¥æˆ‘ä»¬æ‰“å°ä¸€äº›ä¿¡æ¯ã€‚
- en: we print some informationã€‚And we also see that our Tenzoar is 4 by 13ã€‚ So we
    have our batch size is 4 and then 30 different features in each batchã€‚And yeahã€‚
    so that's how we use theã€‚Data set and the data loader classesã€‚ And then we can
    very easily get a single patchã€‚Single besã€‚å—¯ï¼Œè¿™æ ·ã€‚Of courseã€‚
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜çœ‹åˆ°æˆ‘ä»¬çš„ Tensor æ˜¯ 4 x 13ã€‚æ‰€ä»¥æˆ‘ä»¬çš„æ‰¹é‡å¤§å°æ˜¯ 4ï¼Œæ¯ä¸ªæ‰¹æ¬¡æœ‰ 30 ä¸ªä¸åŒçš„ç‰¹å¾ã€‚å¥½çš„ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨æ•°æ®é›†å’Œæ•°æ®åŠ è½½å™¨ç±»ã€‚ç„¶åæˆ‘ä»¬å¯ä»¥éå¸¸è½»æ¾åœ°è·å–ä¸€ä¸ªå•ç‹¬çš„æ‰¹æ¬¡ã€‚å•ä¸ªæ‰¹æ¬¡ã€‚å—¯ï¼Œè¿™æ ·ã€‚å½“ç„¶ã€‚
- en: Pytorch also has some already built in data setsã€‚ Soï¼Œ for exampleã€‚ from torch
    Viion dot data sets dotã€‚Amistï¼Œ we get the famous Amist data setã€‚ and for exampleã€‚
    we can also get the fashion Ams data set or the scipherã€‚And a data set or the
    coco data setã€‚ And yeahï¼Œ so the M this data is one that we will use in one of
    the next tutorialsã€‚ And for nowã€‚
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Pytorch è¿˜å†…ç½®äº†ä¸€äº›æ•°æ®é›†ã€‚å› æ­¤ï¼Œä¾‹å¦‚ï¼Œä» `torchvision.datasets.AMNIST`ï¼Œæˆ‘ä»¬å¯ä»¥è·å–è‘—åçš„ MNIST æ•°æ®é›†ã€‚æˆ‘ä»¬è¿˜å¯ä»¥è·å–
    Fashion MNIST æ•°æ®é›†æˆ– CIFAR æ•°æ®é›†ï¼Œç”šè‡³æ˜¯ COCO æ•°æ®é›†ã€‚æ˜¯çš„ï¼Œè¿™ä¸ªæ•°æ®é›†æ˜¯æˆ‘ä»¬åœ¨æ¥ä¸‹æ¥çš„æ•™ç¨‹ä¸­ä¼šä½¿ç”¨çš„ã€‚ç°åœ¨ã€‚
- en: this is what I wanted to show you about the data and data loader classesã€‚ I
    hope you liked itã€‚ and please subscribe to the channel and see you next timeï¼Œ
    byeã€‚![](img/c1a2854fc440d590a0a01b0cce4cb953_10.png)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯æˆ‘æƒ³å‘ä½ å±•ç¤ºçš„æ•°æ®å’Œæ•°æ®åŠ è½½å™¨ç±»ã€‚æˆ‘å¸Œæœ›ä½ å–œæ¬¢å®ƒï¼Œè¯·è®¢é˜…é¢‘é“ï¼Œä¸‹æ¬¡è§ï¼Œå†è§ï¼![](img/c1a2854fc440d590a0a01b0cce4cb953_10.png)
