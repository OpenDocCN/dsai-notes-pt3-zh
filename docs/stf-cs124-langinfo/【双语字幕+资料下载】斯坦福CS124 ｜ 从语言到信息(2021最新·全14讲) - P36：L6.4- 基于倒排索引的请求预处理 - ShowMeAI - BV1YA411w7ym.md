# ã€åŒè¯­å­—å¹•+èµ„æ–™ä¸‹è½½ã€‘æ–¯å¦ç¦CS124 ï½œ ä»è¯­è¨€åˆ°ä¿¡æ¯(2021æœ€æ–°Â·å…¨14è®²) - P36ï¼šL6.4- åŸºäºå€’æ’ç´¢å¼•çš„è¯·æ±‚é¢„å¤„ç† - ShowMeAI - BV1YA411w7ym

In this segmentï¼Œ we're going to keep on looking at the inverted index and see how it's an efficient data structure for doing query operations in an IR system and in particular we'll step through in detail how you can perform a common kind of query and an query for two termsã€‚

ğŸ˜Šã€‚

![](img/c5e0b7f7eb2f95b5e17177f959ed497d_1.png)

So starting off nowï¼Œ we'll look at the details of query processingã€‚

 and then we'll have a later segment where we'll talk even in more detail about the kind of queries we can processã€‚

ğŸ˜Šï¼ŒSo suppose we want to process a queryã€‚So suppose our query is Brutus and Caesarã€‚Wellã€‚

Let me even do a simpler example than thatã€‚ Suppose the very first kind of query one we want to look at is just a query for Brutusã€‚

 Wellï¼Œ how to do that is totally straightforwardã€‚ What we do is locate Brutus in theã€‚Dictionaryã€‚

 and then we return its postings list that we look up and sayï¼Œ okayã€‚

 this is the set of documents where Brutus occursï¼Œ and we don't need to do anything elseã€‚

But now let's go to that fractionï¼Œ more complicated caseã€‚ Wellã€‚

 then we're going to locate for Brutus and Caesarã€‚ We're going to locate both the words in the dictionaryã€‚

 look up their postings listsã€‚ And what we'd like to do is then work out what are the documents that contain both Brutus and Caesarã€‚

 and doing the putting them together is standardly referred to as merging the two postings listsã€‚

 Nowï¼Œ that term can actually be misleadingï¼Œ because what we're doing for an an query is we're actually intersecting the two sets of documents to find the documents that in which both words occurã€‚

 whereas merging suggests doing some kind of putting them together in a union operationã€‚

 But the term merge is used actually in both casesã€‚

 So the merge algorithm family refers to a family of algorithms where you can step through a pair of sorted lists and do various boolean operations on itã€‚

'sã€‚ğŸ˜Šï¼ŒIn concrete detailï¼Œ how that happensã€‚Okayï¼Œ so the way we do merge operation to do Brutus and Caesar is like thisã€‚

We start with a pointer which points at the head of both listsã€‚

And what we're going to be wanting to doã€‚Is then work outã€‚What's in their intersectionã€‚

 So the way we do that is we askï¼Œ are these two pointers pointing at the same an equal doc I Dã€‚

 And the answer is noã€‚ And so what we do is then advance theã€‚Pointer that has the smaller dock Idã€‚

 So now our two pointers like thisã€‚ And we sayï¼Œ doesã€‚Thisã€‚

Are the two pointers pointing at the same document I Dã€‚ And hereï¼Œ the answer is yesã€‚

 So we put that into a result listã€‚ And then if we've done thatï¼Œ we can then advance both pointersã€‚

We now sayï¼Œ are these pointers both pointing at the same doc Iï¼Œ Noã€‚

 is the first list greater first the thing pointed to by the first list pointer greater than the thing pointed to by the second list pointerã€‚

 Noï¼Œ So we advance the bottom pointer oneã€‚Then we say is the doc ID pointed out by the two pointers equalã€‚

 noï¼Œ and so againï¼Œ we advance the smaller oneã€‚Equalï¼Œ noï¼Œ advance a smaller oneã€‚ At this pointã€‚

 they're againï¼Œ both pointing at the same dock I Dã€‚ So we add that to our results setã€‚

 and we advance both pointersã€‚Are they the sameï¼Œ noï¼Œ what we do is advance the smaller oneã€‚

Are they the sameï¼Œ Noï¼Œ we advance the smaller oneã€‚Sameï¼Œ noï¼Œ advanceï¼Œ the smaller oneã€‚Sameï¼Œ noã€‚

 advance a smaller oneã€‚Same noã€‚ And at this pointï¼Œ when we try and advance the smaller oneã€‚

 one of our lists is exhaustedã€‚ And so then there can be no other items in the intersectionã€‚

 And so we can stopã€‚ And so this is our return documents setã€‚

 documentsments 2 and 8 contained both Brutus and Caesarã€‚

So I hope we went through that carefully enough that you can see that if the list lengths are x and yã€‚

 then this merge algorithm takes Biggo x plus y time that it's linear in the sum of the lengths of the two postings listsã€‚

ğŸ˜Šï¼ŒAnd you should also have seen what's crucial to make this operation linearã€‚

 And what's crucial to making it linear is the fact that these postings lists were sorted in order of document I Dã€‚

 precisely because of thatï¼Œ we could do a linear scan through the two postings listã€‚

 Where if that hadn't been the caseï¼Œ then it would have turned into an n squared algorithmã€‚Okayã€‚

 here's the postings list intersection algorithm one more times the real algorithmã€‚

 but hopefully you can see it's doing exactly the same as what I was by hand so we start here with the answer set0 and then we're going to be doing this while loop whileã€‚

ğŸ˜Šï¼ŒThe postings lists are both not equal to nil because as soon as one's nilï¼Œ we can stopã€‚

 So it's the end operationã€‚ Okayï¼Œ so then at each stepã€‚

 what we do is ask whether the two the document idea of the two pointers is the same If soã€‚

 we add it to our answerã€‚ If notï¼Œ and sorryï¼Œ and ifã€‚They are the sameã€‚ We can advance both pointersã€‚

 and if notï¼Œ we work out which doc IDã€‚Is smaller and then we advanced that pointer so either this one or this one and that was exactly what I was doing and then where soon as one of the document lists runs outã€‚

 we can return our answer setã€‚

![](img/c5e0b7f7eb2f95b5e17177f959ed497d_3.png)

Okayï¼Œ I hope that made sense and you now feel like you could write your own code to do the intersection of posting lists using the mergeG algorithmã€‚

ğŸ˜Šã€‚

![](img/c5e0b7f7eb2f95b5e17177f959ed497d_5.png)

Okayã€‚